
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Otp
 * 
 */
export type Otp = $Result.DefaultSelection<Prisma.$OtpPayload>
/**
 * Model panVerificationData
 * 
 */
export type panVerificationData = $Result.DefaultSelection<Prisma.$panVerificationDataPayload>
/**
 * Model UserPurchasedServices
 * 
 */
export type UserPurchasedServices = $Result.DefaultSelection<Prisma.$UserPurchasedServicesPayload>
/**
 * Model Coupon
 * 
 */
export type Coupon = $Result.DefaultSelection<Prisma.$CouponPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model UserDocuments
 * 
 */
export type UserDocuments = $Result.DefaultSelection<Prisma.$UserDocumentsPayload>
/**
 * Model Agreement
 * 
 */
export type Agreement = $Result.DefaultSelection<Prisma.$AgreementPayload>
/**
 * Model ServiceAgreement
 * 
 */
export type ServiceAgreement = $Result.DefaultSelection<Prisma.$ServiceAgreementPayload>
/**
 * Model ComboPlanAgreement
 * 
 */
export type ComboPlanAgreement = $Result.DefaultSelection<Prisma.$ComboPlanAgreementPayload>
/**
 * Model ComboPlan
 * 
 */
export type ComboPlan = $Result.DefaultSelection<Prisma.$ComboPlanPayload>
/**
 * Model ComboPlanService
 * 
 */
export type ComboPlanService = $Result.DefaultSelection<Prisma.$ComboPlanServicePayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ServiceTrading
 * 
 */
export type ServiceTrading = $Result.DefaultSelection<Prisma.$ServiceTradingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserType: {
  INDIVIDUAL: 'INDIVIDUAL',
  BUSINESS: 'BUSINESS'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const Status: {
  CLOSED_CALL: 'CLOSED_CALL',
  ACTIVE_CALL: 'ACTIVE_CALL'
};

export type Status = (typeof Status)[keyof typeof Status]


export const DocumentStatus: {
  PENDING: 'PENDING',
  UNDER_REVIEW: 'UNDER_REVIEW',
  RESUBMISSION_REQUIRED: 'RESUBMISSION_REQUIRED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type DocumentStatus = (typeof DocumentStatus)[keyof typeof DocumentStatus]


export const ServiceType: {
  TRADING: 'TRADING',
  RESEARCH_ADVISORY: 'RESEARCH_ADVISORY',
  RESEARCH_ADVISORY_MODEL_PORTFOLIO: 'RESEARCH_ADVISORY_MODEL_PORTFOLIO',
  RESEARCH_ADVISORY_PORTFOLIO_REVIEW: 'RESEARCH_ADVISORY_PORTFOLIO_REVIEW',
  INVESTMENT_ADVISORY: 'INVESTMENT_ADVISORY',
  RESEARCH_ADVISORY_MUTUAL_FUNDS: 'RESEARCH_ADVISORY_MUTUAL_FUNDS',
  SMALLCASE: 'SMALLCASE'
};

export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType]


export const VerificationType: {
  EMAIL_UPDATE: 'EMAIL_UPDATE',
  PHONE_UPDATE: 'PHONE_UPDATE',
  EMAIL_VERIFY: 'EMAIL_VERIFY',
  PHONE_VERIFY: 'PHONE_VERIFY',
  RESET_PASS_VERIFY: 'RESET_PASS_VERIFY',
  CONSENT: 'CONSENT',
  AGREEMENT_ACCEPTANCE: 'AGREEMENT_ACCEPTANCE'
};

export type VerificationType = (typeof VerificationType)[keyof typeof VerificationType]

}

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type DocumentStatus = $Enums.DocumentStatus

export const DocumentStatus: typeof $Enums.DocumentStatus

export type ServiceType = $Enums.ServiceType

export const ServiceType: typeof $Enums.ServiceType

export type VerificationType = $Enums.VerificationType

export const VerificationType: typeof $Enums.VerificationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.panVerificationData`: Exposes CRUD operations for the **panVerificationData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PanVerificationData
    * const panVerificationData = await prisma.panVerificationData.findMany()
    * ```
    */
  get panVerificationData(): Prisma.panVerificationDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPurchasedServices`: Exposes CRUD operations for the **UserPurchasedServices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPurchasedServices
    * const userPurchasedServices = await prisma.userPurchasedServices.findMany()
    * ```
    */
  get userPurchasedServices(): Prisma.UserPurchasedServicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coupon`: Exposes CRUD operations for the **Coupon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coupons
    * const coupons = await prisma.coupon.findMany()
    * ```
    */
  get coupon(): Prisma.CouponDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userDocuments`: Exposes CRUD operations for the **UserDocuments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserDocuments
    * const userDocuments = await prisma.userDocuments.findMany()
    * ```
    */
  get userDocuments(): Prisma.UserDocumentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agreement`: Exposes CRUD operations for the **Agreement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agreements
    * const agreements = await prisma.agreement.findMany()
    * ```
    */
  get agreement(): Prisma.AgreementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceAgreement`: Exposes CRUD operations for the **ServiceAgreement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceAgreements
    * const serviceAgreements = await prisma.serviceAgreement.findMany()
    * ```
    */
  get serviceAgreement(): Prisma.ServiceAgreementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comboPlanAgreement`: Exposes CRUD operations for the **ComboPlanAgreement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComboPlanAgreements
    * const comboPlanAgreements = await prisma.comboPlanAgreement.findMany()
    * ```
    */
  get comboPlanAgreement(): Prisma.ComboPlanAgreementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comboPlan`: Exposes CRUD operations for the **ComboPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComboPlans
    * const comboPlans = await prisma.comboPlan.findMany()
    * ```
    */
  get comboPlan(): Prisma.ComboPlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comboPlanService`: Exposes CRUD operations for the **ComboPlanService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComboPlanServices
    * const comboPlanServices = await prisma.comboPlanService.findMany()
    * ```
    */
  get comboPlanService(): Prisma.ComboPlanServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceTrading`: Exposes CRUD operations for the **ServiceTrading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceTradings
    * const serviceTradings = await prisma.serviceTrading.findMany()
    * ```
    */
  get serviceTrading(): Prisma.ServiceTradingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Account: 'Account',
    Otp: 'Otp',
    panVerificationData: 'panVerificationData',
    UserPurchasedServices: 'UserPurchasedServices',
    Coupon: 'Coupon',
    Transaction: 'Transaction',
    UserDocuments: 'UserDocuments',
    Agreement: 'Agreement',
    ServiceAgreement: 'ServiceAgreement',
    ComboPlanAgreement: 'ComboPlanAgreement',
    ComboPlan: 'ComboPlan',
    ComboPlanService: 'ComboPlanService',
    Service: 'Service',
    ServiceTrading: 'ServiceTrading'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "account" | "otp" | "panVerificationData" | "userPurchasedServices" | "coupon" | "transaction" | "userDocuments" | "agreement" | "serviceAgreement" | "comboPlanAgreement" | "comboPlan" | "comboPlanService" | "service" | "serviceTrading"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: Prisma.$OtpPayload<ExtArgs>
        fields: Prisma.OtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OtpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      panVerificationData: {
        payload: Prisma.$panVerificationDataPayload<ExtArgs>
        fields: Prisma.panVerificationDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.panVerificationDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panVerificationDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.panVerificationDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panVerificationDataPayload>
          }
          findFirst: {
            args: Prisma.panVerificationDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panVerificationDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.panVerificationDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panVerificationDataPayload>
          }
          findMany: {
            args: Prisma.panVerificationDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panVerificationDataPayload>[]
          }
          create: {
            args: Prisma.panVerificationDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panVerificationDataPayload>
          }
          createMany: {
            args: Prisma.panVerificationDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.panVerificationDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panVerificationDataPayload>[]
          }
          delete: {
            args: Prisma.panVerificationDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panVerificationDataPayload>
          }
          update: {
            args: Prisma.panVerificationDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panVerificationDataPayload>
          }
          deleteMany: {
            args: Prisma.panVerificationDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.panVerificationDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.panVerificationDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panVerificationDataPayload>[]
          }
          upsert: {
            args: Prisma.panVerificationDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$panVerificationDataPayload>
          }
          aggregate: {
            args: Prisma.PanVerificationDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePanVerificationData>
          }
          groupBy: {
            args: Prisma.panVerificationDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<PanVerificationDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.panVerificationDataCountArgs<ExtArgs>
            result: $Utils.Optional<PanVerificationDataCountAggregateOutputType> | number
          }
        }
      }
      UserPurchasedServices: {
        payload: Prisma.$UserPurchasedServicesPayload<ExtArgs>
        fields: Prisma.UserPurchasedServicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPurchasedServicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPurchasedServicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPurchasedServicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPurchasedServicesPayload>
          }
          findFirst: {
            args: Prisma.UserPurchasedServicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPurchasedServicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPurchasedServicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPurchasedServicesPayload>
          }
          findMany: {
            args: Prisma.UserPurchasedServicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPurchasedServicesPayload>[]
          }
          create: {
            args: Prisma.UserPurchasedServicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPurchasedServicesPayload>
          }
          createMany: {
            args: Prisma.UserPurchasedServicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPurchasedServicesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPurchasedServicesPayload>[]
          }
          delete: {
            args: Prisma.UserPurchasedServicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPurchasedServicesPayload>
          }
          update: {
            args: Prisma.UserPurchasedServicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPurchasedServicesPayload>
          }
          deleteMany: {
            args: Prisma.UserPurchasedServicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPurchasedServicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPurchasedServicesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPurchasedServicesPayload>[]
          }
          upsert: {
            args: Prisma.UserPurchasedServicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPurchasedServicesPayload>
          }
          aggregate: {
            args: Prisma.UserPurchasedServicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPurchasedServices>
          }
          groupBy: {
            args: Prisma.UserPurchasedServicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPurchasedServicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPurchasedServicesCountArgs<ExtArgs>
            result: $Utils.Optional<UserPurchasedServicesCountAggregateOutputType> | number
          }
        }
      }
      Coupon: {
        payload: Prisma.$CouponPayload<ExtArgs>
        fields: Prisma.CouponFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CouponFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CouponFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findFirst: {
            args: Prisma.CouponFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CouponFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          findMany: {
            args: Prisma.CouponFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          create: {
            args: Prisma.CouponCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          createMany: {
            args: Prisma.CouponCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CouponCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          delete: {
            args: Prisma.CouponDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          update: {
            args: Prisma.CouponUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          deleteMany: {
            args: Prisma.CouponDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CouponUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CouponUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>[]
          }
          upsert: {
            args: Prisma.CouponUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CouponPayload>
          }
          aggregate: {
            args: Prisma.CouponAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoupon>
          }
          groupBy: {
            args: Prisma.CouponGroupByArgs<ExtArgs>
            result: $Utils.Optional<CouponGroupByOutputType>[]
          }
          count: {
            args: Prisma.CouponCountArgs<ExtArgs>
            result: $Utils.Optional<CouponCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      UserDocuments: {
        payload: Prisma.$UserDocumentsPayload<ExtArgs>
        fields: Prisma.UserDocumentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserDocumentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDocumentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserDocumentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDocumentsPayload>
          }
          findFirst: {
            args: Prisma.UserDocumentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDocumentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserDocumentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDocumentsPayload>
          }
          findMany: {
            args: Prisma.UserDocumentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDocumentsPayload>[]
          }
          create: {
            args: Prisma.UserDocumentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDocumentsPayload>
          }
          createMany: {
            args: Prisma.UserDocumentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserDocumentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDocumentsPayload>[]
          }
          delete: {
            args: Prisma.UserDocumentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDocumentsPayload>
          }
          update: {
            args: Prisma.UserDocumentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDocumentsPayload>
          }
          deleteMany: {
            args: Prisma.UserDocumentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserDocumentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserDocumentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDocumentsPayload>[]
          }
          upsert: {
            args: Prisma.UserDocumentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserDocumentsPayload>
          }
          aggregate: {
            args: Prisma.UserDocumentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserDocuments>
          }
          groupBy: {
            args: Prisma.UserDocumentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserDocumentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserDocumentsCountArgs<ExtArgs>
            result: $Utils.Optional<UserDocumentsCountAggregateOutputType> | number
          }
        }
      }
      Agreement: {
        payload: Prisma.$AgreementPayload<ExtArgs>
        fields: Prisma.AgreementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgreementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgreementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          findFirst: {
            args: Prisma.AgreementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgreementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          findMany: {
            args: Prisma.AgreementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>[]
          }
          create: {
            args: Prisma.AgreementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          createMany: {
            args: Prisma.AgreementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgreementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>[]
          }
          delete: {
            args: Prisma.AgreementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          update: {
            args: Prisma.AgreementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          deleteMany: {
            args: Prisma.AgreementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgreementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgreementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>[]
          }
          upsert: {
            args: Prisma.AgreementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgreementPayload>
          }
          aggregate: {
            args: Prisma.AgreementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgreement>
          }
          groupBy: {
            args: Prisma.AgreementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgreementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgreementCountArgs<ExtArgs>
            result: $Utils.Optional<AgreementCountAggregateOutputType> | number
          }
        }
      }
      ServiceAgreement: {
        payload: Prisma.$ServiceAgreementPayload<ExtArgs>
        fields: Prisma.ServiceAgreementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceAgreementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAgreementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceAgreementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAgreementPayload>
          }
          findFirst: {
            args: Prisma.ServiceAgreementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAgreementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceAgreementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAgreementPayload>
          }
          findMany: {
            args: Prisma.ServiceAgreementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAgreementPayload>[]
          }
          create: {
            args: Prisma.ServiceAgreementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAgreementPayload>
          }
          createMany: {
            args: Prisma.ServiceAgreementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceAgreementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAgreementPayload>[]
          }
          delete: {
            args: Prisma.ServiceAgreementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAgreementPayload>
          }
          update: {
            args: Prisma.ServiceAgreementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAgreementPayload>
          }
          deleteMany: {
            args: Prisma.ServiceAgreementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceAgreementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceAgreementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAgreementPayload>[]
          }
          upsert: {
            args: Prisma.ServiceAgreementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAgreementPayload>
          }
          aggregate: {
            args: Prisma.ServiceAgreementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceAgreement>
          }
          groupBy: {
            args: Prisma.ServiceAgreementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceAgreementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceAgreementCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceAgreementCountAggregateOutputType> | number
          }
        }
      }
      ComboPlanAgreement: {
        payload: Prisma.$ComboPlanAgreementPayload<ExtArgs>
        fields: Prisma.ComboPlanAgreementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComboPlanAgreementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanAgreementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComboPlanAgreementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanAgreementPayload>
          }
          findFirst: {
            args: Prisma.ComboPlanAgreementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanAgreementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComboPlanAgreementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanAgreementPayload>
          }
          findMany: {
            args: Prisma.ComboPlanAgreementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanAgreementPayload>[]
          }
          create: {
            args: Prisma.ComboPlanAgreementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanAgreementPayload>
          }
          createMany: {
            args: Prisma.ComboPlanAgreementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComboPlanAgreementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanAgreementPayload>[]
          }
          delete: {
            args: Prisma.ComboPlanAgreementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanAgreementPayload>
          }
          update: {
            args: Prisma.ComboPlanAgreementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanAgreementPayload>
          }
          deleteMany: {
            args: Prisma.ComboPlanAgreementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComboPlanAgreementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComboPlanAgreementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanAgreementPayload>[]
          }
          upsert: {
            args: Prisma.ComboPlanAgreementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanAgreementPayload>
          }
          aggregate: {
            args: Prisma.ComboPlanAgreementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComboPlanAgreement>
          }
          groupBy: {
            args: Prisma.ComboPlanAgreementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComboPlanAgreementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComboPlanAgreementCountArgs<ExtArgs>
            result: $Utils.Optional<ComboPlanAgreementCountAggregateOutputType> | number
          }
        }
      }
      ComboPlan: {
        payload: Prisma.$ComboPlanPayload<ExtArgs>
        fields: Prisma.ComboPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComboPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComboPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanPayload>
          }
          findFirst: {
            args: Prisma.ComboPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComboPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanPayload>
          }
          findMany: {
            args: Prisma.ComboPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanPayload>[]
          }
          create: {
            args: Prisma.ComboPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanPayload>
          }
          createMany: {
            args: Prisma.ComboPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComboPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanPayload>[]
          }
          delete: {
            args: Prisma.ComboPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanPayload>
          }
          update: {
            args: Prisma.ComboPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanPayload>
          }
          deleteMany: {
            args: Prisma.ComboPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComboPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComboPlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanPayload>[]
          }
          upsert: {
            args: Prisma.ComboPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanPayload>
          }
          aggregate: {
            args: Prisma.ComboPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComboPlan>
          }
          groupBy: {
            args: Prisma.ComboPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComboPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComboPlanCountArgs<ExtArgs>
            result: $Utils.Optional<ComboPlanCountAggregateOutputType> | number
          }
        }
      }
      ComboPlanService: {
        payload: Prisma.$ComboPlanServicePayload<ExtArgs>
        fields: Prisma.ComboPlanServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComboPlanServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComboPlanServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanServicePayload>
          }
          findFirst: {
            args: Prisma.ComboPlanServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComboPlanServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanServicePayload>
          }
          findMany: {
            args: Prisma.ComboPlanServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanServicePayload>[]
          }
          create: {
            args: Prisma.ComboPlanServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanServicePayload>
          }
          createMany: {
            args: Prisma.ComboPlanServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComboPlanServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanServicePayload>[]
          }
          delete: {
            args: Prisma.ComboPlanServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanServicePayload>
          }
          update: {
            args: Prisma.ComboPlanServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanServicePayload>
          }
          deleteMany: {
            args: Prisma.ComboPlanServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComboPlanServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComboPlanServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanServicePayload>[]
          }
          upsert: {
            args: Prisma.ComboPlanServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboPlanServicePayload>
          }
          aggregate: {
            args: Prisma.ComboPlanServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComboPlanService>
          }
          groupBy: {
            args: Prisma.ComboPlanServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComboPlanServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComboPlanServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ComboPlanServiceCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceTrading: {
        payload: Prisma.$ServiceTradingPayload<ExtArgs>
        fields: Prisma.ServiceTradingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceTradingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTradingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceTradingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTradingPayload>
          }
          findFirst: {
            args: Prisma.ServiceTradingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTradingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceTradingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTradingPayload>
          }
          findMany: {
            args: Prisma.ServiceTradingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTradingPayload>[]
          }
          create: {
            args: Prisma.ServiceTradingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTradingPayload>
          }
          createMany: {
            args: Prisma.ServiceTradingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceTradingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTradingPayload>[]
          }
          delete: {
            args: Prisma.ServiceTradingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTradingPayload>
          }
          update: {
            args: Prisma.ServiceTradingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTradingPayload>
          }
          deleteMany: {
            args: Prisma.ServiceTradingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceTradingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceTradingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTradingPayload>[]
          }
          upsert: {
            args: Prisma.ServiceTradingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTradingPayload>
          }
          aggregate: {
            args: Prisma.ServiceTradingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceTrading>
          }
          groupBy: {
            args: Prisma.ServiceTradingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceTradingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceTradingCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceTradingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    account?: AccountOmit
    otp?: OtpOmit
    panVerificationData?: panVerificationDataOmit
    userPurchasedServices?: UserPurchasedServicesOmit
    coupon?: CouponOmit
    transaction?: TransactionOmit
    userDocuments?: UserDocumentsOmit
    agreement?: AgreementOmit
    serviceAgreement?: ServiceAgreementOmit
    comboPlanAgreement?: ComboPlanAgreementOmit
    comboPlan?: ComboPlanOmit
    comboPlanService?: ComboPlanServiceOmit
    service?: ServiceOmit
    serviceTrading?: ServiceTradingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    documents: number
    purchasedServices: number
    panVerificationData: number
    transaction: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    purchasedServices?: boolean | UserCountOutputTypeCountPurchasedServicesArgs
    panVerificationData?: boolean | UserCountOutputTypeCountPanVerificationDataArgs
    transaction?: boolean | UserCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDocumentsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchasedServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPurchasedServicesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPanVerificationDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: panVerificationDataWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type CouponCountOutputType
   */

  export type CouponCountOutputType = {
    transactions: number
  }

  export type CouponCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CouponCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CouponCountOutputType
     */
    select?: CouponCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CouponCountOutputType without action
   */
  export type CouponCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type AgreementCountOutputType
   */

  export type AgreementCountOutputType = {
    serviceAgreements: number
    comboPlanAgreements: number
  }

  export type AgreementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceAgreements?: boolean | AgreementCountOutputTypeCountServiceAgreementsArgs
    comboPlanAgreements?: boolean | AgreementCountOutputTypeCountComboPlanAgreementsArgs
  }

  // Custom InputTypes
  /**
   * AgreementCountOutputType without action
   */
  export type AgreementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgreementCountOutputType
     */
    select?: AgreementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgreementCountOutputType without action
   */
  export type AgreementCountOutputTypeCountServiceAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAgreementWhereInput
  }

  /**
   * AgreementCountOutputType without action
   */
  export type AgreementCountOutputTypeCountComboPlanAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComboPlanAgreementWhereInput
  }


  /**
   * Count Type ComboPlanCountOutputType
   */

  export type ComboPlanCountOutputType = {
    agreement: number
    services: number
    coupon: number
    Transaction: number
  }

  export type ComboPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agreement?: boolean | ComboPlanCountOutputTypeCountAgreementArgs
    services?: boolean | ComboPlanCountOutputTypeCountServicesArgs
    coupon?: boolean | ComboPlanCountOutputTypeCountCouponArgs
    Transaction?: boolean | ComboPlanCountOutputTypeCountTransactionArgs
  }

  // Custom InputTypes
  /**
   * ComboPlanCountOutputType without action
   */
  export type ComboPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanCountOutputType
     */
    select?: ComboPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ComboPlanCountOutputType without action
   */
  export type ComboPlanCountOutputTypeCountAgreementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComboPlanAgreementWhereInput
  }

  /**
   * ComboPlanCountOutputType without action
   */
  export type ComboPlanCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComboPlanServiceWhereInput
  }

  /**
   * ComboPlanCountOutputType without action
   */
  export type ComboPlanCountOutputTypeCountCouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
  }

  /**
   * ComboPlanCountOutputType without action
   */
  export type ComboPlanCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    agreements: number
    purchasedServices: number
    userDocuments: number
    Transaction: number
    ComboPlanService: number
    coupon: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agreements?: boolean | ServiceCountOutputTypeCountAgreementsArgs
    purchasedServices?: boolean | ServiceCountOutputTypeCountPurchasedServicesArgs
    userDocuments?: boolean | ServiceCountOutputTypeCountUserDocumentsArgs
    Transaction?: boolean | ServiceCountOutputTypeCountTransactionArgs
    ComboPlanService?: boolean | ServiceCountOutputTypeCountComboPlanServiceArgs
    coupon?: boolean | ServiceCountOutputTypeCountCouponArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAgreementWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountPurchasedServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPurchasedServicesWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountUserDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDocumentsWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountComboPlanServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComboPlanServiceWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountCouponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    username: string | null
    image: string | null
    password: string | null
    dob: string | null
    pan: string | null
    aadharNumber: string | null
    gstin: string | null
    address: string | null
    state: string | null
    city: string | null
    zip: string | null
    panVerified: Date | null
    termsAccepted: Date | null
    emailVerified: Date | null
    phoneVerified: Date | null
    isBanned: boolean | null
    userType: $Enums.UserType | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    username: string | null
    image: string | null
    password: string | null
    dob: string | null
    pan: string | null
    aadharNumber: string | null
    gstin: string | null
    address: string | null
    state: string | null
    city: string | null
    zip: string | null
    panVerified: Date | null
    termsAccepted: Date | null
    emailVerified: Date | null
    phoneVerified: Date | null
    isBanned: boolean | null
    userType: $Enums.UserType | null
    role: $Enums.UserRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    username: number
    image: number
    password: number
    dob: number
    pan: number
    aadharNumber: number
    gstin: number
    address: number
    state: number
    city: number
    zip: number
    panVerified: number
    termsAccepted: number
    emailVerified: number
    phoneVerified: number
    isBanned: number
    userType: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    username?: true
    image?: true
    password?: true
    dob?: true
    pan?: true
    aadharNumber?: true
    gstin?: true
    address?: true
    state?: true
    city?: true
    zip?: true
    panVerified?: true
    termsAccepted?: true
    emailVerified?: true
    phoneVerified?: true
    isBanned?: true
    userType?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    username?: true
    image?: true
    password?: true
    dob?: true
    pan?: true
    aadharNumber?: true
    gstin?: true
    address?: true
    state?: true
    city?: true
    zip?: true
    panVerified?: true
    termsAccepted?: true
    emailVerified?: true
    phoneVerified?: true
    isBanned?: true
    userType?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    username?: true
    image?: true
    password?: true
    dob?: true
    pan?: true
    aadharNumber?: true
    gstin?: true
    address?: true
    state?: true
    city?: true
    zip?: true
    panVerified?: true
    termsAccepted?: true
    emailVerified?: true
    phoneVerified?: true
    isBanned?: true
    userType?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    phone: string | null
    username: string | null
    image: string | null
    password: string | null
    dob: string | null
    pan: string | null
    aadharNumber: string | null
    gstin: string | null
    address: string | null
    state: string | null
    city: string | null
    zip: string | null
    panVerified: Date | null
    termsAccepted: Date | null
    emailVerified: Date | null
    phoneVerified: Date | null
    isBanned: boolean
    userType: $Enums.UserType
    role: $Enums.UserRole
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    username?: boolean
    image?: boolean
    password?: boolean
    dob?: boolean
    pan?: boolean
    aadharNumber?: boolean
    gstin?: boolean
    address?: boolean
    state?: boolean
    city?: boolean
    zip?: boolean
    panVerified?: boolean
    termsAccepted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    isBanned?: boolean
    userType?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    purchasedServices?: boolean | User$purchasedServicesArgs<ExtArgs>
    panVerificationData?: boolean | User$panVerificationDataArgs<ExtArgs>
    transaction?: boolean | User$transactionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    username?: boolean
    image?: boolean
    password?: boolean
    dob?: boolean
    pan?: boolean
    aadharNumber?: boolean
    gstin?: boolean
    address?: boolean
    state?: boolean
    city?: boolean
    zip?: boolean
    panVerified?: boolean
    termsAccepted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    isBanned?: boolean
    userType?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    username?: boolean
    image?: boolean
    password?: boolean
    dob?: boolean
    pan?: boolean
    aadharNumber?: boolean
    gstin?: boolean
    address?: boolean
    state?: boolean
    city?: boolean
    zip?: boolean
    panVerified?: boolean
    termsAccepted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    isBanned?: boolean
    userType?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    username?: boolean
    image?: boolean
    password?: boolean
    dob?: boolean
    pan?: boolean
    aadharNumber?: boolean
    gstin?: boolean
    address?: boolean
    state?: boolean
    city?: boolean
    zip?: boolean
    panVerified?: boolean
    termsAccepted?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    isBanned?: boolean
    userType?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "username" | "image" | "password" | "dob" | "pan" | "aadharNumber" | "gstin" | "address" | "state" | "city" | "zip" | "panVerified" | "termsAccepted" | "emailVerified" | "phoneVerified" | "isBanned" | "userType" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    purchasedServices?: boolean | User$purchasedServicesArgs<ExtArgs>
    panVerificationData?: boolean | User$panVerificationDataArgs<ExtArgs>
    transaction?: boolean | User$transactionArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      documents: Prisma.$UserDocumentsPayload<ExtArgs>[]
      purchasedServices: Prisma.$UserPurchasedServicesPayload<ExtArgs>[]
      panVerificationData: Prisma.$panVerificationDataPayload<ExtArgs>[]
      transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      phone: string | null
      username: string | null
      image: string | null
      password: string | null
      dob: string | null
      pan: string | null
      aadharNumber: string | null
      gstin: string | null
      address: string | null
      state: string | null
      city: string | null
      zip: string | null
      panVerified: Date | null
      termsAccepted: Date | null
      emailVerified: Date | null
      phoneVerified: Date | null
      isBanned: boolean
      userType: $Enums.UserType
      role: $Enums.UserRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDocumentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchasedServices<T extends User$purchasedServicesArgs<ExtArgs> = {}>(args?: Subset<T, User$purchasedServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPurchasedServicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    panVerificationData<T extends User$panVerificationDataArgs<ExtArgs> = {}>(args?: Subset<T, User$panVerificationDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$panVerificationDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transaction<T extends User$transactionArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly dob: FieldRef<"User", 'String'>
    readonly pan: FieldRef<"User", 'String'>
    readonly aadharNumber: FieldRef<"User", 'String'>
    readonly gstin: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly state: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly zip: FieldRef<"User", 'String'>
    readonly panVerified: FieldRef<"User", 'DateTime'>
    readonly termsAccepted: FieldRef<"User", 'DateTime'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly phoneVerified: FieldRef<"User", 'DateTime'>
    readonly isBanned: FieldRef<"User", 'Boolean'>
    readonly userType: FieldRef<"User", 'UserType'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocuments
     */
    select?: UserDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDocuments
     */
    omit?: UserDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDocumentsInclude<ExtArgs> | null
    where?: UserDocumentsWhereInput
    orderBy?: UserDocumentsOrderByWithRelationInput | UserDocumentsOrderByWithRelationInput[]
    cursor?: UserDocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserDocumentsScalarFieldEnum | UserDocumentsScalarFieldEnum[]
  }

  /**
   * User.purchasedServices
   */
  export type User$purchasedServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPurchasedServices
     */
    select?: UserPurchasedServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPurchasedServices
     */
    omit?: UserPurchasedServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPurchasedServicesInclude<ExtArgs> | null
    where?: UserPurchasedServicesWhereInput
    orderBy?: UserPurchasedServicesOrderByWithRelationInput | UserPurchasedServicesOrderByWithRelationInput[]
    cursor?: UserPurchasedServicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPurchasedServicesScalarFieldEnum | UserPurchasedServicesScalarFieldEnum[]
  }

  /**
   * User.panVerificationData
   */
  export type User$panVerificationDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panVerificationData
     */
    select?: panVerificationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the panVerificationData
     */
    omit?: panVerificationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panVerificationDataInclude<ExtArgs> | null
    where?: panVerificationDataWhereInput
    orderBy?: panVerificationDataOrderByWithRelationInput | panVerificationDataOrderByWithRelationInput[]
    cursor?: panVerificationDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PanVerificationDataScalarFieldEnum | PanVerificationDataScalarFieldEnum[]
  }

  /**
   * User.transaction
   */
  export type User$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const accountWithUserIdOnly = await prisma.account.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `userId`
     * const accountWithUserIdOnly = await prisma.account.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `userId`
     * const accountWithUserIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpMinAggregateOutputType = {
    id: string | null
    userId: string | null
    identifier: string | null
    otp: string | null
    expires_at: Date | null
    verificationType: $Enums.VerificationType | null
    createdAt: Date | null
  }

  export type OtpMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    identifier: string | null
    otp: string | null
    expires_at: Date | null
    verificationType: $Enums.VerificationType | null
    createdAt: Date | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    userId: number
    identifier: number
    otp: number
    expires_at: number
    verificationType: number
    createdAt: number
    _all: number
  }


  export type OtpMinAggregateInputType = {
    id?: true
    userId?: true
    identifier?: true
    otp?: true
    expires_at?: true
    verificationType?: true
    createdAt?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    userId?: true
    identifier?: true
    otp?: true
    expires_at?: true
    verificationType?: true
    createdAt?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    userId?: true
    identifier?: true
    otp?: true
    expires_at?: true
    verificationType?: true
    createdAt?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithAggregationInput | OtpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: string
    userId: string
    identifier: string
    otp: string
    expires_at: Date
    verificationType: $Enums.VerificationType
    createdAt: Date
    _count: OtpCountAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    identifier?: boolean
    otp?: boolean
    expires_at?: boolean
    verificationType?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    identifier?: boolean
    otp?: boolean
    expires_at?: boolean
    verificationType?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    identifier?: boolean
    otp?: boolean
    expires_at?: boolean
    verificationType?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectScalar = {
    id?: boolean
    userId?: boolean
    identifier?: boolean
    otp?: boolean
    expires_at?: boolean
    verificationType?: boolean
    createdAt?: boolean
  }

  export type OtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "identifier" | "otp" | "expires_at" | "verificationType" | "createdAt", ExtArgs["result"]["otp"]>

  export type $OtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      identifier: string
      otp: string
      expires_at: Date
      verificationType: $Enums.VerificationType
      createdAt: Date
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type OtpGetPayload<S extends boolean | null | undefined | OtpDefaultArgs> = $Result.GetResult<Prisma.$OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpFindUniqueArgs>(args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpFindFirstArgs>(args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpFindManyArgs>(args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends OtpCreateArgs>(args: SelectSubset<T, OtpCreateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpCreateManyArgs>(args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Otps and returns the data saved in the database.
     * @param {OtpCreateManyAndReturnArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtpCreateManyAndReturnArgs>(args?: SelectSubset<T, OtpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends OtpDeleteArgs>(args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpUpdateArgs>(args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpDeleteManyArgs>(args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpUpdateManyArgs>(args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps and returns the data updated in the database.
     * @param {OtpUpdateManyAndReturnArgs} args - Arguments to update many Otps.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OtpUpdateManyAndReturnArgs>(args: SelectSubset<T, OtpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends OtpUpsertArgs>(args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otp model
   */
  readonly fields: OtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Otp model
   */
  interface OtpFieldRefs {
    readonly id: FieldRef<"Otp", 'String'>
    readonly userId: FieldRef<"Otp", 'String'>
    readonly identifier: FieldRef<"Otp", 'String'>
    readonly otp: FieldRef<"Otp", 'String'>
    readonly expires_at: FieldRef<"Otp", 'DateTime'>
    readonly verificationType: FieldRef<"Otp", 'VerificationType'>
    readonly createdAt: FieldRef<"Otp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Otp findUnique
   */
  export type OtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findFirst
   */
  export type OtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }

  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp createManyAndReturn
   */
  export type OtpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp updateManyAndReturn
   */
  export type OtpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }

  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to delete.
     */
    limit?: number
  }

  /**
   * Otp without action
   */
  export type OtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
  }


  /**
   * Model panVerificationData
   */

  export type AggregatePanVerificationData = {
    _count: PanVerificationDataCountAggregateOutputType | null
    _min: PanVerificationDataMinAggregateOutputType | null
    _max: PanVerificationDataMaxAggregateOutputType | null
  }

  export type PanVerificationDataMinAggregateOutputType = {
    userId: string | null
    provider: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PanVerificationDataMaxAggregateOutputType = {
    userId: string | null
    provider: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PanVerificationDataCountAggregateOutputType = {
    userId: number
    provider: number
    result: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PanVerificationDataMinAggregateInputType = {
    userId?: true
    provider?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PanVerificationDataMaxAggregateInputType = {
    userId?: true
    provider?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PanVerificationDataCountAggregateInputType = {
    userId?: true
    provider?: true
    result?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PanVerificationDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which panVerificationData to aggregate.
     */
    where?: panVerificationDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of panVerificationData to fetch.
     */
    orderBy?: panVerificationDataOrderByWithRelationInput | panVerificationDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: panVerificationDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` panVerificationData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` panVerificationData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned panVerificationData
    **/
    _count?: true | PanVerificationDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PanVerificationDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PanVerificationDataMaxAggregateInputType
  }

  export type GetPanVerificationDataAggregateType<T extends PanVerificationDataAggregateArgs> = {
        [P in keyof T & keyof AggregatePanVerificationData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePanVerificationData[P]>
      : GetScalarType<T[P], AggregatePanVerificationData[P]>
  }




  export type panVerificationDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: panVerificationDataWhereInput
    orderBy?: panVerificationDataOrderByWithAggregationInput | panVerificationDataOrderByWithAggregationInput[]
    by: PanVerificationDataScalarFieldEnum[] | PanVerificationDataScalarFieldEnum
    having?: panVerificationDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PanVerificationDataCountAggregateInputType | true
    _min?: PanVerificationDataMinAggregateInputType
    _max?: PanVerificationDataMaxAggregateInputType
  }

  export type PanVerificationDataGroupByOutputType = {
    userId: string
    provider: string
    result: JsonValue
    status: string
    createdAt: Date
    updatedAt: Date
    _count: PanVerificationDataCountAggregateOutputType | null
    _min: PanVerificationDataMinAggregateOutputType | null
    _max: PanVerificationDataMaxAggregateOutputType | null
  }

  type GetPanVerificationDataGroupByPayload<T extends panVerificationDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PanVerificationDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PanVerificationDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PanVerificationDataGroupByOutputType[P]>
            : GetScalarType<T[P], PanVerificationDataGroupByOutputType[P]>
        }
      >
    >


  export type panVerificationDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    provider?: boolean
    result?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["panVerificationData"]>

  export type panVerificationDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    provider?: boolean
    result?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["panVerificationData"]>

  export type panVerificationDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    provider?: boolean
    result?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["panVerificationData"]>

  export type panVerificationDataSelectScalar = {
    userId?: boolean
    provider?: boolean
    result?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type panVerificationDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "provider" | "result" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["panVerificationData"]>
  export type panVerificationDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type panVerificationDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type panVerificationDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $panVerificationDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "panVerificationData"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      provider: string
      result: Prisma.JsonValue
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["panVerificationData"]>
    composites: {}
  }

  type panVerificationDataGetPayload<S extends boolean | null | undefined | panVerificationDataDefaultArgs> = $Result.GetResult<Prisma.$panVerificationDataPayload, S>

  type panVerificationDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<panVerificationDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PanVerificationDataCountAggregateInputType | true
    }

  export interface panVerificationDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['panVerificationData'], meta: { name: 'panVerificationData' } }
    /**
     * Find zero or one PanVerificationData that matches the filter.
     * @param {panVerificationDataFindUniqueArgs} args - Arguments to find a PanVerificationData
     * @example
     * // Get one PanVerificationData
     * const panVerificationData = await prisma.panVerificationData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends panVerificationDataFindUniqueArgs>(args: SelectSubset<T, panVerificationDataFindUniqueArgs<ExtArgs>>): Prisma__panVerificationDataClient<$Result.GetResult<Prisma.$panVerificationDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PanVerificationData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {panVerificationDataFindUniqueOrThrowArgs} args - Arguments to find a PanVerificationData
     * @example
     * // Get one PanVerificationData
     * const panVerificationData = await prisma.panVerificationData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends panVerificationDataFindUniqueOrThrowArgs>(args: SelectSubset<T, panVerificationDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__panVerificationDataClient<$Result.GetResult<Prisma.$panVerificationDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PanVerificationData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panVerificationDataFindFirstArgs} args - Arguments to find a PanVerificationData
     * @example
     * // Get one PanVerificationData
     * const panVerificationData = await prisma.panVerificationData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends panVerificationDataFindFirstArgs>(args?: SelectSubset<T, panVerificationDataFindFirstArgs<ExtArgs>>): Prisma__panVerificationDataClient<$Result.GetResult<Prisma.$panVerificationDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PanVerificationData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panVerificationDataFindFirstOrThrowArgs} args - Arguments to find a PanVerificationData
     * @example
     * // Get one PanVerificationData
     * const panVerificationData = await prisma.panVerificationData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends panVerificationDataFindFirstOrThrowArgs>(args?: SelectSubset<T, panVerificationDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__panVerificationDataClient<$Result.GetResult<Prisma.$panVerificationDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PanVerificationData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panVerificationDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PanVerificationData
     * const panVerificationData = await prisma.panVerificationData.findMany()
     * 
     * // Get first 10 PanVerificationData
     * const panVerificationData = await prisma.panVerificationData.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const panVerificationDataWithUserIdOnly = await prisma.panVerificationData.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends panVerificationDataFindManyArgs>(args?: SelectSubset<T, panVerificationDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$panVerificationDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PanVerificationData.
     * @param {panVerificationDataCreateArgs} args - Arguments to create a PanVerificationData.
     * @example
     * // Create one PanVerificationData
     * const PanVerificationData = await prisma.panVerificationData.create({
     *   data: {
     *     // ... data to create a PanVerificationData
     *   }
     * })
     * 
     */
    create<T extends panVerificationDataCreateArgs>(args: SelectSubset<T, panVerificationDataCreateArgs<ExtArgs>>): Prisma__panVerificationDataClient<$Result.GetResult<Prisma.$panVerificationDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PanVerificationData.
     * @param {panVerificationDataCreateManyArgs} args - Arguments to create many PanVerificationData.
     * @example
     * // Create many PanVerificationData
     * const panVerificationData = await prisma.panVerificationData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends panVerificationDataCreateManyArgs>(args?: SelectSubset<T, panVerificationDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PanVerificationData and returns the data saved in the database.
     * @param {panVerificationDataCreateManyAndReturnArgs} args - Arguments to create many PanVerificationData.
     * @example
     * // Create many PanVerificationData
     * const panVerificationData = await prisma.panVerificationData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PanVerificationData and only return the `userId`
     * const panVerificationDataWithUserIdOnly = await prisma.panVerificationData.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends panVerificationDataCreateManyAndReturnArgs>(args?: SelectSubset<T, panVerificationDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$panVerificationDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PanVerificationData.
     * @param {panVerificationDataDeleteArgs} args - Arguments to delete one PanVerificationData.
     * @example
     * // Delete one PanVerificationData
     * const PanVerificationData = await prisma.panVerificationData.delete({
     *   where: {
     *     // ... filter to delete one PanVerificationData
     *   }
     * })
     * 
     */
    delete<T extends panVerificationDataDeleteArgs>(args: SelectSubset<T, panVerificationDataDeleteArgs<ExtArgs>>): Prisma__panVerificationDataClient<$Result.GetResult<Prisma.$panVerificationDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PanVerificationData.
     * @param {panVerificationDataUpdateArgs} args - Arguments to update one PanVerificationData.
     * @example
     * // Update one PanVerificationData
     * const panVerificationData = await prisma.panVerificationData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends panVerificationDataUpdateArgs>(args: SelectSubset<T, panVerificationDataUpdateArgs<ExtArgs>>): Prisma__panVerificationDataClient<$Result.GetResult<Prisma.$panVerificationDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PanVerificationData.
     * @param {panVerificationDataDeleteManyArgs} args - Arguments to filter PanVerificationData to delete.
     * @example
     * // Delete a few PanVerificationData
     * const { count } = await prisma.panVerificationData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends panVerificationDataDeleteManyArgs>(args?: SelectSubset<T, panVerificationDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PanVerificationData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panVerificationDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PanVerificationData
     * const panVerificationData = await prisma.panVerificationData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends panVerificationDataUpdateManyArgs>(args: SelectSubset<T, panVerificationDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PanVerificationData and returns the data updated in the database.
     * @param {panVerificationDataUpdateManyAndReturnArgs} args - Arguments to update many PanVerificationData.
     * @example
     * // Update many PanVerificationData
     * const panVerificationData = await prisma.panVerificationData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PanVerificationData and only return the `userId`
     * const panVerificationDataWithUserIdOnly = await prisma.panVerificationData.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends panVerificationDataUpdateManyAndReturnArgs>(args: SelectSubset<T, panVerificationDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$panVerificationDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PanVerificationData.
     * @param {panVerificationDataUpsertArgs} args - Arguments to update or create a PanVerificationData.
     * @example
     * // Update or create a PanVerificationData
     * const panVerificationData = await prisma.panVerificationData.upsert({
     *   create: {
     *     // ... data to create a PanVerificationData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PanVerificationData we want to update
     *   }
     * })
     */
    upsert<T extends panVerificationDataUpsertArgs>(args: SelectSubset<T, panVerificationDataUpsertArgs<ExtArgs>>): Prisma__panVerificationDataClient<$Result.GetResult<Prisma.$panVerificationDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PanVerificationData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panVerificationDataCountArgs} args - Arguments to filter PanVerificationData to count.
     * @example
     * // Count the number of PanVerificationData
     * const count = await prisma.panVerificationData.count({
     *   where: {
     *     // ... the filter for the PanVerificationData we want to count
     *   }
     * })
    **/
    count<T extends panVerificationDataCountArgs>(
      args?: Subset<T, panVerificationDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PanVerificationDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PanVerificationData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanVerificationDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PanVerificationDataAggregateArgs>(args: Subset<T, PanVerificationDataAggregateArgs>): Prisma.PrismaPromise<GetPanVerificationDataAggregateType<T>>

    /**
     * Group by PanVerificationData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {panVerificationDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends panVerificationDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: panVerificationDataGroupByArgs['orderBy'] }
        : { orderBy?: panVerificationDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, panVerificationDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPanVerificationDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the panVerificationData model
   */
  readonly fields: panVerificationDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for panVerificationData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__panVerificationDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the panVerificationData model
   */
  interface panVerificationDataFieldRefs {
    readonly userId: FieldRef<"panVerificationData", 'String'>
    readonly provider: FieldRef<"panVerificationData", 'String'>
    readonly result: FieldRef<"panVerificationData", 'Json'>
    readonly status: FieldRef<"panVerificationData", 'String'>
    readonly createdAt: FieldRef<"panVerificationData", 'DateTime'>
    readonly updatedAt: FieldRef<"panVerificationData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * panVerificationData findUnique
   */
  export type panVerificationDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panVerificationData
     */
    select?: panVerificationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the panVerificationData
     */
    omit?: panVerificationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panVerificationDataInclude<ExtArgs> | null
    /**
     * Filter, which panVerificationData to fetch.
     */
    where: panVerificationDataWhereUniqueInput
  }

  /**
   * panVerificationData findUniqueOrThrow
   */
  export type panVerificationDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panVerificationData
     */
    select?: panVerificationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the panVerificationData
     */
    omit?: panVerificationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panVerificationDataInclude<ExtArgs> | null
    /**
     * Filter, which panVerificationData to fetch.
     */
    where: panVerificationDataWhereUniqueInput
  }

  /**
   * panVerificationData findFirst
   */
  export type panVerificationDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panVerificationData
     */
    select?: panVerificationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the panVerificationData
     */
    omit?: panVerificationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panVerificationDataInclude<ExtArgs> | null
    /**
     * Filter, which panVerificationData to fetch.
     */
    where?: panVerificationDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of panVerificationData to fetch.
     */
    orderBy?: panVerificationDataOrderByWithRelationInput | panVerificationDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for panVerificationData.
     */
    cursor?: panVerificationDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` panVerificationData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` panVerificationData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of panVerificationData.
     */
    distinct?: PanVerificationDataScalarFieldEnum | PanVerificationDataScalarFieldEnum[]
  }

  /**
   * panVerificationData findFirstOrThrow
   */
  export type panVerificationDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panVerificationData
     */
    select?: panVerificationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the panVerificationData
     */
    omit?: panVerificationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panVerificationDataInclude<ExtArgs> | null
    /**
     * Filter, which panVerificationData to fetch.
     */
    where?: panVerificationDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of panVerificationData to fetch.
     */
    orderBy?: panVerificationDataOrderByWithRelationInput | panVerificationDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for panVerificationData.
     */
    cursor?: panVerificationDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` panVerificationData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` panVerificationData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of panVerificationData.
     */
    distinct?: PanVerificationDataScalarFieldEnum | PanVerificationDataScalarFieldEnum[]
  }

  /**
   * panVerificationData findMany
   */
  export type panVerificationDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panVerificationData
     */
    select?: panVerificationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the panVerificationData
     */
    omit?: panVerificationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panVerificationDataInclude<ExtArgs> | null
    /**
     * Filter, which panVerificationData to fetch.
     */
    where?: panVerificationDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of panVerificationData to fetch.
     */
    orderBy?: panVerificationDataOrderByWithRelationInput | panVerificationDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing panVerificationData.
     */
    cursor?: panVerificationDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` panVerificationData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` panVerificationData.
     */
    skip?: number
    distinct?: PanVerificationDataScalarFieldEnum | PanVerificationDataScalarFieldEnum[]
  }

  /**
   * panVerificationData create
   */
  export type panVerificationDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panVerificationData
     */
    select?: panVerificationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the panVerificationData
     */
    omit?: panVerificationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panVerificationDataInclude<ExtArgs> | null
    /**
     * The data needed to create a panVerificationData.
     */
    data: XOR<panVerificationDataCreateInput, panVerificationDataUncheckedCreateInput>
  }

  /**
   * panVerificationData createMany
   */
  export type panVerificationDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many panVerificationData.
     */
    data: panVerificationDataCreateManyInput | panVerificationDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * panVerificationData createManyAndReturn
   */
  export type panVerificationDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panVerificationData
     */
    select?: panVerificationDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the panVerificationData
     */
    omit?: panVerificationDataOmit<ExtArgs> | null
    /**
     * The data used to create many panVerificationData.
     */
    data: panVerificationDataCreateManyInput | panVerificationDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panVerificationDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * panVerificationData update
   */
  export type panVerificationDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panVerificationData
     */
    select?: panVerificationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the panVerificationData
     */
    omit?: panVerificationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panVerificationDataInclude<ExtArgs> | null
    /**
     * The data needed to update a panVerificationData.
     */
    data: XOR<panVerificationDataUpdateInput, panVerificationDataUncheckedUpdateInput>
    /**
     * Choose, which panVerificationData to update.
     */
    where: panVerificationDataWhereUniqueInput
  }

  /**
   * panVerificationData updateMany
   */
  export type panVerificationDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update panVerificationData.
     */
    data: XOR<panVerificationDataUpdateManyMutationInput, panVerificationDataUncheckedUpdateManyInput>
    /**
     * Filter which panVerificationData to update
     */
    where?: panVerificationDataWhereInput
    /**
     * Limit how many panVerificationData to update.
     */
    limit?: number
  }

  /**
   * panVerificationData updateManyAndReturn
   */
  export type panVerificationDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panVerificationData
     */
    select?: panVerificationDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the panVerificationData
     */
    omit?: panVerificationDataOmit<ExtArgs> | null
    /**
     * The data used to update panVerificationData.
     */
    data: XOR<panVerificationDataUpdateManyMutationInput, panVerificationDataUncheckedUpdateManyInput>
    /**
     * Filter which panVerificationData to update
     */
    where?: panVerificationDataWhereInput
    /**
     * Limit how many panVerificationData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panVerificationDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * panVerificationData upsert
   */
  export type panVerificationDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panVerificationData
     */
    select?: panVerificationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the panVerificationData
     */
    omit?: panVerificationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panVerificationDataInclude<ExtArgs> | null
    /**
     * The filter to search for the panVerificationData to update in case it exists.
     */
    where: panVerificationDataWhereUniqueInput
    /**
     * In case the panVerificationData found by the `where` argument doesn't exist, create a new panVerificationData with this data.
     */
    create: XOR<panVerificationDataCreateInput, panVerificationDataUncheckedCreateInput>
    /**
     * In case the panVerificationData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<panVerificationDataUpdateInput, panVerificationDataUncheckedUpdateInput>
  }

  /**
   * panVerificationData delete
   */
  export type panVerificationDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panVerificationData
     */
    select?: panVerificationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the panVerificationData
     */
    omit?: panVerificationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panVerificationDataInclude<ExtArgs> | null
    /**
     * Filter which panVerificationData to delete.
     */
    where: panVerificationDataWhereUniqueInput
  }

  /**
   * panVerificationData deleteMany
   */
  export type panVerificationDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which panVerificationData to delete
     */
    where?: panVerificationDataWhereInput
    /**
     * Limit how many panVerificationData to delete.
     */
    limit?: number
  }

  /**
   * panVerificationData without action
   */
  export type panVerificationDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the panVerificationData
     */
    select?: panVerificationDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the panVerificationData
     */
    omit?: panVerificationDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: panVerificationDataInclude<ExtArgs> | null
  }


  /**
   * Model UserPurchasedServices
   */

  export type AggregateUserPurchasedServices = {
    _count: UserPurchasedServicesCountAggregateOutputType | null
    _avg: UserPurchasedServicesAvgAggregateOutputType | null
    _sum: UserPurchasedServicesSumAggregateOutputType | null
    _min: UserPurchasedServicesMinAggregateOutputType | null
    _max: UserPurchasedServicesMaxAggregateOutputType | null
  }

  export type UserPurchasedServicesAvgAggregateOutputType = {
    planDays: number | null
    planDiscount: number | null
  }

  export type UserPurchasedServicesSumAggregateOutputType = {
    planDays: number | null
    planDiscount: number | null
  }

  export type UserPurchasedServicesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    purchaseDate: Date | null
    expiryDate: Date | null
    planDays: number | null
    planDiscount: number | null
    agreementAcceptedAt: Date | null
  }

  export type UserPurchasedServicesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    serviceId: string | null
    purchaseDate: Date | null
    expiryDate: Date | null
    planDays: number | null
    planDiscount: number | null
    agreementAcceptedAt: Date | null
  }

  export type UserPurchasedServicesCountAggregateOutputType = {
    id: number
    userId: number
    serviceId: number
    purchaseDate: number
    expiryDate: number
    planDays: number
    planDiscount: number
    agreementAcceptedAt: number
    agreementData: number
    _all: number
  }


  export type UserPurchasedServicesAvgAggregateInputType = {
    planDays?: true
    planDiscount?: true
  }

  export type UserPurchasedServicesSumAggregateInputType = {
    planDays?: true
    planDiscount?: true
  }

  export type UserPurchasedServicesMinAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    purchaseDate?: true
    expiryDate?: true
    planDays?: true
    planDiscount?: true
    agreementAcceptedAt?: true
  }

  export type UserPurchasedServicesMaxAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    purchaseDate?: true
    expiryDate?: true
    planDays?: true
    planDiscount?: true
    agreementAcceptedAt?: true
  }

  export type UserPurchasedServicesCountAggregateInputType = {
    id?: true
    userId?: true
    serviceId?: true
    purchaseDate?: true
    expiryDate?: true
    planDays?: true
    planDiscount?: true
    agreementAcceptedAt?: true
    agreementData?: true
    _all?: true
  }

  export type UserPurchasedServicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPurchasedServices to aggregate.
     */
    where?: UserPurchasedServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPurchasedServices to fetch.
     */
    orderBy?: UserPurchasedServicesOrderByWithRelationInput | UserPurchasedServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPurchasedServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPurchasedServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPurchasedServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPurchasedServices
    **/
    _count?: true | UserPurchasedServicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPurchasedServicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPurchasedServicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPurchasedServicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPurchasedServicesMaxAggregateInputType
  }

  export type GetUserPurchasedServicesAggregateType<T extends UserPurchasedServicesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPurchasedServices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPurchasedServices[P]>
      : GetScalarType<T[P], AggregateUserPurchasedServices[P]>
  }




  export type UserPurchasedServicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPurchasedServicesWhereInput
    orderBy?: UserPurchasedServicesOrderByWithAggregationInput | UserPurchasedServicesOrderByWithAggregationInput[]
    by: UserPurchasedServicesScalarFieldEnum[] | UserPurchasedServicesScalarFieldEnum
    having?: UserPurchasedServicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPurchasedServicesCountAggregateInputType | true
    _avg?: UserPurchasedServicesAvgAggregateInputType
    _sum?: UserPurchasedServicesSumAggregateInputType
    _min?: UserPurchasedServicesMinAggregateInputType
    _max?: UserPurchasedServicesMaxAggregateInputType
  }

  export type UserPurchasedServicesGroupByOutputType = {
    id: string
    userId: string
    serviceId: string
    purchaseDate: Date
    expiryDate: Date
    planDays: number
    planDiscount: number
    agreementAcceptedAt: Date | null
    agreementData: JsonValue | null
    _count: UserPurchasedServicesCountAggregateOutputType | null
    _avg: UserPurchasedServicesAvgAggregateOutputType | null
    _sum: UserPurchasedServicesSumAggregateOutputType | null
    _min: UserPurchasedServicesMinAggregateOutputType | null
    _max: UserPurchasedServicesMaxAggregateOutputType | null
  }

  type GetUserPurchasedServicesGroupByPayload<T extends UserPurchasedServicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPurchasedServicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPurchasedServicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPurchasedServicesGroupByOutputType[P]>
            : GetScalarType<T[P], UserPurchasedServicesGroupByOutputType[P]>
        }
      >
    >


  export type UserPurchasedServicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    purchaseDate?: boolean
    expiryDate?: boolean
    planDays?: boolean
    planDiscount?: boolean
    agreementAcceptedAt?: boolean
    agreementData?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPurchasedServices"]>

  export type UserPurchasedServicesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    purchaseDate?: boolean
    expiryDate?: boolean
    planDays?: boolean
    planDiscount?: boolean
    agreementAcceptedAt?: boolean
    agreementData?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPurchasedServices"]>

  export type UserPurchasedServicesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    purchaseDate?: boolean
    expiryDate?: boolean
    planDays?: boolean
    planDiscount?: boolean
    agreementAcceptedAt?: boolean
    agreementData?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPurchasedServices"]>

  export type UserPurchasedServicesSelectScalar = {
    id?: boolean
    userId?: boolean
    serviceId?: boolean
    purchaseDate?: boolean
    expiryDate?: boolean
    planDays?: boolean
    planDiscount?: boolean
    agreementAcceptedAt?: boolean
    agreementData?: boolean
  }

  export type UserPurchasedServicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "serviceId" | "purchaseDate" | "expiryDate" | "planDays" | "planDiscount" | "agreementAcceptedAt" | "agreementData", ExtArgs["result"]["userPurchasedServices"]>
  export type UserPurchasedServicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type UserPurchasedServicesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type UserPurchasedServicesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $UserPurchasedServicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPurchasedServices"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      serviceId: string
      purchaseDate: Date
      expiryDate: Date
      planDays: number
      planDiscount: number
      agreementAcceptedAt: Date | null
      agreementData: Prisma.JsonValue | null
    }, ExtArgs["result"]["userPurchasedServices"]>
    composites: {}
  }

  type UserPurchasedServicesGetPayload<S extends boolean | null | undefined | UserPurchasedServicesDefaultArgs> = $Result.GetResult<Prisma.$UserPurchasedServicesPayload, S>

  type UserPurchasedServicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPurchasedServicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPurchasedServicesCountAggregateInputType | true
    }

  export interface UserPurchasedServicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPurchasedServices'], meta: { name: 'UserPurchasedServices' } }
    /**
     * Find zero or one UserPurchasedServices that matches the filter.
     * @param {UserPurchasedServicesFindUniqueArgs} args - Arguments to find a UserPurchasedServices
     * @example
     * // Get one UserPurchasedServices
     * const userPurchasedServices = await prisma.userPurchasedServices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPurchasedServicesFindUniqueArgs>(args: SelectSubset<T, UserPurchasedServicesFindUniqueArgs<ExtArgs>>): Prisma__UserPurchasedServicesClient<$Result.GetResult<Prisma.$UserPurchasedServicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPurchasedServices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPurchasedServicesFindUniqueOrThrowArgs} args - Arguments to find a UserPurchasedServices
     * @example
     * // Get one UserPurchasedServices
     * const userPurchasedServices = await prisma.userPurchasedServices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPurchasedServicesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPurchasedServicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPurchasedServicesClient<$Result.GetResult<Prisma.$UserPurchasedServicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPurchasedServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPurchasedServicesFindFirstArgs} args - Arguments to find a UserPurchasedServices
     * @example
     * // Get one UserPurchasedServices
     * const userPurchasedServices = await prisma.userPurchasedServices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPurchasedServicesFindFirstArgs>(args?: SelectSubset<T, UserPurchasedServicesFindFirstArgs<ExtArgs>>): Prisma__UserPurchasedServicesClient<$Result.GetResult<Prisma.$UserPurchasedServicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPurchasedServices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPurchasedServicesFindFirstOrThrowArgs} args - Arguments to find a UserPurchasedServices
     * @example
     * // Get one UserPurchasedServices
     * const userPurchasedServices = await prisma.userPurchasedServices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPurchasedServicesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPurchasedServicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPurchasedServicesClient<$Result.GetResult<Prisma.$UserPurchasedServicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPurchasedServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPurchasedServicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPurchasedServices
     * const userPurchasedServices = await prisma.userPurchasedServices.findMany()
     * 
     * // Get first 10 UserPurchasedServices
     * const userPurchasedServices = await prisma.userPurchasedServices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPurchasedServicesWithIdOnly = await prisma.userPurchasedServices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPurchasedServicesFindManyArgs>(args?: SelectSubset<T, UserPurchasedServicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPurchasedServicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPurchasedServices.
     * @param {UserPurchasedServicesCreateArgs} args - Arguments to create a UserPurchasedServices.
     * @example
     * // Create one UserPurchasedServices
     * const UserPurchasedServices = await prisma.userPurchasedServices.create({
     *   data: {
     *     // ... data to create a UserPurchasedServices
     *   }
     * })
     * 
     */
    create<T extends UserPurchasedServicesCreateArgs>(args: SelectSubset<T, UserPurchasedServicesCreateArgs<ExtArgs>>): Prisma__UserPurchasedServicesClient<$Result.GetResult<Prisma.$UserPurchasedServicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPurchasedServices.
     * @param {UserPurchasedServicesCreateManyArgs} args - Arguments to create many UserPurchasedServices.
     * @example
     * // Create many UserPurchasedServices
     * const userPurchasedServices = await prisma.userPurchasedServices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPurchasedServicesCreateManyArgs>(args?: SelectSubset<T, UserPurchasedServicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPurchasedServices and returns the data saved in the database.
     * @param {UserPurchasedServicesCreateManyAndReturnArgs} args - Arguments to create many UserPurchasedServices.
     * @example
     * // Create many UserPurchasedServices
     * const userPurchasedServices = await prisma.userPurchasedServices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPurchasedServices and only return the `id`
     * const userPurchasedServicesWithIdOnly = await prisma.userPurchasedServices.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPurchasedServicesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPurchasedServicesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPurchasedServicesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPurchasedServices.
     * @param {UserPurchasedServicesDeleteArgs} args - Arguments to delete one UserPurchasedServices.
     * @example
     * // Delete one UserPurchasedServices
     * const UserPurchasedServices = await prisma.userPurchasedServices.delete({
     *   where: {
     *     // ... filter to delete one UserPurchasedServices
     *   }
     * })
     * 
     */
    delete<T extends UserPurchasedServicesDeleteArgs>(args: SelectSubset<T, UserPurchasedServicesDeleteArgs<ExtArgs>>): Prisma__UserPurchasedServicesClient<$Result.GetResult<Prisma.$UserPurchasedServicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPurchasedServices.
     * @param {UserPurchasedServicesUpdateArgs} args - Arguments to update one UserPurchasedServices.
     * @example
     * // Update one UserPurchasedServices
     * const userPurchasedServices = await prisma.userPurchasedServices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPurchasedServicesUpdateArgs>(args: SelectSubset<T, UserPurchasedServicesUpdateArgs<ExtArgs>>): Prisma__UserPurchasedServicesClient<$Result.GetResult<Prisma.$UserPurchasedServicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPurchasedServices.
     * @param {UserPurchasedServicesDeleteManyArgs} args - Arguments to filter UserPurchasedServices to delete.
     * @example
     * // Delete a few UserPurchasedServices
     * const { count } = await prisma.userPurchasedServices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPurchasedServicesDeleteManyArgs>(args?: SelectSubset<T, UserPurchasedServicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPurchasedServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPurchasedServicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPurchasedServices
     * const userPurchasedServices = await prisma.userPurchasedServices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPurchasedServicesUpdateManyArgs>(args: SelectSubset<T, UserPurchasedServicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPurchasedServices and returns the data updated in the database.
     * @param {UserPurchasedServicesUpdateManyAndReturnArgs} args - Arguments to update many UserPurchasedServices.
     * @example
     * // Update many UserPurchasedServices
     * const userPurchasedServices = await prisma.userPurchasedServices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPurchasedServices and only return the `id`
     * const userPurchasedServicesWithIdOnly = await prisma.userPurchasedServices.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPurchasedServicesUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPurchasedServicesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPurchasedServicesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPurchasedServices.
     * @param {UserPurchasedServicesUpsertArgs} args - Arguments to update or create a UserPurchasedServices.
     * @example
     * // Update or create a UserPurchasedServices
     * const userPurchasedServices = await prisma.userPurchasedServices.upsert({
     *   create: {
     *     // ... data to create a UserPurchasedServices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPurchasedServices we want to update
     *   }
     * })
     */
    upsert<T extends UserPurchasedServicesUpsertArgs>(args: SelectSubset<T, UserPurchasedServicesUpsertArgs<ExtArgs>>): Prisma__UserPurchasedServicesClient<$Result.GetResult<Prisma.$UserPurchasedServicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPurchasedServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPurchasedServicesCountArgs} args - Arguments to filter UserPurchasedServices to count.
     * @example
     * // Count the number of UserPurchasedServices
     * const count = await prisma.userPurchasedServices.count({
     *   where: {
     *     // ... the filter for the UserPurchasedServices we want to count
     *   }
     * })
    **/
    count<T extends UserPurchasedServicesCountArgs>(
      args?: Subset<T, UserPurchasedServicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPurchasedServicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPurchasedServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPurchasedServicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPurchasedServicesAggregateArgs>(args: Subset<T, UserPurchasedServicesAggregateArgs>): Prisma.PrismaPromise<GetUserPurchasedServicesAggregateType<T>>

    /**
     * Group by UserPurchasedServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPurchasedServicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPurchasedServicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPurchasedServicesGroupByArgs['orderBy'] }
        : { orderBy?: UserPurchasedServicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPurchasedServicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPurchasedServicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPurchasedServices model
   */
  readonly fields: UserPurchasedServicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPurchasedServices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPurchasedServicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPurchasedServices model
   */
  interface UserPurchasedServicesFieldRefs {
    readonly id: FieldRef<"UserPurchasedServices", 'String'>
    readonly userId: FieldRef<"UserPurchasedServices", 'String'>
    readonly serviceId: FieldRef<"UserPurchasedServices", 'String'>
    readonly purchaseDate: FieldRef<"UserPurchasedServices", 'DateTime'>
    readonly expiryDate: FieldRef<"UserPurchasedServices", 'DateTime'>
    readonly planDays: FieldRef<"UserPurchasedServices", 'Int'>
    readonly planDiscount: FieldRef<"UserPurchasedServices", 'Float'>
    readonly agreementAcceptedAt: FieldRef<"UserPurchasedServices", 'DateTime'>
    readonly agreementData: FieldRef<"UserPurchasedServices", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UserPurchasedServices findUnique
   */
  export type UserPurchasedServicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPurchasedServices
     */
    select?: UserPurchasedServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPurchasedServices
     */
    omit?: UserPurchasedServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPurchasedServicesInclude<ExtArgs> | null
    /**
     * Filter, which UserPurchasedServices to fetch.
     */
    where: UserPurchasedServicesWhereUniqueInput
  }

  /**
   * UserPurchasedServices findUniqueOrThrow
   */
  export type UserPurchasedServicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPurchasedServices
     */
    select?: UserPurchasedServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPurchasedServices
     */
    omit?: UserPurchasedServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPurchasedServicesInclude<ExtArgs> | null
    /**
     * Filter, which UserPurchasedServices to fetch.
     */
    where: UserPurchasedServicesWhereUniqueInput
  }

  /**
   * UserPurchasedServices findFirst
   */
  export type UserPurchasedServicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPurchasedServices
     */
    select?: UserPurchasedServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPurchasedServices
     */
    omit?: UserPurchasedServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPurchasedServicesInclude<ExtArgs> | null
    /**
     * Filter, which UserPurchasedServices to fetch.
     */
    where?: UserPurchasedServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPurchasedServices to fetch.
     */
    orderBy?: UserPurchasedServicesOrderByWithRelationInput | UserPurchasedServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPurchasedServices.
     */
    cursor?: UserPurchasedServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPurchasedServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPurchasedServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPurchasedServices.
     */
    distinct?: UserPurchasedServicesScalarFieldEnum | UserPurchasedServicesScalarFieldEnum[]
  }

  /**
   * UserPurchasedServices findFirstOrThrow
   */
  export type UserPurchasedServicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPurchasedServices
     */
    select?: UserPurchasedServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPurchasedServices
     */
    omit?: UserPurchasedServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPurchasedServicesInclude<ExtArgs> | null
    /**
     * Filter, which UserPurchasedServices to fetch.
     */
    where?: UserPurchasedServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPurchasedServices to fetch.
     */
    orderBy?: UserPurchasedServicesOrderByWithRelationInput | UserPurchasedServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPurchasedServices.
     */
    cursor?: UserPurchasedServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPurchasedServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPurchasedServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPurchasedServices.
     */
    distinct?: UserPurchasedServicesScalarFieldEnum | UserPurchasedServicesScalarFieldEnum[]
  }

  /**
   * UserPurchasedServices findMany
   */
  export type UserPurchasedServicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPurchasedServices
     */
    select?: UserPurchasedServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPurchasedServices
     */
    omit?: UserPurchasedServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPurchasedServicesInclude<ExtArgs> | null
    /**
     * Filter, which UserPurchasedServices to fetch.
     */
    where?: UserPurchasedServicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPurchasedServices to fetch.
     */
    orderBy?: UserPurchasedServicesOrderByWithRelationInput | UserPurchasedServicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPurchasedServices.
     */
    cursor?: UserPurchasedServicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPurchasedServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPurchasedServices.
     */
    skip?: number
    distinct?: UserPurchasedServicesScalarFieldEnum | UserPurchasedServicesScalarFieldEnum[]
  }

  /**
   * UserPurchasedServices create
   */
  export type UserPurchasedServicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPurchasedServices
     */
    select?: UserPurchasedServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPurchasedServices
     */
    omit?: UserPurchasedServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPurchasedServicesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPurchasedServices.
     */
    data: XOR<UserPurchasedServicesCreateInput, UserPurchasedServicesUncheckedCreateInput>
  }

  /**
   * UserPurchasedServices createMany
   */
  export type UserPurchasedServicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPurchasedServices.
     */
    data: UserPurchasedServicesCreateManyInput | UserPurchasedServicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPurchasedServices createManyAndReturn
   */
  export type UserPurchasedServicesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPurchasedServices
     */
    select?: UserPurchasedServicesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPurchasedServices
     */
    omit?: UserPurchasedServicesOmit<ExtArgs> | null
    /**
     * The data used to create many UserPurchasedServices.
     */
    data: UserPurchasedServicesCreateManyInput | UserPurchasedServicesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPurchasedServicesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPurchasedServices update
   */
  export type UserPurchasedServicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPurchasedServices
     */
    select?: UserPurchasedServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPurchasedServices
     */
    omit?: UserPurchasedServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPurchasedServicesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPurchasedServices.
     */
    data: XOR<UserPurchasedServicesUpdateInput, UserPurchasedServicesUncheckedUpdateInput>
    /**
     * Choose, which UserPurchasedServices to update.
     */
    where: UserPurchasedServicesWhereUniqueInput
  }

  /**
   * UserPurchasedServices updateMany
   */
  export type UserPurchasedServicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPurchasedServices.
     */
    data: XOR<UserPurchasedServicesUpdateManyMutationInput, UserPurchasedServicesUncheckedUpdateManyInput>
    /**
     * Filter which UserPurchasedServices to update
     */
    where?: UserPurchasedServicesWhereInput
    /**
     * Limit how many UserPurchasedServices to update.
     */
    limit?: number
  }

  /**
   * UserPurchasedServices updateManyAndReturn
   */
  export type UserPurchasedServicesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPurchasedServices
     */
    select?: UserPurchasedServicesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPurchasedServices
     */
    omit?: UserPurchasedServicesOmit<ExtArgs> | null
    /**
     * The data used to update UserPurchasedServices.
     */
    data: XOR<UserPurchasedServicesUpdateManyMutationInput, UserPurchasedServicesUncheckedUpdateManyInput>
    /**
     * Filter which UserPurchasedServices to update
     */
    where?: UserPurchasedServicesWhereInput
    /**
     * Limit how many UserPurchasedServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPurchasedServicesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPurchasedServices upsert
   */
  export type UserPurchasedServicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPurchasedServices
     */
    select?: UserPurchasedServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPurchasedServices
     */
    omit?: UserPurchasedServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPurchasedServicesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPurchasedServices to update in case it exists.
     */
    where: UserPurchasedServicesWhereUniqueInput
    /**
     * In case the UserPurchasedServices found by the `where` argument doesn't exist, create a new UserPurchasedServices with this data.
     */
    create: XOR<UserPurchasedServicesCreateInput, UserPurchasedServicesUncheckedCreateInput>
    /**
     * In case the UserPurchasedServices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPurchasedServicesUpdateInput, UserPurchasedServicesUncheckedUpdateInput>
  }

  /**
   * UserPurchasedServices delete
   */
  export type UserPurchasedServicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPurchasedServices
     */
    select?: UserPurchasedServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPurchasedServices
     */
    omit?: UserPurchasedServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPurchasedServicesInclude<ExtArgs> | null
    /**
     * Filter which UserPurchasedServices to delete.
     */
    where: UserPurchasedServicesWhereUniqueInput
  }

  /**
   * UserPurchasedServices deleteMany
   */
  export type UserPurchasedServicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPurchasedServices to delete
     */
    where?: UserPurchasedServicesWhereInput
    /**
     * Limit how many UserPurchasedServices to delete.
     */
    limit?: number
  }

  /**
   * UserPurchasedServices without action
   */
  export type UserPurchasedServicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPurchasedServices
     */
    select?: UserPurchasedServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPurchasedServices
     */
    omit?: UserPurchasedServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPurchasedServicesInclude<ExtArgs> | null
  }


  /**
   * Model Coupon
   */

  export type AggregateCoupon = {
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  export type CouponAvgAggregateOutputType = {
    percentOff: number | null
    minAmount: number | null
    maxAmount: number | null
    planDays: number | null
  }

  export type CouponSumAggregateOutputType = {
    percentOff: number | null
    minAmount: number | null
    maxAmount: number | null
    planDays: number | null
  }

  export type CouponMinAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    percentOff: number | null
    expiryDate: Date | null
    minAmount: number | null
    maxAmount: number | null
    serviceId: string | null
    comboPlanId: string | null
    planDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponMaxAggregateOutputType = {
    id: string | null
    code: string | null
    description: string | null
    percentOff: number | null
    expiryDate: Date | null
    minAmount: number | null
    maxAmount: number | null
    serviceId: string | null
    comboPlanId: string | null
    planDays: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CouponCountAggregateOutputType = {
    id: number
    code: number
    description: number
    percentOff: number
    expiryDate: number
    minAmount: number
    maxAmount: number
    serviceId: number
    comboPlanId: number
    planDays: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CouponAvgAggregateInputType = {
    percentOff?: true
    minAmount?: true
    maxAmount?: true
    planDays?: true
  }

  export type CouponSumAggregateInputType = {
    percentOff?: true
    minAmount?: true
    maxAmount?: true
    planDays?: true
  }

  export type CouponMinAggregateInputType = {
    id?: true
    code?: true
    description?: true
    percentOff?: true
    expiryDate?: true
    minAmount?: true
    maxAmount?: true
    serviceId?: true
    comboPlanId?: true
    planDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponMaxAggregateInputType = {
    id?: true
    code?: true
    description?: true
    percentOff?: true
    expiryDate?: true
    minAmount?: true
    maxAmount?: true
    serviceId?: true
    comboPlanId?: true
    planDays?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CouponCountAggregateInputType = {
    id?: true
    code?: true
    description?: true
    percentOff?: true
    expiryDate?: true
    minAmount?: true
    maxAmount?: true
    serviceId?: true
    comboPlanId?: true
    planDays?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CouponAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupon to aggregate.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coupons
    **/
    _count?: true | CouponCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CouponAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CouponSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CouponMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CouponMaxAggregateInputType
  }

  export type GetCouponAggregateType<T extends CouponAggregateArgs> = {
        [P in keyof T & keyof AggregateCoupon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoupon[P]>
      : GetScalarType<T[P], AggregateCoupon[P]>
  }




  export type CouponGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithAggregationInput | CouponOrderByWithAggregationInput[]
    by: CouponScalarFieldEnum[] | CouponScalarFieldEnum
    having?: CouponScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CouponCountAggregateInputType | true
    _avg?: CouponAvgAggregateInputType
    _sum?: CouponSumAggregateInputType
    _min?: CouponMinAggregateInputType
    _max?: CouponMaxAggregateInputType
  }

  export type CouponGroupByOutputType = {
    id: string
    code: string
    description: string | null
    percentOff: number
    expiryDate: Date
    minAmount: number
    maxAmount: number | null
    serviceId: string | null
    comboPlanId: string | null
    planDays: number | null
    createdAt: Date
    updatedAt: Date
    _count: CouponCountAggregateOutputType | null
    _avg: CouponAvgAggregateOutputType | null
    _sum: CouponSumAggregateOutputType | null
    _min: CouponMinAggregateOutputType | null
    _max: CouponMaxAggregateOutputType | null
  }

  type GetCouponGroupByPayload<T extends CouponGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CouponGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CouponGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CouponGroupByOutputType[P]>
            : GetScalarType<T[P], CouponGroupByOutputType[P]>
        }
      >
    >


  export type CouponSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    percentOff?: boolean
    expiryDate?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    serviceId?: boolean
    comboPlanId?: boolean
    planDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comboPlan?: boolean | Coupon$comboPlanArgs<ExtArgs>
    service?: boolean | Coupon$serviceArgs<ExtArgs>
    transactions?: boolean | Coupon$transactionsArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    percentOff?: boolean
    expiryDate?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    serviceId?: boolean
    comboPlanId?: boolean
    planDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comboPlan?: boolean | Coupon$comboPlanArgs<ExtArgs>
    service?: boolean | Coupon$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    description?: boolean
    percentOff?: boolean
    expiryDate?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    serviceId?: boolean
    comboPlanId?: boolean
    planDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comboPlan?: boolean | Coupon$comboPlanArgs<ExtArgs>
    service?: boolean | Coupon$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["coupon"]>

  export type CouponSelectScalar = {
    id?: boolean
    code?: boolean
    description?: boolean
    percentOff?: boolean
    expiryDate?: boolean
    minAmount?: boolean
    maxAmount?: boolean
    serviceId?: boolean
    comboPlanId?: boolean
    planDays?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CouponOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "description" | "percentOff" | "expiryDate" | "minAmount" | "maxAmount" | "serviceId" | "comboPlanId" | "planDays" | "createdAt" | "updatedAt", ExtArgs["result"]["coupon"]>
  export type CouponInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comboPlan?: boolean | Coupon$comboPlanArgs<ExtArgs>
    service?: boolean | Coupon$serviceArgs<ExtArgs>
    transactions?: boolean | Coupon$transactionsArgs<ExtArgs>
    _count?: boolean | CouponCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CouponIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comboPlan?: boolean | Coupon$comboPlanArgs<ExtArgs>
    service?: boolean | Coupon$serviceArgs<ExtArgs>
  }
  export type CouponIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comboPlan?: boolean | Coupon$comboPlanArgs<ExtArgs>
    service?: boolean | Coupon$serviceArgs<ExtArgs>
  }

  export type $CouponPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Coupon"
    objects: {
      comboPlan: Prisma.$ComboPlanPayload<ExtArgs> | null
      service: Prisma.$ServicePayload<ExtArgs> | null
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      description: string | null
      percentOff: number
      expiryDate: Date
      minAmount: number
      maxAmount: number | null
      serviceId: string | null
      comboPlanId: string | null
      planDays: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coupon"]>
    composites: {}
  }

  type CouponGetPayload<S extends boolean | null | undefined | CouponDefaultArgs> = $Result.GetResult<Prisma.$CouponPayload, S>

  type CouponCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CouponFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CouponCountAggregateInputType | true
    }

  export interface CouponDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Coupon'], meta: { name: 'Coupon' } }
    /**
     * Find zero or one Coupon that matches the filter.
     * @param {CouponFindUniqueArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CouponFindUniqueArgs>(args: SelectSubset<T, CouponFindUniqueArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Coupon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CouponFindUniqueOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CouponFindUniqueOrThrowArgs>(args: SelectSubset<T, CouponFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CouponFindFirstArgs>(args?: SelectSubset<T, CouponFindFirstArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Coupon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindFirstOrThrowArgs} args - Arguments to find a Coupon
     * @example
     * // Get one Coupon
     * const coupon = await prisma.coupon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CouponFindFirstOrThrowArgs>(args?: SelectSubset<T, CouponFindFirstOrThrowArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Coupons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coupons
     * const coupons = await prisma.coupon.findMany()
     * 
     * // Get first 10 Coupons
     * const coupons = await prisma.coupon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const couponWithIdOnly = await prisma.coupon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CouponFindManyArgs>(args?: SelectSubset<T, CouponFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Coupon.
     * @param {CouponCreateArgs} args - Arguments to create a Coupon.
     * @example
     * // Create one Coupon
     * const Coupon = await prisma.coupon.create({
     *   data: {
     *     // ... data to create a Coupon
     *   }
     * })
     * 
     */
    create<T extends CouponCreateArgs>(args: SelectSubset<T, CouponCreateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Coupons.
     * @param {CouponCreateManyArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CouponCreateManyArgs>(args?: SelectSubset<T, CouponCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Coupons and returns the data saved in the database.
     * @param {CouponCreateManyAndReturnArgs} args - Arguments to create many Coupons.
     * @example
     * // Create many Coupons
     * const coupon = await prisma.coupon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CouponCreateManyAndReturnArgs>(args?: SelectSubset<T, CouponCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Coupon.
     * @param {CouponDeleteArgs} args - Arguments to delete one Coupon.
     * @example
     * // Delete one Coupon
     * const Coupon = await prisma.coupon.delete({
     *   where: {
     *     // ... filter to delete one Coupon
     *   }
     * })
     * 
     */
    delete<T extends CouponDeleteArgs>(args: SelectSubset<T, CouponDeleteArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Coupon.
     * @param {CouponUpdateArgs} args - Arguments to update one Coupon.
     * @example
     * // Update one Coupon
     * const coupon = await prisma.coupon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CouponUpdateArgs>(args: SelectSubset<T, CouponUpdateArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Coupons.
     * @param {CouponDeleteManyArgs} args - Arguments to filter Coupons to delete.
     * @example
     * // Delete a few Coupons
     * const { count } = await prisma.coupon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CouponDeleteManyArgs>(args?: SelectSubset<T, CouponDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CouponUpdateManyArgs>(args: SelectSubset<T, CouponUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coupons and returns the data updated in the database.
     * @param {CouponUpdateManyAndReturnArgs} args - Arguments to update many Coupons.
     * @example
     * // Update many Coupons
     * const coupon = await prisma.coupon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Coupons and only return the `id`
     * const couponWithIdOnly = await prisma.coupon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CouponUpdateManyAndReturnArgs>(args: SelectSubset<T, CouponUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Coupon.
     * @param {CouponUpsertArgs} args - Arguments to update or create a Coupon.
     * @example
     * // Update or create a Coupon
     * const coupon = await prisma.coupon.upsert({
     *   create: {
     *     // ... data to create a Coupon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Coupon we want to update
     *   }
     * })
     */
    upsert<T extends CouponUpsertArgs>(args: SelectSubset<T, CouponUpsertArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Coupons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponCountArgs} args - Arguments to filter Coupons to count.
     * @example
     * // Count the number of Coupons
     * const count = await prisma.coupon.count({
     *   where: {
     *     // ... the filter for the Coupons we want to count
     *   }
     * })
    **/
    count<T extends CouponCountArgs>(
      args?: Subset<T, CouponCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CouponCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CouponAggregateArgs>(args: Subset<T, CouponAggregateArgs>): Prisma.PrismaPromise<GetCouponAggregateType<T>>

    /**
     * Group by Coupon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CouponGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CouponGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CouponGroupByArgs['orderBy'] }
        : { orderBy?: CouponGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CouponGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCouponGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Coupon model
   */
  readonly fields: CouponFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Coupon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CouponClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comboPlan<T extends Coupon$comboPlanArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$comboPlanArgs<ExtArgs>>): Prisma__ComboPlanClient<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    service<T extends Coupon$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactions<T extends Coupon$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Coupon$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Coupon model
   */
  interface CouponFieldRefs {
    readonly id: FieldRef<"Coupon", 'String'>
    readonly code: FieldRef<"Coupon", 'String'>
    readonly description: FieldRef<"Coupon", 'String'>
    readonly percentOff: FieldRef<"Coupon", 'Float'>
    readonly expiryDate: FieldRef<"Coupon", 'DateTime'>
    readonly minAmount: FieldRef<"Coupon", 'Float'>
    readonly maxAmount: FieldRef<"Coupon", 'Float'>
    readonly serviceId: FieldRef<"Coupon", 'String'>
    readonly comboPlanId: FieldRef<"Coupon", 'String'>
    readonly planDays: FieldRef<"Coupon", 'Int'>
    readonly createdAt: FieldRef<"Coupon", 'DateTime'>
    readonly updatedAt: FieldRef<"Coupon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Coupon findUnique
   */
  export type CouponFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findUniqueOrThrow
   */
  export type CouponFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon findFirst
   */
  export type CouponFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findFirstOrThrow
   */
  export type CouponFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupon to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coupons.
     */
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon findMany
   */
  export type CouponFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter, which Coupons to fetch.
     */
    where?: CouponWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coupons to fetch.
     */
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coupons.
     */
    cursor?: CouponWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coupons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coupons.
     */
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Coupon create
   */
  export type CouponCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to create a Coupon.
     */
    data: XOR<CouponCreateInput, CouponUncheckedCreateInput>
  }

  /**
   * Coupon createMany
   */
  export type CouponCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Coupon createManyAndReturn
   */
  export type CouponCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data used to create many Coupons.
     */
    data: CouponCreateManyInput | CouponCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Coupon update
   */
  export type CouponUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The data needed to update a Coupon.
     */
    data: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
    /**
     * Choose, which Coupon to update.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon updateMany
   */
  export type CouponUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
  }

  /**
   * Coupon updateManyAndReturn
   */
  export type CouponUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * The data used to update Coupons.
     */
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyInput>
    /**
     * Filter which Coupons to update
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Coupon upsert
   */
  export type CouponUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * The filter to search for the Coupon to update in case it exists.
     */
    where: CouponWhereUniqueInput
    /**
     * In case the Coupon found by the `where` argument doesn't exist, create a new Coupon with this data.
     */
    create: XOR<CouponCreateInput, CouponUncheckedCreateInput>
    /**
     * In case the Coupon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CouponUpdateInput, CouponUncheckedUpdateInput>
  }

  /**
   * Coupon delete
   */
  export type CouponDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    /**
     * Filter which Coupon to delete.
     */
    where: CouponWhereUniqueInput
  }

  /**
   * Coupon deleteMany
   */
  export type CouponDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Coupons to delete
     */
    where?: CouponWhereInput
    /**
     * Limit how many Coupons to delete.
     */
    limit?: number
  }

  /**
   * Coupon.comboPlan
   */
  export type Coupon$comboPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlan
     */
    select?: ComboPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlan
     */
    omit?: ComboPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanInclude<ExtArgs> | null
    where?: ComboPlanWhereInput
  }

  /**
   * Coupon.service
   */
  export type Coupon$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * Coupon.transactions
   */
  export type Coupon$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Coupon without action
   */
  export type CouponDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    paymentId: string | null
    couponId: string | null
    userId: string | null
    serviceId: string | null
    comboPlanId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    paymentGateway: string | null
    idempotencyKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    paymentId: string | null
    couponId: string | null
    userId: string | null
    serviceId: string | null
    comboPlanId: string | null
    amount: number | null
    currency: string | null
    status: string | null
    paymentGateway: string | null
    idempotencyKey: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    orderId: number
    paymentId: number
    couponId: number
    userId: number
    serviceId: number
    comboPlanId: number
    amount: number
    tenure: number
    currency: number
    status: number
    paymentGateway: number
    idempotencyKey: number
    webhookResponse: number
    createdAt: number
    updatedAt: number
    extraData: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    orderId?: true
    paymentId?: true
    couponId?: true
    userId?: true
    serviceId?: true
    comboPlanId?: true
    amount?: true
    currency?: true
    status?: true
    paymentGateway?: true
    idempotencyKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    orderId?: true
    paymentId?: true
    couponId?: true
    userId?: true
    serviceId?: true
    comboPlanId?: true
    amount?: true
    currency?: true
    status?: true
    paymentGateway?: true
    idempotencyKey?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    orderId?: true
    paymentId?: true
    couponId?: true
    userId?: true
    serviceId?: true
    comboPlanId?: true
    amount?: true
    tenure?: true
    currency?: true
    status?: true
    paymentGateway?: true
    idempotencyKey?: true
    webhookResponse?: true
    createdAt?: true
    updatedAt?: true
    extraData?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    orderId: string | null
    paymentId: string | null
    couponId: string | null
    userId: string
    serviceId: string | null
    comboPlanId: string | null
    amount: number
    tenure: JsonValue | null
    currency: string
    status: string
    paymentGateway: string
    idempotencyKey: string | null
    webhookResponse: JsonValue | null
    createdAt: Date
    updatedAt: Date
    extraData: JsonValue | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    paymentId?: boolean
    couponId?: boolean
    userId?: boolean
    serviceId?: boolean
    comboPlanId?: boolean
    amount?: boolean
    tenure?: boolean
    currency?: boolean
    status?: boolean
    paymentGateway?: boolean
    idempotencyKey?: boolean
    webhookResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    extraData?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | Transaction$serviceArgs<ExtArgs>
    comboPlan?: boolean | Transaction$comboPlanArgs<ExtArgs>
    coupon?: boolean | Transaction$couponArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    paymentId?: boolean
    couponId?: boolean
    userId?: boolean
    serviceId?: boolean
    comboPlanId?: boolean
    amount?: boolean
    tenure?: boolean
    currency?: boolean
    status?: boolean
    paymentGateway?: boolean
    idempotencyKey?: boolean
    webhookResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    extraData?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | Transaction$serviceArgs<ExtArgs>
    comboPlan?: boolean | Transaction$comboPlanArgs<ExtArgs>
    coupon?: boolean | Transaction$couponArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    paymentId?: boolean
    couponId?: boolean
    userId?: boolean
    serviceId?: boolean
    comboPlanId?: boolean
    amount?: boolean
    tenure?: boolean
    currency?: boolean
    status?: boolean
    paymentGateway?: boolean
    idempotencyKey?: boolean
    webhookResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    extraData?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | Transaction$serviceArgs<ExtArgs>
    comboPlan?: boolean | Transaction$comboPlanArgs<ExtArgs>
    coupon?: boolean | Transaction$couponArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    orderId?: boolean
    paymentId?: boolean
    couponId?: boolean
    userId?: boolean
    serviceId?: boolean
    comboPlanId?: boolean
    amount?: boolean
    tenure?: boolean
    currency?: boolean
    status?: boolean
    paymentGateway?: boolean
    idempotencyKey?: boolean
    webhookResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    extraData?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "paymentId" | "couponId" | "userId" | "serviceId" | "comboPlanId" | "amount" | "tenure" | "currency" | "status" | "paymentGateway" | "idempotencyKey" | "webhookResponse" | "createdAt" | "updatedAt" | "extraData", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | Transaction$serviceArgs<ExtArgs>
    comboPlan?: boolean | Transaction$comboPlanArgs<ExtArgs>
    coupon?: boolean | Transaction$couponArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | Transaction$serviceArgs<ExtArgs>
    comboPlan?: boolean | Transaction$comboPlanArgs<ExtArgs>
    coupon?: boolean | Transaction$couponArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | Transaction$serviceArgs<ExtArgs>
    comboPlan?: boolean | Transaction$comboPlanArgs<ExtArgs>
    coupon?: boolean | Transaction$couponArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs> | null
      comboPlan: Prisma.$ComboPlanPayload<ExtArgs> | null
      coupon: Prisma.$CouponPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string | null
      paymentId: string | null
      couponId: string | null
      userId: string
      serviceId: string | null
      comboPlanId: string | null
      amount: number
      tenure: Prisma.JsonValue | null
      currency: string
      status: string
      paymentGateway: string
      idempotencyKey: string | null
      webhookResponse: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      extraData: Prisma.JsonValue | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends Transaction$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comboPlan<T extends Transaction$comboPlanArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$comboPlanArgs<ExtArgs>>): Prisma__ComboPlanClient<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    coupon<T extends Transaction$couponArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$couponArgs<ExtArgs>>): Prisma__CouponClient<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly orderId: FieldRef<"Transaction", 'String'>
    readonly paymentId: FieldRef<"Transaction", 'String'>
    readonly couponId: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly serviceId: FieldRef<"Transaction", 'String'>
    readonly comboPlanId: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly tenure: FieldRef<"Transaction", 'Json'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly status: FieldRef<"Transaction", 'String'>
    readonly paymentGateway: FieldRef<"Transaction", 'String'>
    readonly idempotencyKey: FieldRef<"Transaction", 'String'>
    readonly webhookResponse: FieldRef<"Transaction", 'Json'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
    readonly extraData: FieldRef<"Transaction", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.service
   */
  export type Transaction$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * Transaction.comboPlan
   */
  export type Transaction$comboPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlan
     */
    select?: ComboPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlan
     */
    omit?: ComboPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanInclude<ExtArgs> | null
    where?: ComboPlanWhereInput
  }

  /**
   * Transaction.coupon
   */
  export type Transaction$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model UserDocuments
   */

  export type AggregateUserDocuments = {
    _count: UserDocumentsCountAggregateOutputType | null
    _min: UserDocumentsMinAggregateOutputType | null
    _max: UserDocumentsMaxAggregateOutputType | null
  }

  export type UserDocumentsMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    userId: string | null
    documentUrl: string | null
    reviewedDocumentUrl: string | null
    status: $Enums.DocumentStatus | null
    reviewedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserDocumentsMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    userId: string | null
    documentUrl: string | null
    reviewedDocumentUrl: string | null
    status: $Enums.DocumentStatus | null
    reviewedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserDocumentsCountAggregateOutputType = {
    id: number
    serviceId: number
    userId: number
    documentUrl: number
    reviewedDocumentUrl: number
    status: number
    reviewedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserDocumentsMinAggregateInputType = {
    id?: true
    serviceId?: true
    userId?: true
    documentUrl?: true
    reviewedDocumentUrl?: true
    status?: true
    reviewedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserDocumentsMaxAggregateInputType = {
    id?: true
    serviceId?: true
    userId?: true
    documentUrl?: true
    reviewedDocumentUrl?: true
    status?: true
    reviewedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserDocumentsCountAggregateInputType = {
    id?: true
    serviceId?: true
    userId?: true
    documentUrl?: true
    reviewedDocumentUrl?: true
    status?: true
    reviewedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserDocumentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDocuments to aggregate.
     */
    where?: UserDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocuments to fetch.
     */
    orderBy?: UserDocumentsOrderByWithRelationInput | UserDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserDocuments
    **/
    _count?: true | UserDocumentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserDocumentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserDocumentsMaxAggregateInputType
  }

  export type GetUserDocumentsAggregateType<T extends UserDocumentsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserDocuments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserDocuments[P]>
      : GetScalarType<T[P], AggregateUserDocuments[P]>
  }




  export type UserDocumentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserDocumentsWhereInput
    orderBy?: UserDocumentsOrderByWithAggregationInput | UserDocumentsOrderByWithAggregationInput[]
    by: UserDocumentsScalarFieldEnum[] | UserDocumentsScalarFieldEnum
    having?: UserDocumentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserDocumentsCountAggregateInputType | true
    _min?: UserDocumentsMinAggregateInputType
    _max?: UserDocumentsMaxAggregateInputType
  }

  export type UserDocumentsGroupByOutputType = {
    id: string
    serviceId: string
    userId: string
    documentUrl: string
    reviewedDocumentUrl: string | null
    status: $Enums.DocumentStatus
    reviewedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserDocumentsCountAggregateOutputType | null
    _min: UserDocumentsMinAggregateOutputType | null
    _max: UserDocumentsMaxAggregateOutputType | null
  }

  type GetUserDocumentsGroupByPayload<T extends UserDocumentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserDocumentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserDocumentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserDocumentsGroupByOutputType[P]>
            : GetScalarType<T[P], UserDocumentsGroupByOutputType[P]>
        }
      >
    >


  export type UserDocumentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    userId?: boolean
    documentUrl?: boolean
    reviewedDocumentUrl?: boolean
    status?: boolean
    reviewedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | UserDocuments$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["userDocuments"]>

  export type UserDocumentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    userId?: boolean
    documentUrl?: boolean
    reviewedDocumentUrl?: boolean
    status?: boolean
    reviewedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | UserDocuments$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["userDocuments"]>

  export type UserDocumentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    userId?: boolean
    documentUrl?: boolean
    reviewedDocumentUrl?: boolean
    status?: boolean
    reviewedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | UserDocuments$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["userDocuments"]>

  export type UserDocumentsSelectScalar = {
    id?: boolean
    serviceId?: boolean
    userId?: boolean
    documentUrl?: boolean
    reviewedDocumentUrl?: boolean
    status?: boolean
    reviewedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserDocumentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceId" | "userId" | "documentUrl" | "reviewedDocumentUrl" | "status" | "reviewedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["userDocuments"]>
  export type UserDocumentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | UserDocuments$serviceArgs<ExtArgs>
  }
  export type UserDocumentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | UserDocuments$serviceArgs<ExtArgs>
  }
  export type UserDocumentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    service?: boolean | UserDocuments$serviceArgs<ExtArgs>
  }

  export type $UserDocumentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserDocuments"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      userId: string
      documentUrl: string
      reviewedDocumentUrl: string | null
      status: $Enums.DocumentStatus
      reviewedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userDocuments"]>
    composites: {}
  }

  type UserDocumentsGetPayload<S extends boolean | null | undefined | UserDocumentsDefaultArgs> = $Result.GetResult<Prisma.$UserDocumentsPayload, S>

  type UserDocumentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserDocumentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserDocumentsCountAggregateInputType | true
    }

  export interface UserDocumentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserDocuments'], meta: { name: 'UserDocuments' } }
    /**
     * Find zero or one UserDocuments that matches the filter.
     * @param {UserDocumentsFindUniqueArgs} args - Arguments to find a UserDocuments
     * @example
     * // Get one UserDocuments
     * const userDocuments = await prisma.userDocuments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserDocumentsFindUniqueArgs>(args: SelectSubset<T, UserDocumentsFindUniqueArgs<ExtArgs>>): Prisma__UserDocumentsClient<$Result.GetResult<Prisma.$UserDocumentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserDocuments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserDocumentsFindUniqueOrThrowArgs} args - Arguments to find a UserDocuments
     * @example
     * // Get one UserDocuments
     * const userDocuments = await prisma.userDocuments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserDocumentsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserDocumentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserDocumentsClient<$Result.GetResult<Prisma.$UserDocumentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentsFindFirstArgs} args - Arguments to find a UserDocuments
     * @example
     * // Get one UserDocuments
     * const userDocuments = await prisma.userDocuments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserDocumentsFindFirstArgs>(args?: SelectSubset<T, UserDocumentsFindFirstArgs<ExtArgs>>): Prisma__UserDocumentsClient<$Result.GetResult<Prisma.$UserDocumentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserDocuments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentsFindFirstOrThrowArgs} args - Arguments to find a UserDocuments
     * @example
     * // Get one UserDocuments
     * const userDocuments = await prisma.userDocuments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserDocumentsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserDocumentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserDocumentsClient<$Result.GetResult<Prisma.$UserDocumentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserDocuments
     * const userDocuments = await prisma.userDocuments.findMany()
     * 
     * // Get first 10 UserDocuments
     * const userDocuments = await prisma.userDocuments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userDocumentsWithIdOnly = await prisma.userDocuments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserDocumentsFindManyArgs>(args?: SelectSubset<T, UserDocumentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDocumentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserDocuments.
     * @param {UserDocumentsCreateArgs} args - Arguments to create a UserDocuments.
     * @example
     * // Create one UserDocuments
     * const UserDocuments = await prisma.userDocuments.create({
     *   data: {
     *     // ... data to create a UserDocuments
     *   }
     * })
     * 
     */
    create<T extends UserDocumentsCreateArgs>(args: SelectSubset<T, UserDocumentsCreateArgs<ExtArgs>>): Prisma__UserDocumentsClient<$Result.GetResult<Prisma.$UserDocumentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserDocuments.
     * @param {UserDocumentsCreateManyArgs} args - Arguments to create many UserDocuments.
     * @example
     * // Create many UserDocuments
     * const userDocuments = await prisma.userDocuments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserDocumentsCreateManyArgs>(args?: SelectSubset<T, UserDocumentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserDocuments and returns the data saved in the database.
     * @param {UserDocumentsCreateManyAndReturnArgs} args - Arguments to create many UserDocuments.
     * @example
     * // Create many UserDocuments
     * const userDocuments = await prisma.userDocuments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserDocuments and only return the `id`
     * const userDocumentsWithIdOnly = await prisma.userDocuments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserDocumentsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserDocumentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDocumentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserDocuments.
     * @param {UserDocumentsDeleteArgs} args - Arguments to delete one UserDocuments.
     * @example
     * // Delete one UserDocuments
     * const UserDocuments = await prisma.userDocuments.delete({
     *   where: {
     *     // ... filter to delete one UserDocuments
     *   }
     * })
     * 
     */
    delete<T extends UserDocumentsDeleteArgs>(args: SelectSubset<T, UserDocumentsDeleteArgs<ExtArgs>>): Prisma__UserDocumentsClient<$Result.GetResult<Prisma.$UserDocumentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserDocuments.
     * @param {UserDocumentsUpdateArgs} args - Arguments to update one UserDocuments.
     * @example
     * // Update one UserDocuments
     * const userDocuments = await prisma.userDocuments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserDocumentsUpdateArgs>(args: SelectSubset<T, UserDocumentsUpdateArgs<ExtArgs>>): Prisma__UserDocumentsClient<$Result.GetResult<Prisma.$UserDocumentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserDocuments.
     * @param {UserDocumentsDeleteManyArgs} args - Arguments to filter UserDocuments to delete.
     * @example
     * // Delete a few UserDocuments
     * const { count } = await prisma.userDocuments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDocumentsDeleteManyArgs>(args?: SelectSubset<T, UserDocumentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserDocuments
     * const userDocuments = await prisma.userDocuments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserDocumentsUpdateManyArgs>(args: SelectSubset<T, UserDocumentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserDocuments and returns the data updated in the database.
     * @param {UserDocumentsUpdateManyAndReturnArgs} args - Arguments to update many UserDocuments.
     * @example
     * // Update many UserDocuments
     * const userDocuments = await prisma.userDocuments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserDocuments and only return the `id`
     * const userDocumentsWithIdOnly = await prisma.userDocuments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserDocumentsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserDocumentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDocumentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserDocuments.
     * @param {UserDocumentsUpsertArgs} args - Arguments to update or create a UserDocuments.
     * @example
     * // Update or create a UserDocuments
     * const userDocuments = await prisma.userDocuments.upsert({
     *   create: {
     *     // ... data to create a UserDocuments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserDocuments we want to update
     *   }
     * })
     */
    upsert<T extends UserDocumentsUpsertArgs>(args: SelectSubset<T, UserDocumentsUpsertArgs<ExtArgs>>): Prisma__UserDocumentsClient<$Result.GetResult<Prisma.$UserDocumentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentsCountArgs} args - Arguments to filter UserDocuments to count.
     * @example
     * // Count the number of UserDocuments
     * const count = await prisma.userDocuments.count({
     *   where: {
     *     // ... the filter for the UserDocuments we want to count
     *   }
     * })
    **/
    count<T extends UserDocumentsCountArgs>(
      args?: Subset<T, UserDocumentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserDocumentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserDocumentsAggregateArgs>(args: Subset<T, UserDocumentsAggregateArgs>): Prisma.PrismaPromise<GetUserDocumentsAggregateType<T>>

    /**
     * Group by UserDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserDocumentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserDocumentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserDocumentsGroupByArgs['orderBy'] }
        : { orderBy?: UserDocumentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserDocumentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserDocumentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserDocuments model
   */
  readonly fields: UserDocumentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserDocuments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserDocumentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends UserDocuments$serviceArgs<ExtArgs> = {}>(args?: Subset<T, UserDocuments$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserDocuments model
   */
  interface UserDocumentsFieldRefs {
    readonly id: FieldRef<"UserDocuments", 'String'>
    readonly serviceId: FieldRef<"UserDocuments", 'String'>
    readonly userId: FieldRef<"UserDocuments", 'String'>
    readonly documentUrl: FieldRef<"UserDocuments", 'String'>
    readonly reviewedDocumentUrl: FieldRef<"UserDocuments", 'String'>
    readonly status: FieldRef<"UserDocuments", 'DocumentStatus'>
    readonly reviewedBy: FieldRef<"UserDocuments", 'String'>
    readonly createdAt: FieldRef<"UserDocuments", 'DateTime'>
    readonly updatedAt: FieldRef<"UserDocuments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserDocuments findUnique
   */
  export type UserDocumentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocuments
     */
    select?: UserDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDocuments
     */
    omit?: UserDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which UserDocuments to fetch.
     */
    where: UserDocumentsWhereUniqueInput
  }

  /**
   * UserDocuments findUniqueOrThrow
   */
  export type UserDocumentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocuments
     */
    select?: UserDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDocuments
     */
    omit?: UserDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which UserDocuments to fetch.
     */
    where: UserDocumentsWhereUniqueInput
  }

  /**
   * UserDocuments findFirst
   */
  export type UserDocumentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocuments
     */
    select?: UserDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDocuments
     */
    omit?: UserDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which UserDocuments to fetch.
     */
    where?: UserDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocuments to fetch.
     */
    orderBy?: UserDocumentsOrderByWithRelationInput | UserDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDocuments.
     */
    cursor?: UserDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDocuments.
     */
    distinct?: UserDocumentsScalarFieldEnum | UserDocumentsScalarFieldEnum[]
  }

  /**
   * UserDocuments findFirstOrThrow
   */
  export type UserDocumentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocuments
     */
    select?: UserDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDocuments
     */
    omit?: UserDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which UserDocuments to fetch.
     */
    where?: UserDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocuments to fetch.
     */
    orderBy?: UserDocumentsOrderByWithRelationInput | UserDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserDocuments.
     */
    cursor?: UserDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserDocuments.
     */
    distinct?: UserDocumentsScalarFieldEnum | UserDocumentsScalarFieldEnum[]
  }

  /**
   * UserDocuments findMany
   */
  export type UserDocumentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocuments
     */
    select?: UserDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDocuments
     */
    omit?: UserDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDocumentsInclude<ExtArgs> | null
    /**
     * Filter, which UserDocuments to fetch.
     */
    where?: UserDocumentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserDocuments to fetch.
     */
    orderBy?: UserDocumentsOrderByWithRelationInput | UserDocumentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserDocuments.
     */
    cursor?: UserDocumentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserDocuments.
     */
    skip?: number
    distinct?: UserDocumentsScalarFieldEnum | UserDocumentsScalarFieldEnum[]
  }

  /**
   * UserDocuments create
   */
  export type UserDocumentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocuments
     */
    select?: UserDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDocuments
     */
    omit?: UserDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDocumentsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserDocuments.
     */
    data: XOR<UserDocumentsCreateInput, UserDocumentsUncheckedCreateInput>
  }

  /**
   * UserDocuments createMany
   */
  export type UserDocumentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserDocuments.
     */
    data: UserDocumentsCreateManyInput | UserDocumentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserDocuments createManyAndReturn
   */
  export type UserDocumentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocuments
     */
    select?: UserDocumentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDocuments
     */
    omit?: UserDocumentsOmit<ExtArgs> | null
    /**
     * The data used to create many UserDocuments.
     */
    data: UserDocumentsCreateManyInput | UserDocumentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDocumentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDocuments update
   */
  export type UserDocumentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocuments
     */
    select?: UserDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDocuments
     */
    omit?: UserDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDocumentsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserDocuments.
     */
    data: XOR<UserDocumentsUpdateInput, UserDocumentsUncheckedUpdateInput>
    /**
     * Choose, which UserDocuments to update.
     */
    where: UserDocumentsWhereUniqueInput
  }

  /**
   * UserDocuments updateMany
   */
  export type UserDocumentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserDocuments.
     */
    data: XOR<UserDocumentsUpdateManyMutationInput, UserDocumentsUncheckedUpdateManyInput>
    /**
     * Filter which UserDocuments to update
     */
    where?: UserDocumentsWhereInput
    /**
     * Limit how many UserDocuments to update.
     */
    limit?: number
  }

  /**
   * UserDocuments updateManyAndReturn
   */
  export type UserDocumentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocuments
     */
    select?: UserDocumentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserDocuments
     */
    omit?: UserDocumentsOmit<ExtArgs> | null
    /**
     * The data used to update UserDocuments.
     */
    data: XOR<UserDocumentsUpdateManyMutationInput, UserDocumentsUncheckedUpdateManyInput>
    /**
     * Filter which UserDocuments to update
     */
    where?: UserDocumentsWhereInput
    /**
     * Limit how many UserDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDocumentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserDocuments upsert
   */
  export type UserDocumentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocuments
     */
    select?: UserDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDocuments
     */
    omit?: UserDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDocumentsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserDocuments to update in case it exists.
     */
    where: UserDocumentsWhereUniqueInput
    /**
     * In case the UserDocuments found by the `where` argument doesn't exist, create a new UserDocuments with this data.
     */
    create: XOR<UserDocumentsCreateInput, UserDocumentsUncheckedCreateInput>
    /**
     * In case the UserDocuments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserDocumentsUpdateInput, UserDocumentsUncheckedUpdateInput>
  }

  /**
   * UserDocuments delete
   */
  export type UserDocumentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocuments
     */
    select?: UserDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDocuments
     */
    omit?: UserDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDocumentsInclude<ExtArgs> | null
    /**
     * Filter which UserDocuments to delete.
     */
    where: UserDocumentsWhereUniqueInput
  }

  /**
   * UserDocuments deleteMany
   */
  export type UserDocumentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserDocuments to delete
     */
    where?: UserDocumentsWhereInput
    /**
     * Limit how many UserDocuments to delete.
     */
    limit?: number
  }

  /**
   * UserDocuments.service
   */
  export type UserDocuments$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * UserDocuments without action
   */
  export type UserDocumentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocuments
     */
    select?: UserDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDocuments
     */
    omit?: UserDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDocumentsInclude<ExtArgs> | null
  }


  /**
   * Model Agreement
   */

  export type AggregateAgreement = {
    _count: AgreementCountAggregateOutputType | null
    _avg: AgreementAvgAggregateOutputType | null
    _sum: AgreementSumAggregateOutputType | null
    _min: AgreementMinAggregateOutputType | null
    _max: AgreementMaxAggregateOutputType | null
  }

  export type AgreementAvgAggregateOutputType = {
    version: number | null
  }

  export type AgreementSumAggregateOutputType = {
    version: number | null
  }

  export type AgreementMinAggregateOutputType = {
    id: string | null
    name: string | null
    version: number | null
    hash: string | null
    signatoryPerson: string | null
    companyName: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type AgreementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    version: number | null
    hash: string | null
    signatoryPerson: string | null
    companyName: string | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type AgreementCountAggregateOutputType = {
    id: number
    name: number
    content: number
    version: number
    hash: number
    signatoryPerson: number
    companyName: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type AgreementAvgAggregateInputType = {
    version?: true
  }

  export type AgreementSumAggregateInputType = {
    version?: true
  }

  export type AgreementMinAggregateInputType = {
    id?: true
    name?: true
    version?: true
    hash?: true
    signatoryPerson?: true
    companyName?: true
    updatedAt?: true
    createdAt?: true
  }

  export type AgreementMaxAggregateInputType = {
    id?: true
    name?: true
    version?: true
    hash?: true
    signatoryPerson?: true
    companyName?: true
    updatedAt?: true
    createdAt?: true
  }

  export type AgreementCountAggregateInputType = {
    id?: true
    name?: true
    content?: true
    version?: true
    hash?: true
    signatoryPerson?: true
    companyName?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type AgreementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agreement to aggregate.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agreements
    **/
    _count?: true | AgreementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgreementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgreementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgreementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgreementMaxAggregateInputType
  }

  export type GetAgreementAggregateType<T extends AgreementAggregateArgs> = {
        [P in keyof T & keyof AggregateAgreement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgreement[P]>
      : GetScalarType<T[P], AggregateAgreement[P]>
  }




  export type AgreementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgreementWhereInput
    orderBy?: AgreementOrderByWithAggregationInput | AgreementOrderByWithAggregationInput[]
    by: AgreementScalarFieldEnum[] | AgreementScalarFieldEnum
    having?: AgreementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgreementCountAggregateInputType | true
    _avg?: AgreementAvgAggregateInputType
    _sum?: AgreementSumAggregateInputType
    _min?: AgreementMinAggregateInputType
    _max?: AgreementMaxAggregateInputType
  }

  export type AgreementGroupByOutputType = {
    id: string
    name: string
    content: JsonValue
    version: number
    hash: string
    signatoryPerson: string | null
    companyName: string | null
    updatedAt: Date
    createdAt: Date
    _count: AgreementCountAggregateOutputType | null
    _avg: AgreementAvgAggregateOutputType | null
    _sum: AgreementSumAggregateOutputType | null
    _min: AgreementMinAggregateOutputType | null
    _max: AgreementMaxAggregateOutputType | null
  }

  type GetAgreementGroupByPayload<T extends AgreementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgreementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgreementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgreementGroupByOutputType[P]>
            : GetScalarType<T[P], AgreementGroupByOutputType[P]>
        }
      >
    >


  export type AgreementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    version?: boolean
    hash?: boolean
    signatoryPerson?: boolean
    companyName?: boolean
    updatedAt?: boolean
    createdAt?: boolean
    serviceAgreements?: boolean | Agreement$serviceAgreementsArgs<ExtArgs>
    comboPlanAgreements?: boolean | Agreement$comboPlanAgreementsArgs<ExtArgs>
    _count?: boolean | AgreementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agreement"]>

  export type AgreementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    version?: boolean
    hash?: boolean
    signatoryPerson?: boolean
    companyName?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["agreement"]>

  export type AgreementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    version?: boolean
    hash?: boolean
    signatoryPerson?: boolean
    companyName?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["agreement"]>

  export type AgreementSelectScalar = {
    id?: boolean
    name?: boolean
    content?: boolean
    version?: boolean
    hash?: boolean
    signatoryPerson?: boolean
    companyName?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }

  export type AgreementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "content" | "version" | "hash" | "signatoryPerson" | "companyName" | "updatedAt" | "createdAt", ExtArgs["result"]["agreement"]>
  export type AgreementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceAgreements?: boolean | Agreement$serviceAgreementsArgs<ExtArgs>
    comboPlanAgreements?: boolean | Agreement$comboPlanAgreementsArgs<ExtArgs>
    _count?: boolean | AgreementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgreementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AgreementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AgreementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agreement"
    objects: {
      serviceAgreements: Prisma.$ServiceAgreementPayload<ExtArgs>[]
      comboPlanAgreements: Prisma.$ComboPlanAgreementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      content: Prisma.JsonValue
      version: number
      hash: string
      signatoryPerson: string | null
      companyName: string | null
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["agreement"]>
    composites: {}
  }

  type AgreementGetPayload<S extends boolean | null | undefined | AgreementDefaultArgs> = $Result.GetResult<Prisma.$AgreementPayload, S>

  type AgreementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgreementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgreementCountAggregateInputType | true
    }

  export interface AgreementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agreement'], meta: { name: 'Agreement' } }
    /**
     * Find zero or one Agreement that matches the filter.
     * @param {AgreementFindUniqueArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgreementFindUniqueArgs>(args: SelectSubset<T, AgreementFindUniqueArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agreement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgreementFindUniqueOrThrowArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgreementFindUniqueOrThrowArgs>(args: SelectSubset<T, AgreementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agreement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementFindFirstArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgreementFindFirstArgs>(args?: SelectSubset<T, AgreementFindFirstArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agreement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementFindFirstOrThrowArgs} args - Arguments to find a Agreement
     * @example
     * // Get one Agreement
     * const agreement = await prisma.agreement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgreementFindFirstOrThrowArgs>(args?: SelectSubset<T, AgreementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agreements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agreements
     * const agreements = await prisma.agreement.findMany()
     * 
     * // Get first 10 Agreements
     * const agreements = await prisma.agreement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agreementWithIdOnly = await prisma.agreement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgreementFindManyArgs>(args?: SelectSubset<T, AgreementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agreement.
     * @param {AgreementCreateArgs} args - Arguments to create a Agreement.
     * @example
     * // Create one Agreement
     * const Agreement = await prisma.agreement.create({
     *   data: {
     *     // ... data to create a Agreement
     *   }
     * })
     * 
     */
    create<T extends AgreementCreateArgs>(args: SelectSubset<T, AgreementCreateArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agreements.
     * @param {AgreementCreateManyArgs} args - Arguments to create many Agreements.
     * @example
     * // Create many Agreements
     * const agreement = await prisma.agreement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgreementCreateManyArgs>(args?: SelectSubset<T, AgreementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agreements and returns the data saved in the database.
     * @param {AgreementCreateManyAndReturnArgs} args - Arguments to create many Agreements.
     * @example
     * // Create many Agreements
     * const agreement = await prisma.agreement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agreements and only return the `id`
     * const agreementWithIdOnly = await prisma.agreement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgreementCreateManyAndReturnArgs>(args?: SelectSubset<T, AgreementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agreement.
     * @param {AgreementDeleteArgs} args - Arguments to delete one Agreement.
     * @example
     * // Delete one Agreement
     * const Agreement = await prisma.agreement.delete({
     *   where: {
     *     // ... filter to delete one Agreement
     *   }
     * })
     * 
     */
    delete<T extends AgreementDeleteArgs>(args: SelectSubset<T, AgreementDeleteArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agreement.
     * @param {AgreementUpdateArgs} args - Arguments to update one Agreement.
     * @example
     * // Update one Agreement
     * const agreement = await prisma.agreement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgreementUpdateArgs>(args: SelectSubset<T, AgreementUpdateArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agreements.
     * @param {AgreementDeleteManyArgs} args - Arguments to filter Agreements to delete.
     * @example
     * // Delete a few Agreements
     * const { count } = await prisma.agreement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgreementDeleteManyArgs>(args?: SelectSubset<T, AgreementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agreements
     * const agreement = await prisma.agreement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgreementUpdateManyArgs>(args: SelectSubset<T, AgreementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agreements and returns the data updated in the database.
     * @param {AgreementUpdateManyAndReturnArgs} args - Arguments to update many Agreements.
     * @example
     * // Update many Agreements
     * const agreement = await prisma.agreement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agreements and only return the `id`
     * const agreementWithIdOnly = await prisma.agreement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgreementUpdateManyAndReturnArgs>(args: SelectSubset<T, AgreementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agreement.
     * @param {AgreementUpsertArgs} args - Arguments to update or create a Agreement.
     * @example
     * // Update or create a Agreement
     * const agreement = await prisma.agreement.upsert({
     *   create: {
     *     // ... data to create a Agreement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agreement we want to update
     *   }
     * })
     */
    upsert<T extends AgreementUpsertArgs>(args: SelectSubset<T, AgreementUpsertArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementCountArgs} args - Arguments to filter Agreements to count.
     * @example
     * // Count the number of Agreements
     * const count = await prisma.agreement.count({
     *   where: {
     *     // ... the filter for the Agreements we want to count
     *   }
     * })
    **/
    count<T extends AgreementCountArgs>(
      args?: Subset<T, AgreementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgreementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgreementAggregateArgs>(args: Subset<T, AgreementAggregateArgs>): Prisma.PrismaPromise<GetAgreementAggregateType<T>>

    /**
     * Group by Agreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgreementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgreementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgreementGroupByArgs['orderBy'] }
        : { orderBy?: AgreementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgreementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgreementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agreement model
   */
  readonly fields: AgreementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agreement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgreementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceAgreements<T extends Agreement$serviceAgreementsArgs<ExtArgs> = {}>(args?: Subset<T, Agreement$serviceAgreementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comboPlanAgreements<T extends Agreement$comboPlanAgreementsArgs<ExtArgs> = {}>(args?: Subset<T, Agreement$comboPlanAgreementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPlanAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agreement model
   */
  interface AgreementFieldRefs {
    readonly id: FieldRef<"Agreement", 'String'>
    readonly name: FieldRef<"Agreement", 'String'>
    readonly content: FieldRef<"Agreement", 'Json'>
    readonly version: FieldRef<"Agreement", 'Int'>
    readonly hash: FieldRef<"Agreement", 'String'>
    readonly signatoryPerson: FieldRef<"Agreement", 'String'>
    readonly companyName: FieldRef<"Agreement", 'String'>
    readonly updatedAt: FieldRef<"Agreement", 'DateTime'>
    readonly createdAt: FieldRef<"Agreement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agreement findUnique
   */
  export type AgreementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agreement
     */
    omit?: AgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where: AgreementWhereUniqueInput
  }

  /**
   * Agreement findUniqueOrThrow
   */
  export type AgreementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agreement
     */
    omit?: AgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where: AgreementWhereUniqueInput
  }

  /**
   * Agreement findFirst
   */
  export type AgreementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agreement
     */
    omit?: AgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agreements.
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agreements.
     */
    distinct?: AgreementScalarFieldEnum | AgreementScalarFieldEnum[]
  }

  /**
   * Agreement findFirstOrThrow
   */
  export type AgreementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agreement
     */
    omit?: AgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreement to fetch.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agreements.
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agreements.
     */
    distinct?: AgreementScalarFieldEnum | AgreementScalarFieldEnum[]
  }

  /**
   * Agreement findMany
   */
  export type AgreementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agreement
     */
    omit?: AgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter, which Agreements to fetch.
     */
    where?: AgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agreements to fetch.
     */
    orderBy?: AgreementOrderByWithRelationInput | AgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agreements.
     */
    cursor?: AgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agreements.
     */
    skip?: number
    distinct?: AgreementScalarFieldEnum | AgreementScalarFieldEnum[]
  }

  /**
   * Agreement create
   */
  export type AgreementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agreement
     */
    omit?: AgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * The data needed to create a Agreement.
     */
    data: XOR<AgreementCreateInput, AgreementUncheckedCreateInput>
  }

  /**
   * Agreement createMany
   */
  export type AgreementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agreements.
     */
    data: AgreementCreateManyInput | AgreementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agreement createManyAndReturn
   */
  export type AgreementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agreement
     */
    omit?: AgreementOmit<ExtArgs> | null
    /**
     * The data used to create many Agreements.
     */
    data: AgreementCreateManyInput | AgreementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agreement update
   */
  export type AgreementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agreement
     */
    omit?: AgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * The data needed to update a Agreement.
     */
    data: XOR<AgreementUpdateInput, AgreementUncheckedUpdateInput>
    /**
     * Choose, which Agreement to update.
     */
    where: AgreementWhereUniqueInput
  }

  /**
   * Agreement updateMany
   */
  export type AgreementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agreements.
     */
    data: XOR<AgreementUpdateManyMutationInput, AgreementUncheckedUpdateManyInput>
    /**
     * Filter which Agreements to update
     */
    where?: AgreementWhereInput
    /**
     * Limit how many Agreements to update.
     */
    limit?: number
  }

  /**
   * Agreement updateManyAndReturn
   */
  export type AgreementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agreement
     */
    omit?: AgreementOmit<ExtArgs> | null
    /**
     * The data used to update Agreements.
     */
    data: XOR<AgreementUpdateManyMutationInput, AgreementUncheckedUpdateManyInput>
    /**
     * Filter which Agreements to update
     */
    where?: AgreementWhereInput
    /**
     * Limit how many Agreements to update.
     */
    limit?: number
  }

  /**
   * Agreement upsert
   */
  export type AgreementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agreement
     */
    omit?: AgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * The filter to search for the Agreement to update in case it exists.
     */
    where: AgreementWhereUniqueInput
    /**
     * In case the Agreement found by the `where` argument doesn't exist, create a new Agreement with this data.
     */
    create: XOR<AgreementCreateInput, AgreementUncheckedCreateInput>
    /**
     * In case the Agreement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgreementUpdateInput, AgreementUncheckedUpdateInput>
  }

  /**
   * Agreement delete
   */
  export type AgreementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agreement
     */
    omit?: AgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
    /**
     * Filter which Agreement to delete.
     */
    where: AgreementWhereUniqueInput
  }

  /**
   * Agreement deleteMany
   */
  export type AgreementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agreements to delete
     */
    where?: AgreementWhereInput
    /**
     * Limit how many Agreements to delete.
     */
    limit?: number
  }

  /**
   * Agreement.serviceAgreements
   */
  export type Agreement$serviceAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAgreement
     */
    select?: ServiceAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAgreement
     */
    omit?: ServiceAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAgreementInclude<ExtArgs> | null
    where?: ServiceAgreementWhereInput
    orderBy?: ServiceAgreementOrderByWithRelationInput | ServiceAgreementOrderByWithRelationInput[]
    cursor?: ServiceAgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceAgreementScalarFieldEnum | ServiceAgreementScalarFieldEnum[]
  }

  /**
   * Agreement.comboPlanAgreements
   */
  export type Agreement$comboPlanAgreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanAgreement
     */
    select?: ComboPlanAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanAgreement
     */
    omit?: ComboPlanAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanAgreementInclude<ExtArgs> | null
    where?: ComboPlanAgreementWhereInput
    orderBy?: ComboPlanAgreementOrderByWithRelationInput | ComboPlanAgreementOrderByWithRelationInput[]
    cursor?: ComboPlanAgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComboPlanAgreementScalarFieldEnum | ComboPlanAgreementScalarFieldEnum[]
  }

  /**
   * Agreement without action
   */
  export type AgreementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agreement
     */
    select?: AgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agreement
     */
    omit?: AgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgreementInclude<ExtArgs> | null
  }


  /**
   * Model ServiceAgreement
   */

  export type AggregateServiceAgreement = {
    _count: ServiceAgreementCountAggregateOutputType | null
    _min: ServiceAgreementMinAggregateOutputType | null
    _max: ServiceAgreementMaxAggregateOutputType | null
  }

  export type ServiceAgreementMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    agreementId: string | null
  }

  export type ServiceAgreementMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    agreementId: string | null
  }

  export type ServiceAgreementCountAggregateOutputType = {
    id: number
    serviceId: number
    agreementId: number
    _all: number
  }


  export type ServiceAgreementMinAggregateInputType = {
    id?: true
    serviceId?: true
    agreementId?: true
  }

  export type ServiceAgreementMaxAggregateInputType = {
    id?: true
    serviceId?: true
    agreementId?: true
  }

  export type ServiceAgreementCountAggregateInputType = {
    id?: true
    serviceId?: true
    agreementId?: true
    _all?: true
  }

  export type ServiceAgreementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAgreement to aggregate.
     */
    where?: ServiceAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAgreements to fetch.
     */
    orderBy?: ServiceAgreementOrderByWithRelationInput | ServiceAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceAgreements
    **/
    _count?: true | ServiceAgreementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceAgreementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceAgreementMaxAggregateInputType
  }

  export type GetServiceAgreementAggregateType<T extends ServiceAgreementAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceAgreement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceAgreement[P]>
      : GetScalarType<T[P], AggregateServiceAgreement[P]>
  }




  export type ServiceAgreementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAgreementWhereInput
    orderBy?: ServiceAgreementOrderByWithAggregationInput | ServiceAgreementOrderByWithAggregationInput[]
    by: ServiceAgreementScalarFieldEnum[] | ServiceAgreementScalarFieldEnum
    having?: ServiceAgreementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceAgreementCountAggregateInputType | true
    _min?: ServiceAgreementMinAggregateInputType
    _max?: ServiceAgreementMaxAggregateInputType
  }

  export type ServiceAgreementGroupByOutputType = {
    id: string
    serviceId: string
    agreementId: string
    _count: ServiceAgreementCountAggregateOutputType | null
    _min: ServiceAgreementMinAggregateOutputType | null
    _max: ServiceAgreementMaxAggregateOutputType | null
  }

  type GetServiceAgreementGroupByPayload<T extends ServiceAgreementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceAgreementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceAgreementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceAgreementGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceAgreementGroupByOutputType[P]>
        }
      >
    >


  export type ServiceAgreementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    agreementId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAgreement"]>

  export type ServiceAgreementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    agreementId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAgreement"]>

  export type ServiceAgreementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    agreementId?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAgreement"]>

  export type ServiceAgreementSelectScalar = {
    id?: boolean
    serviceId?: boolean
    agreementId?: boolean
  }

  export type ServiceAgreementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceId" | "agreementId", ExtArgs["result"]["serviceAgreement"]>
  export type ServiceAgreementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
  }
  export type ServiceAgreementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
  }
  export type ServiceAgreementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
  }

  export type $ServiceAgreementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceAgreement"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
      agreement: Prisma.$AgreementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string
      agreementId: string
    }, ExtArgs["result"]["serviceAgreement"]>
    composites: {}
  }

  type ServiceAgreementGetPayload<S extends boolean | null | undefined | ServiceAgreementDefaultArgs> = $Result.GetResult<Prisma.$ServiceAgreementPayload, S>

  type ServiceAgreementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceAgreementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceAgreementCountAggregateInputType | true
    }

  export interface ServiceAgreementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceAgreement'], meta: { name: 'ServiceAgreement' } }
    /**
     * Find zero or one ServiceAgreement that matches the filter.
     * @param {ServiceAgreementFindUniqueArgs} args - Arguments to find a ServiceAgreement
     * @example
     * // Get one ServiceAgreement
     * const serviceAgreement = await prisma.serviceAgreement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceAgreementFindUniqueArgs>(args: SelectSubset<T, ServiceAgreementFindUniqueArgs<ExtArgs>>): Prisma__ServiceAgreementClient<$Result.GetResult<Prisma.$ServiceAgreementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceAgreement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceAgreementFindUniqueOrThrowArgs} args - Arguments to find a ServiceAgreement
     * @example
     * // Get one ServiceAgreement
     * const serviceAgreement = await prisma.serviceAgreement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceAgreementFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceAgreementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceAgreementClient<$Result.GetResult<Prisma.$ServiceAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceAgreement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAgreementFindFirstArgs} args - Arguments to find a ServiceAgreement
     * @example
     * // Get one ServiceAgreement
     * const serviceAgreement = await prisma.serviceAgreement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceAgreementFindFirstArgs>(args?: SelectSubset<T, ServiceAgreementFindFirstArgs<ExtArgs>>): Prisma__ServiceAgreementClient<$Result.GetResult<Prisma.$ServiceAgreementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceAgreement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAgreementFindFirstOrThrowArgs} args - Arguments to find a ServiceAgreement
     * @example
     * // Get one ServiceAgreement
     * const serviceAgreement = await prisma.serviceAgreement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceAgreementFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceAgreementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceAgreementClient<$Result.GetResult<Prisma.$ServiceAgreementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceAgreements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAgreementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceAgreements
     * const serviceAgreements = await prisma.serviceAgreement.findMany()
     * 
     * // Get first 10 ServiceAgreements
     * const serviceAgreements = await prisma.serviceAgreement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceAgreementWithIdOnly = await prisma.serviceAgreement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceAgreementFindManyArgs>(args?: SelectSubset<T, ServiceAgreementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceAgreement.
     * @param {ServiceAgreementCreateArgs} args - Arguments to create a ServiceAgreement.
     * @example
     * // Create one ServiceAgreement
     * const ServiceAgreement = await prisma.serviceAgreement.create({
     *   data: {
     *     // ... data to create a ServiceAgreement
     *   }
     * })
     * 
     */
    create<T extends ServiceAgreementCreateArgs>(args: SelectSubset<T, ServiceAgreementCreateArgs<ExtArgs>>): Prisma__ServiceAgreementClient<$Result.GetResult<Prisma.$ServiceAgreementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceAgreements.
     * @param {ServiceAgreementCreateManyArgs} args - Arguments to create many ServiceAgreements.
     * @example
     * // Create many ServiceAgreements
     * const serviceAgreement = await prisma.serviceAgreement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceAgreementCreateManyArgs>(args?: SelectSubset<T, ServiceAgreementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceAgreements and returns the data saved in the database.
     * @param {ServiceAgreementCreateManyAndReturnArgs} args - Arguments to create many ServiceAgreements.
     * @example
     * // Create many ServiceAgreements
     * const serviceAgreement = await prisma.serviceAgreement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceAgreements and only return the `id`
     * const serviceAgreementWithIdOnly = await prisma.serviceAgreement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceAgreementCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceAgreementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAgreementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceAgreement.
     * @param {ServiceAgreementDeleteArgs} args - Arguments to delete one ServiceAgreement.
     * @example
     * // Delete one ServiceAgreement
     * const ServiceAgreement = await prisma.serviceAgreement.delete({
     *   where: {
     *     // ... filter to delete one ServiceAgreement
     *   }
     * })
     * 
     */
    delete<T extends ServiceAgreementDeleteArgs>(args: SelectSubset<T, ServiceAgreementDeleteArgs<ExtArgs>>): Prisma__ServiceAgreementClient<$Result.GetResult<Prisma.$ServiceAgreementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceAgreement.
     * @param {ServiceAgreementUpdateArgs} args - Arguments to update one ServiceAgreement.
     * @example
     * // Update one ServiceAgreement
     * const serviceAgreement = await prisma.serviceAgreement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceAgreementUpdateArgs>(args: SelectSubset<T, ServiceAgreementUpdateArgs<ExtArgs>>): Prisma__ServiceAgreementClient<$Result.GetResult<Prisma.$ServiceAgreementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceAgreements.
     * @param {ServiceAgreementDeleteManyArgs} args - Arguments to filter ServiceAgreements to delete.
     * @example
     * // Delete a few ServiceAgreements
     * const { count } = await prisma.serviceAgreement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceAgreementDeleteManyArgs>(args?: SelectSubset<T, ServiceAgreementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAgreementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceAgreements
     * const serviceAgreement = await prisma.serviceAgreement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceAgreementUpdateManyArgs>(args: SelectSubset<T, ServiceAgreementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceAgreements and returns the data updated in the database.
     * @param {ServiceAgreementUpdateManyAndReturnArgs} args - Arguments to update many ServiceAgreements.
     * @example
     * // Update many ServiceAgreements
     * const serviceAgreement = await prisma.serviceAgreement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceAgreements and only return the `id`
     * const serviceAgreementWithIdOnly = await prisma.serviceAgreement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceAgreementUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceAgreementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAgreementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceAgreement.
     * @param {ServiceAgreementUpsertArgs} args - Arguments to update or create a ServiceAgreement.
     * @example
     * // Update or create a ServiceAgreement
     * const serviceAgreement = await prisma.serviceAgreement.upsert({
     *   create: {
     *     // ... data to create a ServiceAgreement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceAgreement we want to update
     *   }
     * })
     */
    upsert<T extends ServiceAgreementUpsertArgs>(args: SelectSubset<T, ServiceAgreementUpsertArgs<ExtArgs>>): Prisma__ServiceAgreementClient<$Result.GetResult<Prisma.$ServiceAgreementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAgreementCountArgs} args - Arguments to filter ServiceAgreements to count.
     * @example
     * // Count the number of ServiceAgreements
     * const count = await prisma.serviceAgreement.count({
     *   where: {
     *     // ... the filter for the ServiceAgreements we want to count
     *   }
     * })
    **/
    count<T extends ServiceAgreementCountArgs>(
      args?: Subset<T, ServiceAgreementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceAgreementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAgreementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAgreementAggregateArgs>(args: Subset<T, ServiceAgreementAggregateArgs>): Prisma.PrismaPromise<GetServiceAgreementAggregateType<T>>

    /**
     * Group by ServiceAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAgreementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceAgreementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceAgreementGroupByArgs['orderBy'] }
        : { orderBy?: ServiceAgreementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceAgreementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceAgreementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceAgreement model
   */
  readonly fields: ServiceAgreementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceAgreement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceAgreementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agreement<T extends AgreementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgreementDefaultArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceAgreement model
   */
  interface ServiceAgreementFieldRefs {
    readonly id: FieldRef<"ServiceAgreement", 'String'>
    readonly serviceId: FieldRef<"ServiceAgreement", 'String'>
    readonly agreementId: FieldRef<"ServiceAgreement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceAgreement findUnique
   */
  export type ServiceAgreementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAgreement
     */
    select?: ServiceAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAgreement
     */
    omit?: ServiceAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAgreementInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAgreement to fetch.
     */
    where: ServiceAgreementWhereUniqueInput
  }

  /**
   * ServiceAgreement findUniqueOrThrow
   */
  export type ServiceAgreementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAgreement
     */
    select?: ServiceAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAgreement
     */
    omit?: ServiceAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAgreementInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAgreement to fetch.
     */
    where: ServiceAgreementWhereUniqueInput
  }

  /**
   * ServiceAgreement findFirst
   */
  export type ServiceAgreementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAgreement
     */
    select?: ServiceAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAgreement
     */
    omit?: ServiceAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAgreementInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAgreement to fetch.
     */
    where?: ServiceAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAgreements to fetch.
     */
    orderBy?: ServiceAgreementOrderByWithRelationInput | ServiceAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAgreements.
     */
    cursor?: ServiceAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAgreements.
     */
    distinct?: ServiceAgreementScalarFieldEnum | ServiceAgreementScalarFieldEnum[]
  }

  /**
   * ServiceAgreement findFirstOrThrow
   */
  export type ServiceAgreementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAgreement
     */
    select?: ServiceAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAgreement
     */
    omit?: ServiceAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAgreementInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAgreement to fetch.
     */
    where?: ServiceAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAgreements to fetch.
     */
    orderBy?: ServiceAgreementOrderByWithRelationInput | ServiceAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAgreements.
     */
    cursor?: ServiceAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAgreements.
     */
    distinct?: ServiceAgreementScalarFieldEnum | ServiceAgreementScalarFieldEnum[]
  }

  /**
   * ServiceAgreement findMany
   */
  export type ServiceAgreementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAgreement
     */
    select?: ServiceAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAgreement
     */
    omit?: ServiceAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAgreementInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAgreements to fetch.
     */
    where?: ServiceAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAgreements to fetch.
     */
    orderBy?: ServiceAgreementOrderByWithRelationInput | ServiceAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceAgreements.
     */
    cursor?: ServiceAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAgreements.
     */
    skip?: number
    distinct?: ServiceAgreementScalarFieldEnum | ServiceAgreementScalarFieldEnum[]
  }

  /**
   * ServiceAgreement create
   */
  export type ServiceAgreementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAgreement
     */
    select?: ServiceAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAgreement
     */
    omit?: ServiceAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAgreementInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceAgreement.
     */
    data: XOR<ServiceAgreementCreateInput, ServiceAgreementUncheckedCreateInput>
  }

  /**
   * ServiceAgreement createMany
   */
  export type ServiceAgreementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceAgreements.
     */
    data: ServiceAgreementCreateManyInput | ServiceAgreementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceAgreement createManyAndReturn
   */
  export type ServiceAgreementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAgreement
     */
    select?: ServiceAgreementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAgreement
     */
    omit?: ServiceAgreementOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceAgreements.
     */
    data: ServiceAgreementCreateManyInput | ServiceAgreementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAgreementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceAgreement update
   */
  export type ServiceAgreementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAgreement
     */
    select?: ServiceAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAgreement
     */
    omit?: ServiceAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAgreementInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceAgreement.
     */
    data: XOR<ServiceAgreementUpdateInput, ServiceAgreementUncheckedUpdateInput>
    /**
     * Choose, which ServiceAgreement to update.
     */
    where: ServiceAgreementWhereUniqueInput
  }

  /**
   * ServiceAgreement updateMany
   */
  export type ServiceAgreementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceAgreements.
     */
    data: XOR<ServiceAgreementUpdateManyMutationInput, ServiceAgreementUncheckedUpdateManyInput>
    /**
     * Filter which ServiceAgreements to update
     */
    where?: ServiceAgreementWhereInput
    /**
     * Limit how many ServiceAgreements to update.
     */
    limit?: number
  }

  /**
   * ServiceAgreement updateManyAndReturn
   */
  export type ServiceAgreementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAgreement
     */
    select?: ServiceAgreementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAgreement
     */
    omit?: ServiceAgreementOmit<ExtArgs> | null
    /**
     * The data used to update ServiceAgreements.
     */
    data: XOR<ServiceAgreementUpdateManyMutationInput, ServiceAgreementUncheckedUpdateManyInput>
    /**
     * Filter which ServiceAgreements to update
     */
    where?: ServiceAgreementWhereInput
    /**
     * Limit how many ServiceAgreements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAgreementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceAgreement upsert
   */
  export type ServiceAgreementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAgreement
     */
    select?: ServiceAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAgreement
     */
    omit?: ServiceAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAgreementInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceAgreement to update in case it exists.
     */
    where: ServiceAgreementWhereUniqueInput
    /**
     * In case the ServiceAgreement found by the `where` argument doesn't exist, create a new ServiceAgreement with this data.
     */
    create: XOR<ServiceAgreementCreateInput, ServiceAgreementUncheckedCreateInput>
    /**
     * In case the ServiceAgreement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceAgreementUpdateInput, ServiceAgreementUncheckedUpdateInput>
  }

  /**
   * ServiceAgreement delete
   */
  export type ServiceAgreementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAgreement
     */
    select?: ServiceAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAgreement
     */
    omit?: ServiceAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAgreementInclude<ExtArgs> | null
    /**
     * Filter which ServiceAgreement to delete.
     */
    where: ServiceAgreementWhereUniqueInput
  }

  /**
   * ServiceAgreement deleteMany
   */
  export type ServiceAgreementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAgreements to delete
     */
    where?: ServiceAgreementWhereInput
    /**
     * Limit how many ServiceAgreements to delete.
     */
    limit?: number
  }

  /**
   * ServiceAgreement without action
   */
  export type ServiceAgreementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAgreement
     */
    select?: ServiceAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAgreement
     */
    omit?: ServiceAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAgreementInclude<ExtArgs> | null
  }


  /**
   * Model ComboPlanAgreement
   */

  export type AggregateComboPlanAgreement = {
    _count: ComboPlanAgreementCountAggregateOutputType | null
    _min: ComboPlanAgreementMinAggregateOutputType | null
    _max: ComboPlanAgreementMaxAggregateOutputType | null
  }

  export type ComboPlanAgreementMinAggregateOutputType = {
    id: string | null
    comboPlanId: string | null
    agreementId: string | null
  }

  export type ComboPlanAgreementMaxAggregateOutputType = {
    id: string | null
    comboPlanId: string | null
    agreementId: string | null
  }

  export type ComboPlanAgreementCountAggregateOutputType = {
    id: number
    comboPlanId: number
    agreementId: number
    _all: number
  }


  export type ComboPlanAgreementMinAggregateInputType = {
    id?: true
    comboPlanId?: true
    agreementId?: true
  }

  export type ComboPlanAgreementMaxAggregateInputType = {
    id?: true
    comboPlanId?: true
    agreementId?: true
  }

  export type ComboPlanAgreementCountAggregateInputType = {
    id?: true
    comboPlanId?: true
    agreementId?: true
    _all?: true
  }

  export type ComboPlanAgreementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComboPlanAgreement to aggregate.
     */
    where?: ComboPlanAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboPlanAgreements to fetch.
     */
    orderBy?: ComboPlanAgreementOrderByWithRelationInput | ComboPlanAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComboPlanAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboPlanAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboPlanAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComboPlanAgreements
    **/
    _count?: true | ComboPlanAgreementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComboPlanAgreementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComboPlanAgreementMaxAggregateInputType
  }

  export type GetComboPlanAgreementAggregateType<T extends ComboPlanAgreementAggregateArgs> = {
        [P in keyof T & keyof AggregateComboPlanAgreement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComboPlanAgreement[P]>
      : GetScalarType<T[P], AggregateComboPlanAgreement[P]>
  }




  export type ComboPlanAgreementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComboPlanAgreementWhereInput
    orderBy?: ComboPlanAgreementOrderByWithAggregationInput | ComboPlanAgreementOrderByWithAggregationInput[]
    by: ComboPlanAgreementScalarFieldEnum[] | ComboPlanAgreementScalarFieldEnum
    having?: ComboPlanAgreementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComboPlanAgreementCountAggregateInputType | true
    _min?: ComboPlanAgreementMinAggregateInputType
    _max?: ComboPlanAgreementMaxAggregateInputType
  }

  export type ComboPlanAgreementGroupByOutputType = {
    id: string
    comboPlanId: string
    agreementId: string
    _count: ComboPlanAgreementCountAggregateOutputType | null
    _min: ComboPlanAgreementMinAggregateOutputType | null
    _max: ComboPlanAgreementMaxAggregateOutputType | null
  }

  type GetComboPlanAgreementGroupByPayload<T extends ComboPlanAgreementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComboPlanAgreementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComboPlanAgreementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComboPlanAgreementGroupByOutputType[P]>
            : GetScalarType<T[P], ComboPlanAgreementGroupByOutputType[P]>
        }
      >
    >


  export type ComboPlanAgreementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comboPlanId?: boolean
    agreementId?: boolean
    comboPlan?: boolean | ComboPlanDefaultArgs<ExtArgs>
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comboPlanAgreement"]>

  export type ComboPlanAgreementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comboPlanId?: boolean
    agreementId?: boolean
    comboPlan?: boolean | ComboPlanDefaultArgs<ExtArgs>
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comboPlanAgreement"]>

  export type ComboPlanAgreementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comboPlanId?: boolean
    agreementId?: boolean
    comboPlan?: boolean | ComboPlanDefaultArgs<ExtArgs>
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comboPlanAgreement"]>

  export type ComboPlanAgreementSelectScalar = {
    id?: boolean
    comboPlanId?: boolean
    agreementId?: boolean
  }

  export type ComboPlanAgreementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "comboPlanId" | "agreementId", ExtArgs["result"]["comboPlanAgreement"]>
  export type ComboPlanAgreementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comboPlan?: boolean | ComboPlanDefaultArgs<ExtArgs>
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
  }
  export type ComboPlanAgreementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comboPlan?: boolean | ComboPlanDefaultArgs<ExtArgs>
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
  }
  export type ComboPlanAgreementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comboPlan?: boolean | ComboPlanDefaultArgs<ExtArgs>
    agreement?: boolean | AgreementDefaultArgs<ExtArgs>
  }

  export type $ComboPlanAgreementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComboPlanAgreement"
    objects: {
      comboPlan: Prisma.$ComboPlanPayload<ExtArgs>
      agreement: Prisma.$AgreementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      comboPlanId: string
      agreementId: string
    }, ExtArgs["result"]["comboPlanAgreement"]>
    composites: {}
  }

  type ComboPlanAgreementGetPayload<S extends boolean | null | undefined | ComboPlanAgreementDefaultArgs> = $Result.GetResult<Prisma.$ComboPlanAgreementPayload, S>

  type ComboPlanAgreementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComboPlanAgreementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComboPlanAgreementCountAggregateInputType | true
    }

  export interface ComboPlanAgreementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComboPlanAgreement'], meta: { name: 'ComboPlanAgreement' } }
    /**
     * Find zero or one ComboPlanAgreement that matches the filter.
     * @param {ComboPlanAgreementFindUniqueArgs} args - Arguments to find a ComboPlanAgreement
     * @example
     * // Get one ComboPlanAgreement
     * const comboPlanAgreement = await prisma.comboPlanAgreement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComboPlanAgreementFindUniqueArgs>(args: SelectSubset<T, ComboPlanAgreementFindUniqueArgs<ExtArgs>>): Prisma__ComboPlanAgreementClient<$Result.GetResult<Prisma.$ComboPlanAgreementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComboPlanAgreement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComboPlanAgreementFindUniqueOrThrowArgs} args - Arguments to find a ComboPlanAgreement
     * @example
     * // Get one ComboPlanAgreement
     * const comboPlanAgreement = await prisma.comboPlanAgreement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComboPlanAgreementFindUniqueOrThrowArgs>(args: SelectSubset<T, ComboPlanAgreementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComboPlanAgreementClient<$Result.GetResult<Prisma.$ComboPlanAgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComboPlanAgreement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanAgreementFindFirstArgs} args - Arguments to find a ComboPlanAgreement
     * @example
     * // Get one ComboPlanAgreement
     * const comboPlanAgreement = await prisma.comboPlanAgreement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComboPlanAgreementFindFirstArgs>(args?: SelectSubset<T, ComboPlanAgreementFindFirstArgs<ExtArgs>>): Prisma__ComboPlanAgreementClient<$Result.GetResult<Prisma.$ComboPlanAgreementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComboPlanAgreement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanAgreementFindFirstOrThrowArgs} args - Arguments to find a ComboPlanAgreement
     * @example
     * // Get one ComboPlanAgreement
     * const comboPlanAgreement = await prisma.comboPlanAgreement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComboPlanAgreementFindFirstOrThrowArgs>(args?: SelectSubset<T, ComboPlanAgreementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComboPlanAgreementClient<$Result.GetResult<Prisma.$ComboPlanAgreementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComboPlanAgreements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanAgreementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComboPlanAgreements
     * const comboPlanAgreements = await prisma.comboPlanAgreement.findMany()
     * 
     * // Get first 10 ComboPlanAgreements
     * const comboPlanAgreements = await prisma.comboPlanAgreement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comboPlanAgreementWithIdOnly = await prisma.comboPlanAgreement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComboPlanAgreementFindManyArgs>(args?: SelectSubset<T, ComboPlanAgreementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPlanAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComboPlanAgreement.
     * @param {ComboPlanAgreementCreateArgs} args - Arguments to create a ComboPlanAgreement.
     * @example
     * // Create one ComboPlanAgreement
     * const ComboPlanAgreement = await prisma.comboPlanAgreement.create({
     *   data: {
     *     // ... data to create a ComboPlanAgreement
     *   }
     * })
     * 
     */
    create<T extends ComboPlanAgreementCreateArgs>(args: SelectSubset<T, ComboPlanAgreementCreateArgs<ExtArgs>>): Prisma__ComboPlanAgreementClient<$Result.GetResult<Prisma.$ComboPlanAgreementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComboPlanAgreements.
     * @param {ComboPlanAgreementCreateManyArgs} args - Arguments to create many ComboPlanAgreements.
     * @example
     * // Create many ComboPlanAgreements
     * const comboPlanAgreement = await prisma.comboPlanAgreement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComboPlanAgreementCreateManyArgs>(args?: SelectSubset<T, ComboPlanAgreementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComboPlanAgreements and returns the data saved in the database.
     * @param {ComboPlanAgreementCreateManyAndReturnArgs} args - Arguments to create many ComboPlanAgreements.
     * @example
     * // Create many ComboPlanAgreements
     * const comboPlanAgreement = await prisma.comboPlanAgreement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComboPlanAgreements and only return the `id`
     * const comboPlanAgreementWithIdOnly = await prisma.comboPlanAgreement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComboPlanAgreementCreateManyAndReturnArgs>(args?: SelectSubset<T, ComboPlanAgreementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPlanAgreementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComboPlanAgreement.
     * @param {ComboPlanAgreementDeleteArgs} args - Arguments to delete one ComboPlanAgreement.
     * @example
     * // Delete one ComboPlanAgreement
     * const ComboPlanAgreement = await prisma.comboPlanAgreement.delete({
     *   where: {
     *     // ... filter to delete one ComboPlanAgreement
     *   }
     * })
     * 
     */
    delete<T extends ComboPlanAgreementDeleteArgs>(args: SelectSubset<T, ComboPlanAgreementDeleteArgs<ExtArgs>>): Prisma__ComboPlanAgreementClient<$Result.GetResult<Prisma.$ComboPlanAgreementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComboPlanAgreement.
     * @param {ComboPlanAgreementUpdateArgs} args - Arguments to update one ComboPlanAgreement.
     * @example
     * // Update one ComboPlanAgreement
     * const comboPlanAgreement = await prisma.comboPlanAgreement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComboPlanAgreementUpdateArgs>(args: SelectSubset<T, ComboPlanAgreementUpdateArgs<ExtArgs>>): Prisma__ComboPlanAgreementClient<$Result.GetResult<Prisma.$ComboPlanAgreementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComboPlanAgreements.
     * @param {ComboPlanAgreementDeleteManyArgs} args - Arguments to filter ComboPlanAgreements to delete.
     * @example
     * // Delete a few ComboPlanAgreements
     * const { count } = await prisma.comboPlanAgreement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComboPlanAgreementDeleteManyArgs>(args?: SelectSubset<T, ComboPlanAgreementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComboPlanAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanAgreementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComboPlanAgreements
     * const comboPlanAgreement = await prisma.comboPlanAgreement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComboPlanAgreementUpdateManyArgs>(args: SelectSubset<T, ComboPlanAgreementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComboPlanAgreements and returns the data updated in the database.
     * @param {ComboPlanAgreementUpdateManyAndReturnArgs} args - Arguments to update many ComboPlanAgreements.
     * @example
     * // Update many ComboPlanAgreements
     * const comboPlanAgreement = await prisma.comboPlanAgreement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComboPlanAgreements and only return the `id`
     * const comboPlanAgreementWithIdOnly = await prisma.comboPlanAgreement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComboPlanAgreementUpdateManyAndReturnArgs>(args: SelectSubset<T, ComboPlanAgreementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPlanAgreementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComboPlanAgreement.
     * @param {ComboPlanAgreementUpsertArgs} args - Arguments to update or create a ComboPlanAgreement.
     * @example
     * // Update or create a ComboPlanAgreement
     * const comboPlanAgreement = await prisma.comboPlanAgreement.upsert({
     *   create: {
     *     // ... data to create a ComboPlanAgreement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComboPlanAgreement we want to update
     *   }
     * })
     */
    upsert<T extends ComboPlanAgreementUpsertArgs>(args: SelectSubset<T, ComboPlanAgreementUpsertArgs<ExtArgs>>): Prisma__ComboPlanAgreementClient<$Result.GetResult<Prisma.$ComboPlanAgreementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComboPlanAgreements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanAgreementCountArgs} args - Arguments to filter ComboPlanAgreements to count.
     * @example
     * // Count the number of ComboPlanAgreements
     * const count = await prisma.comboPlanAgreement.count({
     *   where: {
     *     // ... the filter for the ComboPlanAgreements we want to count
     *   }
     * })
    **/
    count<T extends ComboPlanAgreementCountArgs>(
      args?: Subset<T, ComboPlanAgreementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComboPlanAgreementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComboPlanAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanAgreementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComboPlanAgreementAggregateArgs>(args: Subset<T, ComboPlanAgreementAggregateArgs>): Prisma.PrismaPromise<GetComboPlanAgreementAggregateType<T>>

    /**
     * Group by ComboPlanAgreement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanAgreementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComboPlanAgreementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComboPlanAgreementGroupByArgs['orderBy'] }
        : { orderBy?: ComboPlanAgreementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComboPlanAgreementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComboPlanAgreementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComboPlanAgreement model
   */
  readonly fields: ComboPlanAgreementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComboPlanAgreement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComboPlanAgreementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comboPlan<T extends ComboPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComboPlanDefaultArgs<ExtArgs>>): Prisma__ComboPlanClient<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agreement<T extends AgreementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgreementDefaultArgs<ExtArgs>>): Prisma__AgreementClient<$Result.GetResult<Prisma.$AgreementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComboPlanAgreement model
   */
  interface ComboPlanAgreementFieldRefs {
    readonly id: FieldRef<"ComboPlanAgreement", 'String'>
    readonly comboPlanId: FieldRef<"ComboPlanAgreement", 'String'>
    readonly agreementId: FieldRef<"ComboPlanAgreement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ComboPlanAgreement findUnique
   */
  export type ComboPlanAgreementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanAgreement
     */
    select?: ComboPlanAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanAgreement
     */
    omit?: ComboPlanAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanAgreementInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlanAgreement to fetch.
     */
    where: ComboPlanAgreementWhereUniqueInput
  }

  /**
   * ComboPlanAgreement findUniqueOrThrow
   */
  export type ComboPlanAgreementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanAgreement
     */
    select?: ComboPlanAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanAgreement
     */
    omit?: ComboPlanAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanAgreementInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlanAgreement to fetch.
     */
    where: ComboPlanAgreementWhereUniqueInput
  }

  /**
   * ComboPlanAgreement findFirst
   */
  export type ComboPlanAgreementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanAgreement
     */
    select?: ComboPlanAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanAgreement
     */
    omit?: ComboPlanAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanAgreementInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlanAgreement to fetch.
     */
    where?: ComboPlanAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboPlanAgreements to fetch.
     */
    orderBy?: ComboPlanAgreementOrderByWithRelationInput | ComboPlanAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComboPlanAgreements.
     */
    cursor?: ComboPlanAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboPlanAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboPlanAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComboPlanAgreements.
     */
    distinct?: ComboPlanAgreementScalarFieldEnum | ComboPlanAgreementScalarFieldEnum[]
  }

  /**
   * ComboPlanAgreement findFirstOrThrow
   */
  export type ComboPlanAgreementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanAgreement
     */
    select?: ComboPlanAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanAgreement
     */
    omit?: ComboPlanAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanAgreementInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlanAgreement to fetch.
     */
    where?: ComboPlanAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboPlanAgreements to fetch.
     */
    orderBy?: ComboPlanAgreementOrderByWithRelationInput | ComboPlanAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComboPlanAgreements.
     */
    cursor?: ComboPlanAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboPlanAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboPlanAgreements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComboPlanAgreements.
     */
    distinct?: ComboPlanAgreementScalarFieldEnum | ComboPlanAgreementScalarFieldEnum[]
  }

  /**
   * ComboPlanAgreement findMany
   */
  export type ComboPlanAgreementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanAgreement
     */
    select?: ComboPlanAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanAgreement
     */
    omit?: ComboPlanAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanAgreementInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlanAgreements to fetch.
     */
    where?: ComboPlanAgreementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboPlanAgreements to fetch.
     */
    orderBy?: ComboPlanAgreementOrderByWithRelationInput | ComboPlanAgreementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComboPlanAgreements.
     */
    cursor?: ComboPlanAgreementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboPlanAgreements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboPlanAgreements.
     */
    skip?: number
    distinct?: ComboPlanAgreementScalarFieldEnum | ComboPlanAgreementScalarFieldEnum[]
  }

  /**
   * ComboPlanAgreement create
   */
  export type ComboPlanAgreementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanAgreement
     */
    select?: ComboPlanAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanAgreement
     */
    omit?: ComboPlanAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanAgreementInclude<ExtArgs> | null
    /**
     * The data needed to create a ComboPlanAgreement.
     */
    data: XOR<ComboPlanAgreementCreateInput, ComboPlanAgreementUncheckedCreateInput>
  }

  /**
   * ComboPlanAgreement createMany
   */
  export type ComboPlanAgreementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComboPlanAgreements.
     */
    data: ComboPlanAgreementCreateManyInput | ComboPlanAgreementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComboPlanAgreement createManyAndReturn
   */
  export type ComboPlanAgreementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanAgreement
     */
    select?: ComboPlanAgreementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanAgreement
     */
    omit?: ComboPlanAgreementOmit<ExtArgs> | null
    /**
     * The data used to create many ComboPlanAgreements.
     */
    data: ComboPlanAgreementCreateManyInput | ComboPlanAgreementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanAgreementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComboPlanAgreement update
   */
  export type ComboPlanAgreementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanAgreement
     */
    select?: ComboPlanAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanAgreement
     */
    omit?: ComboPlanAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanAgreementInclude<ExtArgs> | null
    /**
     * The data needed to update a ComboPlanAgreement.
     */
    data: XOR<ComboPlanAgreementUpdateInput, ComboPlanAgreementUncheckedUpdateInput>
    /**
     * Choose, which ComboPlanAgreement to update.
     */
    where: ComboPlanAgreementWhereUniqueInput
  }

  /**
   * ComboPlanAgreement updateMany
   */
  export type ComboPlanAgreementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComboPlanAgreements.
     */
    data: XOR<ComboPlanAgreementUpdateManyMutationInput, ComboPlanAgreementUncheckedUpdateManyInput>
    /**
     * Filter which ComboPlanAgreements to update
     */
    where?: ComboPlanAgreementWhereInput
    /**
     * Limit how many ComboPlanAgreements to update.
     */
    limit?: number
  }

  /**
   * ComboPlanAgreement updateManyAndReturn
   */
  export type ComboPlanAgreementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanAgreement
     */
    select?: ComboPlanAgreementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanAgreement
     */
    omit?: ComboPlanAgreementOmit<ExtArgs> | null
    /**
     * The data used to update ComboPlanAgreements.
     */
    data: XOR<ComboPlanAgreementUpdateManyMutationInput, ComboPlanAgreementUncheckedUpdateManyInput>
    /**
     * Filter which ComboPlanAgreements to update
     */
    where?: ComboPlanAgreementWhereInput
    /**
     * Limit how many ComboPlanAgreements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanAgreementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComboPlanAgreement upsert
   */
  export type ComboPlanAgreementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanAgreement
     */
    select?: ComboPlanAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanAgreement
     */
    omit?: ComboPlanAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanAgreementInclude<ExtArgs> | null
    /**
     * The filter to search for the ComboPlanAgreement to update in case it exists.
     */
    where: ComboPlanAgreementWhereUniqueInput
    /**
     * In case the ComboPlanAgreement found by the `where` argument doesn't exist, create a new ComboPlanAgreement with this data.
     */
    create: XOR<ComboPlanAgreementCreateInput, ComboPlanAgreementUncheckedCreateInput>
    /**
     * In case the ComboPlanAgreement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComboPlanAgreementUpdateInput, ComboPlanAgreementUncheckedUpdateInput>
  }

  /**
   * ComboPlanAgreement delete
   */
  export type ComboPlanAgreementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanAgreement
     */
    select?: ComboPlanAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanAgreement
     */
    omit?: ComboPlanAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanAgreementInclude<ExtArgs> | null
    /**
     * Filter which ComboPlanAgreement to delete.
     */
    where: ComboPlanAgreementWhereUniqueInput
  }

  /**
   * ComboPlanAgreement deleteMany
   */
  export type ComboPlanAgreementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComboPlanAgreements to delete
     */
    where?: ComboPlanAgreementWhereInput
    /**
     * Limit how many ComboPlanAgreements to delete.
     */
    limit?: number
  }

  /**
   * ComboPlanAgreement without action
   */
  export type ComboPlanAgreementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanAgreement
     */
    select?: ComboPlanAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanAgreement
     */
    omit?: ComboPlanAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanAgreementInclude<ExtArgs> | null
  }


  /**
   * Model ComboPlan
   */

  export type AggregateComboPlan = {
    _count: ComboPlanCountAggregateOutputType | null
    _avg: ComboPlanAvgAggregateOutputType | null
    _sum: ComboPlanSumAggregateOutputType | null
    _min: ComboPlanMinAggregateOutputType | null
    _max: ComboPlanMaxAggregateOutputType | null
  }

  export type ComboPlanAvgAggregateOutputType = {
    price: number | null
    taxPercent: number | null
  }

  export type ComboPlanSumAggregateOutputType = {
    price: number | null
    taxPercent: number | null
  }

  export type ComboPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    taxPercent: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComboPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    taxPercent: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComboPlanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    taxPercent: number
    active: number
    tenureDiscounts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComboPlanAvgAggregateInputType = {
    price?: true
    taxPercent?: true
  }

  export type ComboPlanSumAggregateInputType = {
    price?: true
    taxPercent?: true
  }

  export type ComboPlanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    taxPercent?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComboPlanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    taxPercent?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComboPlanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    taxPercent?: true
    active?: true
    tenureDiscounts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComboPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComboPlan to aggregate.
     */
    where?: ComboPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboPlans to fetch.
     */
    orderBy?: ComboPlanOrderByWithRelationInput | ComboPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComboPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComboPlans
    **/
    _count?: true | ComboPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComboPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComboPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComboPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComboPlanMaxAggregateInputType
  }

  export type GetComboPlanAggregateType<T extends ComboPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateComboPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComboPlan[P]>
      : GetScalarType<T[P], AggregateComboPlan[P]>
  }




  export type ComboPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComboPlanWhereInput
    orderBy?: ComboPlanOrderByWithAggregationInput | ComboPlanOrderByWithAggregationInput[]
    by: ComboPlanScalarFieldEnum[] | ComboPlanScalarFieldEnum
    having?: ComboPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComboPlanCountAggregateInputType | true
    _avg?: ComboPlanAvgAggregateInputType
    _sum?: ComboPlanSumAggregateInputType
    _min?: ComboPlanMinAggregateInputType
    _max?: ComboPlanMaxAggregateInputType
  }

  export type ComboPlanGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: number
    taxPercent: number | null
    active: boolean | null
    tenureDiscounts: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ComboPlanCountAggregateOutputType | null
    _avg: ComboPlanAvgAggregateOutputType | null
    _sum: ComboPlanSumAggregateOutputType | null
    _min: ComboPlanMinAggregateOutputType | null
    _max: ComboPlanMaxAggregateOutputType | null
  }

  type GetComboPlanGroupByPayload<T extends ComboPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComboPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComboPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComboPlanGroupByOutputType[P]>
            : GetScalarType<T[P], ComboPlanGroupByOutputType[P]>
        }
      >
    >


  export type ComboPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    taxPercent?: boolean
    active?: boolean
    tenureDiscounts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agreement?: boolean | ComboPlan$agreementArgs<ExtArgs>
    services?: boolean | ComboPlan$servicesArgs<ExtArgs>
    coupon?: boolean | ComboPlan$couponArgs<ExtArgs>
    Transaction?: boolean | ComboPlan$TransactionArgs<ExtArgs>
    _count?: boolean | ComboPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comboPlan"]>

  export type ComboPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    taxPercent?: boolean
    active?: boolean
    tenureDiscounts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["comboPlan"]>

  export type ComboPlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    taxPercent?: boolean
    active?: boolean
    tenureDiscounts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["comboPlan"]>

  export type ComboPlanSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    taxPercent?: boolean
    active?: boolean
    tenureDiscounts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComboPlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "taxPercent" | "active" | "tenureDiscounts" | "createdAt" | "updatedAt", ExtArgs["result"]["comboPlan"]>
  export type ComboPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agreement?: boolean | ComboPlan$agreementArgs<ExtArgs>
    services?: boolean | ComboPlan$servicesArgs<ExtArgs>
    coupon?: boolean | ComboPlan$couponArgs<ExtArgs>
    Transaction?: boolean | ComboPlan$TransactionArgs<ExtArgs>
    _count?: boolean | ComboPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ComboPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ComboPlanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ComboPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComboPlan"
    objects: {
      agreement: Prisma.$ComboPlanAgreementPayload<ExtArgs>[]
      services: Prisma.$ComboPlanServicePayload<ExtArgs>[]
      coupon: Prisma.$CouponPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: number
      taxPercent: number | null
      active: boolean | null
      tenureDiscounts: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comboPlan"]>
    composites: {}
  }

  type ComboPlanGetPayload<S extends boolean | null | undefined | ComboPlanDefaultArgs> = $Result.GetResult<Prisma.$ComboPlanPayload, S>

  type ComboPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComboPlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComboPlanCountAggregateInputType | true
    }

  export interface ComboPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComboPlan'], meta: { name: 'ComboPlan' } }
    /**
     * Find zero or one ComboPlan that matches the filter.
     * @param {ComboPlanFindUniqueArgs} args - Arguments to find a ComboPlan
     * @example
     * // Get one ComboPlan
     * const comboPlan = await prisma.comboPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComboPlanFindUniqueArgs>(args: SelectSubset<T, ComboPlanFindUniqueArgs<ExtArgs>>): Prisma__ComboPlanClient<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComboPlan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComboPlanFindUniqueOrThrowArgs} args - Arguments to find a ComboPlan
     * @example
     * // Get one ComboPlan
     * const comboPlan = await prisma.comboPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComboPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, ComboPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComboPlanClient<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComboPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanFindFirstArgs} args - Arguments to find a ComboPlan
     * @example
     * // Get one ComboPlan
     * const comboPlan = await prisma.comboPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComboPlanFindFirstArgs>(args?: SelectSubset<T, ComboPlanFindFirstArgs<ExtArgs>>): Prisma__ComboPlanClient<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComboPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanFindFirstOrThrowArgs} args - Arguments to find a ComboPlan
     * @example
     * // Get one ComboPlan
     * const comboPlan = await prisma.comboPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComboPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, ComboPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComboPlanClient<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComboPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComboPlans
     * const comboPlans = await prisma.comboPlan.findMany()
     * 
     * // Get first 10 ComboPlans
     * const comboPlans = await prisma.comboPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comboPlanWithIdOnly = await prisma.comboPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComboPlanFindManyArgs>(args?: SelectSubset<T, ComboPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComboPlan.
     * @param {ComboPlanCreateArgs} args - Arguments to create a ComboPlan.
     * @example
     * // Create one ComboPlan
     * const ComboPlan = await prisma.comboPlan.create({
     *   data: {
     *     // ... data to create a ComboPlan
     *   }
     * })
     * 
     */
    create<T extends ComboPlanCreateArgs>(args: SelectSubset<T, ComboPlanCreateArgs<ExtArgs>>): Prisma__ComboPlanClient<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComboPlans.
     * @param {ComboPlanCreateManyArgs} args - Arguments to create many ComboPlans.
     * @example
     * // Create many ComboPlans
     * const comboPlan = await prisma.comboPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComboPlanCreateManyArgs>(args?: SelectSubset<T, ComboPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComboPlans and returns the data saved in the database.
     * @param {ComboPlanCreateManyAndReturnArgs} args - Arguments to create many ComboPlans.
     * @example
     * // Create many ComboPlans
     * const comboPlan = await prisma.comboPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComboPlans and only return the `id`
     * const comboPlanWithIdOnly = await prisma.comboPlan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComboPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, ComboPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComboPlan.
     * @param {ComboPlanDeleteArgs} args - Arguments to delete one ComboPlan.
     * @example
     * // Delete one ComboPlan
     * const ComboPlan = await prisma.comboPlan.delete({
     *   where: {
     *     // ... filter to delete one ComboPlan
     *   }
     * })
     * 
     */
    delete<T extends ComboPlanDeleteArgs>(args: SelectSubset<T, ComboPlanDeleteArgs<ExtArgs>>): Prisma__ComboPlanClient<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComboPlan.
     * @param {ComboPlanUpdateArgs} args - Arguments to update one ComboPlan.
     * @example
     * // Update one ComboPlan
     * const comboPlan = await prisma.comboPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComboPlanUpdateArgs>(args: SelectSubset<T, ComboPlanUpdateArgs<ExtArgs>>): Prisma__ComboPlanClient<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComboPlans.
     * @param {ComboPlanDeleteManyArgs} args - Arguments to filter ComboPlans to delete.
     * @example
     * // Delete a few ComboPlans
     * const { count } = await prisma.comboPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComboPlanDeleteManyArgs>(args?: SelectSubset<T, ComboPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComboPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComboPlans
     * const comboPlan = await prisma.comboPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComboPlanUpdateManyArgs>(args: SelectSubset<T, ComboPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComboPlans and returns the data updated in the database.
     * @param {ComboPlanUpdateManyAndReturnArgs} args - Arguments to update many ComboPlans.
     * @example
     * // Update many ComboPlans
     * const comboPlan = await prisma.comboPlan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComboPlans and only return the `id`
     * const comboPlanWithIdOnly = await prisma.comboPlan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComboPlanUpdateManyAndReturnArgs>(args: SelectSubset<T, ComboPlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComboPlan.
     * @param {ComboPlanUpsertArgs} args - Arguments to update or create a ComboPlan.
     * @example
     * // Update or create a ComboPlan
     * const comboPlan = await prisma.comboPlan.upsert({
     *   create: {
     *     // ... data to create a ComboPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComboPlan we want to update
     *   }
     * })
     */
    upsert<T extends ComboPlanUpsertArgs>(args: SelectSubset<T, ComboPlanUpsertArgs<ExtArgs>>): Prisma__ComboPlanClient<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComboPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanCountArgs} args - Arguments to filter ComboPlans to count.
     * @example
     * // Count the number of ComboPlans
     * const count = await prisma.comboPlan.count({
     *   where: {
     *     // ... the filter for the ComboPlans we want to count
     *   }
     * })
    **/
    count<T extends ComboPlanCountArgs>(
      args?: Subset<T, ComboPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComboPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComboPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComboPlanAggregateArgs>(args: Subset<T, ComboPlanAggregateArgs>): Prisma.PrismaPromise<GetComboPlanAggregateType<T>>

    /**
     * Group by ComboPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComboPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComboPlanGroupByArgs['orderBy'] }
        : { orderBy?: ComboPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComboPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComboPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComboPlan model
   */
  readonly fields: ComboPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComboPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComboPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agreement<T extends ComboPlan$agreementArgs<ExtArgs> = {}>(args?: Subset<T, ComboPlan$agreementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPlanAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends ComboPlan$servicesArgs<ExtArgs> = {}>(args?: Subset<T, ComboPlan$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPlanServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coupon<T extends ComboPlan$couponArgs<ExtArgs> = {}>(args?: Subset<T, ComboPlan$couponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends ComboPlan$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, ComboPlan$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComboPlan model
   */
  interface ComboPlanFieldRefs {
    readonly id: FieldRef<"ComboPlan", 'String'>
    readonly name: FieldRef<"ComboPlan", 'String'>
    readonly description: FieldRef<"ComboPlan", 'String'>
    readonly price: FieldRef<"ComboPlan", 'Float'>
    readonly taxPercent: FieldRef<"ComboPlan", 'Float'>
    readonly active: FieldRef<"ComboPlan", 'Boolean'>
    readonly tenureDiscounts: FieldRef<"ComboPlan", 'Json'>
    readonly createdAt: FieldRef<"ComboPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"ComboPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComboPlan findUnique
   */
  export type ComboPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlan
     */
    select?: ComboPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlan
     */
    omit?: ComboPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlan to fetch.
     */
    where: ComboPlanWhereUniqueInput
  }

  /**
   * ComboPlan findUniqueOrThrow
   */
  export type ComboPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlan
     */
    select?: ComboPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlan
     */
    omit?: ComboPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlan to fetch.
     */
    where: ComboPlanWhereUniqueInput
  }

  /**
   * ComboPlan findFirst
   */
  export type ComboPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlan
     */
    select?: ComboPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlan
     */
    omit?: ComboPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlan to fetch.
     */
    where?: ComboPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboPlans to fetch.
     */
    orderBy?: ComboPlanOrderByWithRelationInput | ComboPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComboPlans.
     */
    cursor?: ComboPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComboPlans.
     */
    distinct?: ComboPlanScalarFieldEnum | ComboPlanScalarFieldEnum[]
  }

  /**
   * ComboPlan findFirstOrThrow
   */
  export type ComboPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlan
     */
    select?: ComboPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlan
     */
    omit?: ComboPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlan to fetch.
     */
    where?: ComboPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboPlans to fetch.
     */
    orderBy?: ComboPlanOrderByWithRelationInput | ComboPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComboPlans.
     */
    cursor?: ComboPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComboPlans.
     */
    distinct?: ComboPlanScalarFieldEnum | ComboPlanScalarFieldEnum[]
  }

  /**
   * ComboPlan findMany
   */
  export type ComboPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlan
     */
    select?: ComboPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlan
     */
    omit?: ComboPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlans to fetch.
     */
    where?: ComboPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboPlans to fetch.
     */
    orderBy?: ComboPlanOrderByWithRelationInput | ComboPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComboPlans.
     */
    cursor?: ComboPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboPlans.
     */
    skip?: number
    distinct?: ComboPlanScalarFieldEnum | ComboPlanScalarFieldEnum[]
  }

  /**
   * ComboPlan create
   */
  export type ComboPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlan
     */
    select?: ComboPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlan
     */
    omit?: ComboPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a ComboPlan.
     */
    data: XOR<ComboPlanCreateInput, ComboPlanUncheckedCreateInput>
  }

  /**
   * ComboPlan createMany
   */
  export type ComboPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComboPlans.
     */
    data: ComboPlanCreateManyInput | ComboPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComboPlan createManyAndReturn
   */
  export type ComboPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlan
     */
    select?: ComboPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlan
     */
    omit?: ComboPlanOmit<ExtArgs> | null
    /**
     * The data used to create many ComboPlans.
     */
    data: ComboPlanCreateManyInput | ComboPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComboPlan update
   */
  export type ComboPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlan
     */
    select?: ComboPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlan
     */
    omit?: ComboPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a ComboPlan.
     */
    data: XOR<ComboPlanUpdateInput, ComboPlanUncheckedUpdateInput>
    /**
     * Choose, which ComboPlan to update.
     */
    where: ComboPlanWhereUniqueInput
  }

  /**
   * ComboPlan updateMany
   */
  export type ComboPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComboPlans.
     */
    data: XOR<ComboPlanUpdateManyMutationInput, ComboPlanUncheckedUpdateManyInput>
    /**
     * Filter which ComboPlans to update
     */
    where?: ComboPlanWhereInput
    /**
     * Limit how many ComboPlans to update.
     */
    limit?: number
  }

  /**
   * ComboPlan updateManyAndReturn
   */
  export type ComboPlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlan
     */
    select?: ComboPlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlan
     */
    omit?: ComboPlanOmit<ExtArgs> | null
    /**
     * The data used to update ComboPlans.
     */
    data: XOR<ComboPlanUpdateManyMutationInput, ComboPlanUncheckedUpdateManyInput>
    /**
     * Filter which ComboPlans to update
     */
    where?: ComboPlanWhereInput
    /**
     * Limit how many ComboPlans to update.
     */
    limit?: number
  }

  /**
   * ComboPlan upsert
   */
  export type ComboPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlan
     */
    select?: ComboPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlan
     */
    omit?: ComboPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the ComboPlan to update in case it exists.
     */
    where: ComboPlanWhereUniqueInput
    /**
     * In case the ComboPlan found by the `where` argument doesn't exist, create a new ComboPlan with this data.
     */
    create: XOR<ComboPlanCreateInput, ComboPlanUncheckedCreateInput>
    /**
     * In case the ComboPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComboPlanUpdateInput, ComboPlanUncheckedUpdateInput>
  }

  /**
   * ComboPlan delete
   */
  export type ComboPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlan
     */
    select?: ComboPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlan
     */
    omit?: ComboPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanInclude<ExtArgs> | null
    /**
     * Filter which ComboPlan to delete.
     */
    where: ComboPlanWhereUniqueInput
  }

  /**
   * ComboPlan deleteMany
   */
  export type ComboPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComboPlans to delete
     */
    where?: ComboPlanWhereInput
    /**
     * Limit how many ComboPlans to delete.
     */
    limit?: number
  }

  /**
   * ComboPlan.agreement
   */
  export type ComboPlan$agreementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanAgreement
     */
    select?: ComboPlanAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanAgreement
     */
    omit?: ComboPlanAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanAgreementInclude<ExtArgs> | null
    where?: ComboPlanAgreementWhereInput
    orderBy?: ComboPlanAgreementOrderByWithRelationInput | ComboPlanAgreementOrderByWithRelationInput[]
    cursor?: ComboPlanAgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComboPlanAgreementScalarFieldEnum | ComboPlanAgreementScalarFieldEnum[]
  }

  /**
   * ComboPlan.services
   */
  export type ComboPlan$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanService
     */
    select?: ComboPlanServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanService
     */
    omit?: ComboPlanServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanServiceInclude<ExtArgs> | null
    where?: ComboPlanServiceWhereInput
    orderBy?: ComboPlanServiceOrderByWithRelationInput | ComboPlanServiceOrderByWithRelationInput[]
    cursor?: ComboPlanServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComboPlanServiceScalarFieldEnum | ComboPlanServiceScalarFieldEnum[]
  }

  /**
   * ComboPlan.coupon
   */
  export type ComboPlan$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    cursor?: CouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * ComboPlan.Transaction
   */
  export type ComboPlan$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * ComboPlan without action
   */
  export type ComboPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlan
     */
    select?: ComboPlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlan
     */
    omit?: ComboPlanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanInclude<ExtArgs> | null
  }


  /**
   * Model ComboPlanService
   */

  export type AggregateComboPlanService = {
    _count: ComboPlanServiceCountAggregateOutputType | null
    _min: ComboPlanServiceMinAggregateOutputType | null
    _max: ComboPlanServiceMaxAggregateOutputType | null
  }

  export type ComboPlanServiceMinAggregateOutputType = {
    id: string | null
    comboPlanId: string | null
    serviceId: string | null
  }

  export type ComboPlanServiceMaxAggregateOutputType = {
    id: string | null
    comboPlanId: string | null
    serviceId: string | null
  }

  export type ComboPlanServiceCountAggregateOutputType = {
    id: number
    comboPlanId: number
    serviceId: number
    _all: number
  }


  export type ComboPlanServiceMinAggregateInputType = {
    id?: true
    comboPlanId?: true
    serviceId?: true
  }

  export type ComboPlanServiceMaxAggregateInputType = {
    id?: true
    comboPlanId?: true
    serviceId?: true
  }

  export type ComboPlanServiceCountAggregateInputType = {
    id?: true
    comboPlanId?: true
    serviceId?: true
    _all?: true
  }

  export type ComboPlanServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComboPlanService to aggregate.
     */
    where?: ComboPlanServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboPlanServices to fetch.
     */
    orderBy?: ComboPlanServiceOrderByWithRelationInput | ComboPlanServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComboPlanServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboPlanServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboPlanServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComboPlanServices
    **/
    _count?: true | ComboPlanServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComboPlanServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComboPlanServiceMaxAggregateInputType
  }

  export type GetComboPlanServiceAggregateType<T extends ComboPlanServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateComboPlanService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComboPlanService[P]>
      : GetScalarType<T[P], AggregateComboPlanService[P]>
  }




  export type ComboPlanServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComboPlanServiceWhereInput
    orderBy?: ComboPlanServiceOrderByWithAggregationInput | ComboPlanServiceOrderByWithAggregationInput[]
    by: ComboPlanServiceScalarFieldEnum[] | ComboPlanServiceScalarFieldEnum
    having?: ComboPlanServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComboPlanServiceCountAggregateInputType | true
    _min?: ComboPlanServiceMinAggregateInputType
    _max?: ComboPlanServiceMaxAggregateInputType
  }

  export type ComboPlanServiceGroupByOutputType = {
    id: string
    comboPlanId: string
    serviceId: string
    _count: ComboPlanServiceCountAggregateOutputType | null
    _min: ComboPlanServiceMinAggregateOutputType | null
    _max: ComboPlanServiceMaxAggregateOutputType | null
  }

  type GetComboPlanServiceGroupByPayload<T extends ComboPlanServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComboPlanServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComboPlanServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComboPlanServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ComboPlanServiceGroupByOutputType[P]>
        }
      >
    >


  export type ComboPlanServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comboPlanId?: boolean
    serviceId?: boolean
    comboPlan?: boolean | ComboPlanDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comboPlanService"]>

  export type ComboPlanServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comboPlanId?: boolean
    serviceId?: boolean
    comboPlan?: boolean | ComboPlanDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comboPlanService"]>

  export type ComboPlanServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comboPlanId?: boolean
    serviceId?: boolean
    comboPlan?: boolean | ComboPlanDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comboPlanService"]>

  export type ComboPlanServiceSelectScalar = {
    id?: boolean
    comboPlanId?: boolean
    serviceId?: boolean
  }

  export type ComboPlanServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "comboPlanId" | "serviceId", ExtArgs["result"]["comboPlanService"]>
  export type ComboPlanServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comboPlan?: boolean | ComboPlanDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ComboPlanServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comboPlan?: boolean | ComboPlanDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ComboPlanServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comboPlan?: boolean | ComboPlanDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ComboPlanServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComboPlanService"
    objects: {
      comboPlan: Prisma.$ComboPlanPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      comboPlanId: string
      serviceId: string
    }, ExtArgs["result"]["comboPlanService"]>
    composites: {}
  }

  type ComboPlanServiceGetPayload<S extends boolean | null | undefined | ComboPlanServiceDefaultArgs> = $Result.GetResult<Prisma.$ComboPlanServicePayload, S>

  type ComboPlanServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComboPlanServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComboPlanServiceCountAggregateInputType | true
    }

  export interface ComboPlanServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComboPlanService'], meta: { name: 'ComboPlanService' } }
    /**
     * Find zero or one ComboPlanService that matches the filter.
     * @param {ComboPlanServiceFindUniqueArgs} args - Arguments to find a ComboPlanService
     * @example
     * // Get one ComboPlanService
     * const comboPlanService = await prisma.comboPlanService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComboPlanServiceFindUniqueArgs>(args: SelectSubset<T, ComboPlanServiceFindUniqueArgs<ExtArgs>>): Prisma__ComboPlanServiceClient<$Result.GetResult<Prisma.$ComboPlanServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComboPlanService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComboPlanServiceFindUniqueOrThrowArgs} args - Arguments to find a ComboPlanService
     * @example
     * // Get one ComboPlanService
     * const comboPlanService = await prisma.comboPlanService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComboPlanServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ComboPlanServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComboPlanServiceClient<$Result.GetResult<Prisma.$ComboPlanServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComboPlanService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanServiceFindFirstArgs} args - Arguments to find a ComboPlanService
     * @example
     * // Get one ComboPlanService
     * const comboPlanService = await prisma.comboPlanService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComboPlanServiceFindFirstArgs>(args?: SelectSubset<T, ComboPlanServiceFindFirstArgs<ExtArgs>>): Prisma__ComboPlanServiceClient<$Result.GetResult<Prisma.$ComboPlanServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComboPlanService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanServiceFindFirstOrThrowArgs} args - Arguments to find a ComboPlanService
     * @example
     * // Get one ComboPlanService
     * const comboPlanService = await prisma.comboPlanService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComboPlanServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ComboPlanServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComboPlanServiceClient<$Result.GetResult<Prisma.$ComboPlanServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComboPlanServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComboPlanServices
     * const comboPlanServices = await prisma.comboPlanService.findMany()
     * 
     * // Get first 10 ComboPlanServices
     * const comboPlanServices = await prisma.comboPlanService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comboPlanServiceWithIdOnly = await prisma.comboPlanService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComboPlanServiceFindManyArgs>(args?: SelectSubset<T, ComboPlanServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPlanServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComboPlanService.
     * @param {ComboPlanServiceCreateArgs} args - Arguments to create a ComboPlanService.
     * @example
     * // Create one ComboPlanService
     * const ComboPlanService = await prisma.comboPlanService.create({
     *   data: {
     *     // ... data to create a ComboPlanService
     *   }
     * })
     * 
     */
    create<T extends ComboPlanServiceCreateArgs>(args: SelectSubset<T, ComboPlanServiceCreateArgs<ExtArgs>>): Prisma__ComboPlanServiceClient<$Result.GetResult<Prisma.$ComboPlanServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComboPlanServices.
     * @param {ComboPlanServiceCreateManyArgs} args - Arguments to create many ComboPlanServices.
     * @example
     * // Create many ComboPlanServices
     * const comboPlanService = await prisma.comboPlanService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComboPlanServiceCreateManyArgs>(args?: SelectSubset<T, ComboPlanServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComboPlanServices and returns the data saved in the database.
     * @param {ComboPlanServiceCreateManyAndReturnArgs} args - Arguments to create many ComboPlanServices.
     * @example
     * // Create many ComboPlanServices
     * const comboPlanService = await prisma.comboPlanService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComboPlanServices and only return the `id`
     * const comboPlanServiceWithIdOnly = await prisma.comboPlanService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComboPlanServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ComboPlanServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPlanServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComboPlanService.
     * @param {ComboPlanServiceDeleteArgs} args - Arguments to delete one ComboPlanService.
     * @example
     * // Delete one ComboPlanService
     * const ComboPlanService = await prisma.comboPlanService.delete({
     *   where: {
     *     // ... filter to delete one ComboPlanService
     *   }
     * })
     * 
     */
    delete<T extends ComboPlanServiceDeleteArgs>(args: SelectSubset<T, ComboPlanServiceDeleteArgs<ExtArgs>>): Prisma__ComboPlanServiceClient<$Result.GetResult<Prisma.$ComboPlanServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComboPlanService.
     * @param {ComboPlanServiceUpdateArgs} args - Arguments to update one ComboPlanService.
     * @example
     * // Update one ComboPlanService
     * const comboPlanService = await prisma.comboPlanService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComboPlanServiceUpdateArgs>(args: SelectSubset<T, ComboPlanServiceUpdateArgs<ExtArgs>>): Prisma__ComboPlanServiceClient<$Result.GetResult<Prisma.$ComboPlanServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComboPlanServices.
     * @param {ComboPlanServiceDeleteManyArgs} args - Arguments to filter ComboPlanServices to delete.
     * @example
     * // Delete a few ComboPlanServices
     * const { count } = await prisma.comboPlanService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComboPlanServiceDeleteManyArgs>(args?: SelectSubset<T, ComboPlanServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComboPlanServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComboPlanServices
     * const comboPlanService = await prisma.comboPlanService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComboPlanServiceUpdateManyArgs>(args: SelectSubset<T, ComboPlanServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComboPlanServices and returns the data updated in the database.
     * @param {ComboPlanServiceUpdateManyAndReturnArgs} args - Arguments to update many ComboPlanServices.
     * @example
     * // Update many ComboPlanServices
     * const comboPlanService = await prisma.comboPlanService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComboPlanServices and only return the `id`
     * const comboPlanServiceWithIdOnly = await prisma.comboPlanService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComboPlanServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ComboPlanServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPlanServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComboPlanService.
     * @param {ComboPlanServiceUpsertArgs} args - Arguments to update or create a ComboPlanService.
     * @example
     * // Update or create a ComboPlanService
     * const comboPlanService = await prisma.comboPlanService.upsert({
     *   create: {
     *     // ... data to create a ComboPlanService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComboPlanService we want to update
     *   }
     * })
     */
    upsert<T extends ComboPlanServiceUpsertArgs>(args: SelectSubset<T, ComboPlanServiceUpsertArgs<ExtArgs>>): Prisma__ComboPlanServiceClient<$Result.GetResult<Prisma.$ComboPlanServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComboPlanServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanServiceCountArgs} args - Arguments to filter ComboPlanServices to count.
     * @example
     * // Count the number of ComboPlanServices
     * const count = await prisma.comboPlanService.count({
     *   where: {
     *     // ... the filter for the ComboPlanServices we want to count
     *   }
     * })
    **/
    count<T extends ComboPlanServiceCountArgs>(
      args?: Subset<T, ComboPlanServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComboPlanServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComboPlanService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComboPlanServiceAggregateArgs>(args: Subset<T, ComboPlanServiceAggregateArgs>): Prisma.PrismaPromise<GetComboPlanServiceAggregateType<T>>

    /**
     * Group by ComboPlanService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboPlanServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComboPlanServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComboPlanServiceGroupByArgs['orderBy'] }
        : { orderBy?: ComboPlanServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComboPlanServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComboPlanServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComboPlanService model
   */
  readonly fields: ComboPlanServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComboPlanService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComboPlanServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comboPlan<T extends ComboPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComboPlanDefaultArgs<ExtArgs>>): Prisma__ComboPlanClient<$Result.GetResult<Prisma.$ComboPlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComboPlanService model
   */
  interface ComboPlanServiceFieldRefs {
    readonly id: FieldRef<"ComboPlanService", 'String'>
    readonly comboPlanId: FieldRef<"ComboPlanService", 'String'>
    readonly serviceId: FieldRef<"ComboPlanService", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ComboPlanService findUnique
   */
  export type ComboPlanServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanService
     */
    select?: ComboPlanServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanService
     */
    omit?: ComboPlanServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanServiceInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlanService to fetch.
     */
    where: ComboPlanServiceWhereUniqueInput
  }

  /**
   * ComboPlanService findUniqueOrThrow
   */
  export type ComboPlanServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanService
     */
    select?: ComboPlanServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanService
     */
    omit?: ComboPlanServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanServiceInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlanService to fetch.
     */
    where: ComboPlanServiceWhereUniqueInput
  }

  /**
   * ComboPlanService findFirst
   */
  export type ComboPlanServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanService
     */
    select?: ComboPlanServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanService
     */
    omit?: ComboPlanServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanServiceInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlanService to fetch.
     */
    where?: ComboPlanServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboPlanServices to fetch.
     */
    orderBy?: ComboPlanServiceOrderByWithRelationInput | ComboPlanServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComboPlanServices.
     */
    cursor?: ComboPlanServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboPlanServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboPlanServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComboPlanServices.
     */
    distinct?: ComboPlanServiceScalarFieldEnum | ComboPlanServiceScalarFieldEnum[]
  }

  /**
   * ComboPlanService findFirstOrThrow
   */
  export type ComboPlanServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanService
     */
    select?: ComboPlanServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanService
     */
    omit?: ComboPlanServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanServiceInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlanService to fetch.
     */
    where?: ComboPlanServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboPlanServices to fetch.
     */
    orderBy?: ComboPlanServiceOrderByWithRelationInput | ComboPlanServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComboPlanServices.
     */
    cursor?: ComboPlanServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboPlanServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboPlanServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComboPlanServices.
     */
    distinct?: ComboPlanServiceScalarFieldEnum | ComboPlanServiceScalarFieldEnum[]
  }

  /**
   * ComboPlanService findMany
   */
  export type ComboPlanServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanService
     */
    select?: ComboPlanServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanService
     */
    omit?: ComboPlanServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanServiceInclude<ExtArgs> | null
    /**
     * Filter, which ComboPlanServices to fetch.
     */
    where?: ComboPlanServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboPlanServices to fetch.
     */
    orderBy?: ComboPlanServiceOrderByWithRelationInput | ComboPlanServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComboPlanServices.
     */
    cursor?: ComboPlanServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboPlanServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboPlanServices.
     */
    skip?: number
    distinct?: ComboPlanServiceScalarFieldEnum | ComboPlanServiceScalarFieldEnum[]
  }

  /**
   * ComboPlanService create
   */
  export type ComboPlanServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanService
     */
    select?: ComboPlanServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanService
     */
    omit?: ComboPlanServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a ComboPlanService.
     */
    data: XOR<ComboPlanServiceCreateInput, ComboPlanServiceUncheckedCreateInput>
  }

  /**
   * ComboPlanService createMany
   */
  export type ComboPlanServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComboPlanServices.
     */
    data: ComboPlanServiceCreateManyInput | ComboPlanServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComboPlanService createManyAndReturn
   */
  export type ComboPlanServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanService
     */
    select?: ComboPlanServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanService
     */
    omit?: ComboPlanServiceOmit<ExtArgs> | null
    /**
     * The data used to create many ComboPlanServices.
     */
    data: ComboPlanServiceCreateManyInput | ComboPlanServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComboPlanService update
   */
  export type ComboPlanServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanService
     */
    select?: ComboPlanServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanService
     */
    omit?: ComboPlanServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a ComboPlanService.
     */
    data: XOR<ComboPlanServiceUpdateInput, ComboPlanServiceUncheckedUpdateInput>
    /**
     * Choose, which ComboPlanService to update.
     */
    where: ComboPlanServiceWhereUniqueInput
  }

  /**
   * ComboPlanService updateMany
   */
  export type ComboPlanServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComboPlanServices.
     */
    data: XOR<ComboPlanServiceUpdateManyMutationInput, ComboPlanServiceUncheckedUpdateManyInput>
    /**
     * Filter which ComboPlanServices to update
     */
    where?: ComboPlanServiceWhereInput
    /**
     * Limit how many ComboPlanServices to update.
     */
    limit?: number
  }

  /**
   * ComboPlanService updateManyAndReturn
   */
  export type ComboPlanServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanService
     */
    select?: ComboPlanServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanService
     */
    omit?: ComboPlanServiceOmit<ExtArgs> | null
    /**
     * The data used to update ComboPlanServices.
     */
    data: XOR<ComboPlanServiceUpdateManyMutationInput, ComboPlanServiceUncheckedUpdateManyInput>
    /**
     * Filter which ComboPlanServices to update
     */
    where?: ComboPlanServiceWhereInput
    /**
     * Limit how many ComboPlanServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComboPlanService upsert
   */
  export type ComboPlanServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanService
     */
    select?: ComboPlanServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanService
     */
    omit?: ComboPlanServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the ComboPlanService to update in case it exists.
     */
    where: ComboPlanServiceWhereUniqueInput
    /**
     * In case the ComboPlanService found by the `where` argument doesn't exist, create a new ComboPlanService with this data.
     */
    create: XOR<ComboPlanServiceCreateInput, ComboPlanServiceUncheckedCreateInput>
    /**
     * In case the ComboPlanService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComboPlanServiceUpdateInput, ComboPlanServiceUncheckedUpdateInput>
  }

  /**
   * ComboPlanService delete
   */
  export type ComboPlanServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanService
     */
    select?: ComboPlanServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanService
     */
    omit?: ComboPlanServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanServiceInclude<ExtArgs> | null
    /**
     * Filter which ComboPlanService to delete.
     */
    where: ComboPlanServiceWhereUniqueInput
  }

  /**
   * ComboPlanService deleteMany
   */
  export type ComboPlanServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComboPlanServices to delete
     */
    where?: ComboPlanServiceWhereInput
    /**
     * Limit how many ComboPlanServices to delete.
     */
    limit?: number
  }

  /**
   * ComboPlanService without action
   */
  export type ComboPlanServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanService
     */
    select?: ComboPlanServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanService
     */
    omit?: ComboPlanServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanServiceInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    taxPercent: number | null
  }

  export type ServiceSumAggregateOutputType = {
    taxPercent: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    tag: string | null
    label: string | null
    serviceClass: string | null
    description: string | null
    comparisonTitle: string | null
    price: string | null
    taxPercent: number | null
    active: boolean | null
    type: $Enums.ServiceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    tag: string | null
    label: string | null
    serviceClass: string | null
    description: string | null
    comparisonTitle: string | null
    price: string | null
    taxPercent: number | null
    active: boolean | null
    type: $Enums.ServiceType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    tag: number
    label: number
    serviceClass: number
    description: number
    chart: number
    comparisonTitle: number
    recommendation: number
    price: number
    taxPercent: number
    tenureDiscounts: number
    features: number
    faq: number
    active: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    taxPercent?: true
  }

  export type ServiceSumAggregateInputType = {
    taxPercent?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    tag?: true
    label?: true
    serviceClass?: true
    description?: true
    comparisonTitle?: true
    price?: true
    taxPercent?: true
    active?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    tag?: true
    label?: true
    serviceClass?: true
    description?: true
    comparisonTitle?: true
    price?: true
    taxPercent?: true
    active?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    tag?: true
    label?: true
    serviceClass?: true
    description?: true
    chart?: true
    comparisonTitle?: true
    recommendation?: true
    price?: true
    taxPercent?: true
    tenureDiscounts?: true
    features?: true
    faq?: true
    active?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    slug: string
    tag: string | null
    label: string | null
    serviceClass: string | null
    description: string | null
    chart: JsonValue | null
    comparisonTitle: string | null
    recommendation: string[]
    price: string | null
    taxPercent: number | null
    tenureDiscounts: JsonValue | null
    features: JsonValue | null
    faq: JsonValue | null
    active: boolean | null
    type: $Enums.ServiceType
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    tag?: boolean
    label?: boolean
    serviceClass?: boolean
    description?: boolean
    chart?: boolean
    comparisonTitle?: boolean
    recommendation?: boolean
    price?: boolean
    taxPercent?: boolean
    tenureDiscounts?: boolean
    features?: boolean
    faq?: boolean
    active?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agreements?: boolean | Service$agreementsArgs<ExtArgs>
    serviceTrading?: boolean | Service$serviceTradingArgs<ExtArgs>
    purchasedServices?: boolean | Service$purchasedServicesArgs<ExtArgs>
    userDocuments?: boolean | Service$userDocumentsArgs<ExtArgs>
    Transaction?: boolean | Service$TransactionArgs<ExtArgs>
    ComboPlanService?: boolean | Service$ComboPlanServiceArgs<ExtArgs>
    coupon?: boolean | Service$couponArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    tag?: boolean
    label?: boolean
    serviceClass?: boolean
    description?: boolean
    chart?: boolean
    comparisonTitle?: boolean
    recommendation?: boolean
    price?: boolean
    taxPercent?: boolean
    tenureDiscounts?: boolean
    features?: boolean
    faq?: boolean
    active?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    tag?: boolean
    label?: boolean
    serviceClass?: boolean
    description?: boolean
    chart?: boolean
    comparisonTitle?: boolean
    recommendation?: boolean
    price?: boolean
    taxPercent?: boolean
    tenureDiscounts?: boolean
    features?: boolean
    faq?: boolean
    active?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    tag?: boolean
    label?: boolean
    serviceClass?: boolean
    description?: boolean
    chart?: boolean
    comparisonTitle?: boolean
    recommendation?: boolean
    price?: boolean
    taxPercent?: boolean
    tenureDiscounts?: boolean
    features?: boolean
    faq?: boolean
    active?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "tag" | "label" | "serviceClass" | "description" | "chart" | "comparisonTitle" | "recommendation" | "price" | "taxPercent" | "tenureDiscounts" | "features" | "faq" | "active" | "type" | "createdAt" | "updatedAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agreements?: boolean | Service$agreementsArgs<ExtArgs>
    serviceTrading?: boolean | Service$serviceTradingArgs<ExtArgs>
    purchasedServices?: boolean | Service$purchasedServicesArgs<ExtArgs>
    userDocuments?: boolean | Service$userDocumentsArgs<ExtArgs>
    Transaction?: boolean | Service$TransactionArgs<ExtArgs>
    ComboPlanService?: boolean | Service$ComboPlanServiceArgs<ExtArgs>
    coupon?: boolean | Service$couponArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      agreements: Prisma.$ServiceAgreementPayload<ExtArgs>[]
      serviceTrading: Prisma.$ServiceTradingPayload<ExtArgs> | null
      purchasedServices: Prisma.$UserPurchasedServicesPayload<ExtArgs>[]
      userDocuments: Prisma.$UserDocumentsPayload<ExtArgs>[]
      Transaction: Prisma.$TransactionPayload<ExtArgs>[]
      ComboPlanService: Prisma.$ComboPlanServicePayload<ExtArgs>[]
      coupon: Prisma.$CouponPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      tag: string | null
      label: string | null
      serviceClass: string | null
      description: string | null
      chart: Prisma.JsonValue | null
      comparisonTitle: string | null
      recommendation: string[]
      price: string | null
      taxPercent: number | null
      tenureDiscounts: Prisma.JsonValue | null
      features: Prisma.JsonValue | null
      faq: Prisma.JsonValue | null
      active: boolean | null
      type: $Enums.ServiceType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agreements<T extends Service$agreementsArgs<ExtArgs> = {}>(args?: Subset<T, Service$agreementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAgreementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceTrading<T extends Service$serviceTradingArgs<ExtArgs> = {}>(args?: Subset<T, Service$serviceTradingArgs<ExtArgs>>): Prisma__ServiceTradingClient<$Result.GetResult<Prisma.$ServiceTradingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    purchasedServices<T extends Service$purchasedServicesArgs<ExtArgs> = {}>(args?: Subset<T, Service$purchasedServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPurchasedServicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userDocuments<T extends Service$userDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Service$userDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserDocumentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Transaction<T extends Service$TransactionArgs<ExtArgs> = {}>(args?: Subset<T, Service$TransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ComboPlanService<T extends Service$ComboPlanServiceArgs<ExtArgs> = {}>(args?: Subset<T, Service$ComboPlanServiceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboPlanServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coupon<T extends Service$couponArgs<ExtArgs> = {}>(args?: Subset<T, Service$couponArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CouponPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly slug: FieldRef<"Service", 'String'>
    readonly tag: FieldRef<"Service", 'String'>
    readonly label: FieldRef<"Service", 'String'>
    readonly serviceClass: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly chart: FieldRef<"Service", 'Json'>
    readonly comparisonTitle: FieldRef<"Service", 'String'>
    readonly recommendation: FieldRef<"Service", 'String[]'>
    readonly price: FieldRef<"Service", 'String'>
    readonly taxPercent: FieldRef<"Service", 'Float'>
    readonly tenureDiscounts: FieldRef<"Service", 'Json'>
    readonly features: FieldRef<"Service", 'Json'>
    readonly faq: FieldRef<"Service", 'Json'>
    readonly active: FieldRef<"Service", 'Boolean'>
    readonly type: FieldRef<"Service", 'ServiceType'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.agreements
   */
  export type Service$agreementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAgreement
     */
    select?: ServiceAgreementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceAgreement
     */
    omit?: ServiceAgreementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAgreementInclude<ExtArgs> | null
    where?: ServiceAgreementWhereInput
    orderBy?: ServiceAgreementOrderByWithRelationInput | ServiceAgreementOrderByWithRelationInput[]
    cursor?: ServiceAgreementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceAgreementScalarFieldEnum | ServiceAgreementScalarFieldEnum[]
  }

  /**
   * Service.serviceTrading
   */
  export type Service$serviceTradingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTrading
     */
    select?: ServiceTradingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTrading
     */
    omit?: ServiceTradingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTradingInclude<ExtArgs> | null
    where?: ServiceTradingWhereInput
  }

  /**
   * Service.purchasedServices
   */
  export type Service$purchasedServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPurchasedServices
     */
    select?: UserPurchasedServicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPurchasedServices
     */
    omit?: UserPurchasedServicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPurchasedServicesInclude<ExtArgs> | null
    where?: UserPurchasedServicesWhereInput
    orderBy?: UserPurchasedServicesOrderByWithRelationInput | UserPurchasedServicesOrderByWithRelationInput[]
    cursor?: UserPurchasedServicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPurchasedServicesScalarFieldEnum | UserPurchasedServicesScalarFieldEnum[]
  }

  /**
   * Service.userDocuments
   */
  export type Service$userDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserDocuments
     */
    select?: UserDocumentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserDocuments
     */
    omit?: UserDocumentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserDocumentsInclude<ExtArgs> | null
    where?: UserDocumentsWhereInput
    orderBy?: UserDocumentsOrderByWithRelationInput | UserDocumentsOrderByWithRelationInput[]
    cursor?: UserDocumentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserDocumentsScalarFieldEnum | UserDocumentsScalarFieldEnum[]
  }

  /**
   * Service.Transaction
   */
  export type Service$TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Service.ComboPlanService
   */
  export type Service$ComboPlanServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboPlanService
     */
    select?: ComboPlanServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComboPlanService
     */
    omit?: ComboPlanServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboPlanServiceInclude<ExtArgs> | null
    where?: ComboPlanServiceWhereInput
    orderBy?: ComboPlanServiceOrderByWithRelationInput | ComboPlanServiceOrderByWithRelationInput[]
    cursor?: ComboPlanServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComboPlanServiceScalarFieldEnum | ComboPlanServiceScalarFieldEnum[]
  }

  /**
   * Service.coupon
   */
  export type Service$couponArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Coupon
     */
    select?: CouponSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Coupon
     */
    omit?: CouponOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CouponInclude<ExtArgs> | null
    where?: CouponWhereInput
    orderBy?: CouponOrderByWithRelationInput | CouponOrderByWithRelationInput[]
    cursor?: CouponWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CouponScalarFieldEnum | CouponScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceTrading
   */

  export type AggregateServiceTrading = {
    _count: ServiceTradingCountAggregateOutputType | null
    _min: ServiceTradingMinAggregateOutputType | null
    _max: ServiceTradingMaxAggregateOutputType | null
  }

  export type ServiceTradingMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTradingMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTradingCountAggregateOutputType = {
    id: number
    buy_stock_list: number
    sell_stock_list: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceTradingMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTradingMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTradingCountAggregateInputType = {
    id?: true
    buy_stock_list?: true
    sell_stock_list?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceTradingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTrading to aggregate.
     */
    where?: ServiceTradingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTradings to fetch.
     */
    orderBy?: ServiceTradingOrderByWithRelationInput | ServiceTradingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceTradingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTradings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTradings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceTradings
    **/
    _count?: true | ServiceTradingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceTradingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceTradingMaxAggregateInputType
  }

  export type GetServiceTradingAggregateType<T extends ServiceTradingAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceTrading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceTrading[P]>
      : GetScalarType<T[P], AggregateServiceTrading[P]>
  }




  export type ServiceTradingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceTradingWhereInput
    orderBy?: ServiceTradingOrderByWithAggregationInput | ServiceTradingOrderByWithAggregationInput[]
    by: ServiceTradingScalarFieldEnum[] | ServiceTradingScalarFieldEnum
    having?: ServiceTradingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceTradingCountAggregateInputType | true
    _min?: ServiceTradingMinAggregateInputType
    _max?: ServiceTradingMaxAggregateInputType
  }

  export type ServiceTradingGroupByOutputType = {
    id: string
    buy_stock_list: JsonValue
    sell_stock_list: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: ServiceTradingCountAggregateOutputType | null
    _min: ServiceTradingMinAggregateOutputType | null
    _max: ServiceTradingMaxAggregateOutputType | null
  }

  type GetServiceTradingGroupByPayload<T extends ServiceTradingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceTradingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceTradingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceTradingGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceTradingGroupByOutputType[P]>
        }
      >
    >


  export type ServiceTradingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buy_stock_list?: boolean
    sell_stock_list?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceTrading"]>

  export type ServiceTradingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buy_stock_list?: boolean
    sell_stock_list?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceTrading"]>

  export type ServiceTradingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buy_stock_list?: boolean
    sell_stock_list?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceTrading"]>

  export type ServiceTradingSelectScalar = {
    id?: boolean
    buy_stock_list?: boolean
    sell_stock_list?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceTradingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "buy_stock_list" | "sell_stock_list" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceTrading"]>
  export type ServiceTradingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ServiceTradingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ServiceTradingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ServiceTradingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceTrading"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      buy_stock_list: Prisma.JsonValue
      sell_stock_list: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceTrading"]>
    composites: {}
  }

  type ServiceTradingGetPayload<S extends boolean | null | undefined | ServiceTradingDefaultArgs> = $Result.GetResult<Prisma.$ServiceTradingPayload, S>

  type ServiceTradingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceTradingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceTradingCountAggregateInputType | true
    }

  export interface ServiceTradingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceTrading'], meta: { name: 'ServiceTrading' } }
    /**
     * Find zero or one ServiceTrading that matches the filter.
     * @param {ServiceTradingFindUniqueArgs} args - Arguments to find a ServiceTrading
     * @example
     * // Get one ServiceTrading
     * const serviceTrading = await prisma.serviceTrading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceTradingFindUniqueArgs>(args: SelectSubset<T, ServiceTradingFindUniqueArgs<ExtArgs>>): Prisma__ServiceTradingClient<$Result.GetResult<Prisma.$ServiceTradingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceTrading that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceTradingFindUniqueOrThrowArgs} args - Arguments to find a ServiceTrading
     * @example
     * // Get one ServiceTrading
     * const serviceTrading = await prisma.serviceTrading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceTradingFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceTradingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceTradingClient<$Result.GetResult<Prisma.$ServiceTradingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceTrading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTradingFindFirstArgs} args - Arguments to find a ServiceTrading
     * @example
     * // Get one ServiceTrading
     * const serviceTrading = await prisma.serviceTrading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceTradingFindFirstArgs>(args?: SelectSubset<T, ServiceTradingFindFirstArgs<ExtArgs>>): Prisma__ServiceTradingClient<$Result.GetResult<Prisma.$ServiceTradingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceTrading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTradingFindFirstOrThrowArgs} args - Arguments to find a ServiceTrading
     * @example
     * // Get one ServiceTrading
     * const serviceTrading = await prisma.serviceTrading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceTradingFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceTradingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceTradingClient<$Result.GetResult<Prisma.$ServiceTradingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceTradings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTradingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceTradings
     * const serviceTradings = await prisma.serviceTrading.findMany()
     * 
     * // Get first 10 ServiceTradings
     * const serviceTradings = await prisma.serviceTrading.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceTradingWithIdOnly = await prisma.serviceTrading.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceTradingFindManyArgs>(args?: SelectSubset<T, ServiceTradingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTradingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceTrading.
     * @param {ServiceTradingCreateArgs} args - Arguments to create a ServiceTrading.
     * @example
     * // Create one ServiceTrading
     * const ServiceTrading = await prisma.serviceTrading.create({
     *   data: {
     *     // ... data to create a ServiceTrading
     *   }
     * })
     * 
     */
    create<T extends ServiceTradingCreateArgs>(args: SelectSubset<T, ServiceTradingCreateArgs<ExtArgs>>): Prisma__ServiceTradingClient<$Result.GetResult<Prisma.$ServiceTradingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceTradings.
     * @param {ServiceTradingCreateManyArgs} args - Arguments to create many ServiceTradings.
     * @example
     * // Create many ServiceTradings
     * const serviceTrading = await prisma.serviceTrading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceTradingCreateManyArgs>(args?: SelectSubset<T, ServiceTradingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceTradings and returns the data saved in the database.
     * @param {ServiceTradingCreateManyAndReturnArgs} args - Arguments to create many ServiceTradings.
     * @example
     * // Create many ServiceTradings
     * const serviceTrading = await prisma.serviceTrading.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceTradings and only return the `id`
     * const serviceTradingWithIdOnly = await prisma.serviceTrading.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceTradingCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceTradingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTradingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceTrading.
     * @param {ServiceTradingDeleteArgs} args - Arguments to delete one ServiceTrading.
     * @example
     * // Delete one ServiceTrading
     * const ServiceTrading = await prisma.serviceTrading.delete({
     *   where: {
     *     // ... filter to delete one ServiceTrading
     *   }
     * })
     * 
     */
    delete<T extends ServiceTradingDeleteArgs>(args: SelectSubset<T, ServiceTradingDeleteArgs<ExtArgs>>): Prisma__ServiceTradingClient<$Result.GetResult<Prisma.$ServiceTradingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceTrading.
     * @param {ServiceTradingUpdateArgs} args - Arguments to update one ServiceTrading.
     * @example
     * // Update one ServiceTrading
     * const serviceTrading = await prisma.serviceTrading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceTradingUpdateArgs>(args: SelectSubset<T, ServiceTradingUpdateArgs<ExtArgs>>): Prisma__ServiceTradingClient<$Result.GetResult<Prisma.$ServiceTradingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceTradings.
     * @param {ServiceTradingDeleteManyArgs} args - Arguments to filter ServiceTradings to delete.
     * @example
     * // Delete a few ServiceTradings
     * const { count } = await prisma.serviceTrading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceTradingDeleteManyArgs>(args?: SelectSubset<T, ServiceTradingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTradings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTradingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceTradings
     * const serviceTrading = await prisma.serviceTrading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceTradingUpdateManyArgs>(args: SelectSubset<T, ServiceTradingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTradings and returns the data updated in the database.
     * @param {ServiceTradingUpdateManyAndReturnArgs} args - Arguments to update many ServiceTradings.
     * @example
     * // Update many ServiceTradings
     * const serviceTrading = await prisma.serviceTrading.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceTradings and only return the `id`
     * const serviceTradingWithIdOnly = await prisma.serviceTrading.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceTradingUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceTradingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTradingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceTrading.
     * @param {ServiceTradingUpsertArgs} args - Arguments to update or create a ServiceTrading.
     * @example
     * // Update or create a ServiceTrading
     * const serviceTrading = await prisma.serviceTrading.upsert({
     *   create: {
     *     // ... data to create a ServiceTrading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceTrading we want to update
     *   }
     * })
     */
    upsert<T extends ServiceTradingUpsertArgs>(args: SelectSubset<T, ServiceTradingUpsertArgs<ExtArgs>>): Prisma__ServiceTradingClient<$Result.GetResult<Prisma.$ServiceTradingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceTradings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTradingCountArgs} args - Arguments to filter ServiceTradings to count.
     * @example
     * // Count the number of ServiceTradings
     * const count = await prisma.serviceTrading.count({
     *   where: {
     *     // ... the filter for the ServiceTradings we want to count
     *   }
     * })
    **/
    count<T extends ServiceTradingCountArgs>(
      args?: Subset<T, ServiceTradingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceTradingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceTrading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTradingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceTradingAggregateArgs>(args: Subset<T, ServiceTradingAggregateArgs>): Prisma.PrismaPromise<GetServiceTradingAggregateType<T>>

    /**
     * Group by ServiceTrading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTradingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceTradingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceTradingGroupByArgs['orderBy'] }
        : { orderBy?: ServiceTradingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceTradingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceTradingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceTrading model
   */
  readonly fields: ServiceTradingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceTrading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceTradingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceTrading model
   */
  interface ServiceTradingFieldRefs {
    readonly id: FieldRef<"ServiceTrading", 'String'>
    readonly buy_stock_list: FieldRef<"ServiceTrading", 'Json'>
    readonly sell_stock_list: FieldRef<"ServiceTrading", 'Json'>
    readonly createdAt: FieldRef<"ServiceTrading", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceTrading", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceTrading findUnique
   */
  export type ServiceTradingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTrading
     */
    select?: ServiceTradingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTrading
     */
    omit?: ServiceTradingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTradingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTrading to fetch.
     */
    where: ServiceTradingWhereUniqueInput
  }

  /**
   * ServiceTrading findUniqueOrThrow
   */
  export type ServiceTradingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTrading
     */
    select?: ServiceTradingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTrading
     */
    omit?: ServiceTradingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTradingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTrading to fetch.
     */
    where: ServiceTradingWhereUniqueInput
  }

  /**
   * ServiceTrading findFirst
   */
  export type ServiceTradingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTrading
     */
    select?: ServiceTradingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTrading
     */
    omit?: ServiceTradingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTradingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTrading to fetch.
     */
    where?: ServiceTradingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTradings to fetch.
     */
    orderBy?: ServiceTradingOrderByWithRelationInput | ServiceTradingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTradings.
     */
    cursor?: ServiceTradingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTradings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTradings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTradings.
     */
    distinct?: ServiceTradingScalarFieldEnum | ServiceTradingScalarFieldEnum[]
  }

  /**
   * ServiceTrading findFirstOrThrow
   */
  export type ServiceTradingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTrading
     */
    select?: ServiceTradingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTrading
     */
    omit?: ServiceTradingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTradingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTrading to fetch.
     */
    where?: ServiceTradingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTradings to fetch.
     */
    orderBy?: ServiceTradingOrderByWithRelationInput | ServiceTradingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTradings.
     */
    cursor?: ServiceTradingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTradings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTradings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTradings.
     */
    distinct?: ServiceTradingScalarFieldEnum | ServiceTradingScalarFieldEnum[]
  }

  /**
   * ServiceTrading findMany
   */
  export type ServiceTradingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTrading
     */
    select?: ServiceTradingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTrading
     */
    omit?: ServiceTradingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTradingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTradings to fetch.
     */
    where?: ServiceTradingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTradings to fetch.
     */
    orderBy?: ServiceTradingOrderByWithRelationInput | ServiceTradingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceTradings.
     */
    cursor?: ServiceTradingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTradings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTradings.
     */
    skip?: number
    distinct?: ServiceTradingScalarFieldEnum | ServiceTradingScalarFieldEnum[]
  }

  /**
   * ServiceTrading create
   */
  export type ServiceTradingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTrading
     */
    select?: ServiceTradingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTrading
     */
    omit?: ServiceTradingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTradingInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceTrading.
     */
    data: XOR<ServiceTradingCreateInput, ServiceTradingUncheckedCreateInput>
  }

  /**
   * ServiceTrading createMany
   */
  export type ServiceTradingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceTradings.
     */
    data: ServiceTradingCreateManyInput | ServiceTradingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceTrading createManyAndReturn
   */
  export type ServiceTradingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTrading
     */
    select?: ServiceTradingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTrading
     */
    omit?: ServiceTradingOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceTradings.
     */
    data: ServiceTradingCreateManyInput | ServiceTradingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTradingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceTrading update
   */
  export type ServiceTradingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTrading
     */
    select?: ServiceTradingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTrading
     */
    omit?: ServiceTradingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTradingInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceTrading.
     */
    data: XOR<ServiceTradingUpdateInput, ServiceTradingUncheckedUpdateInput>
    /**
     * Choose, which ServiceTrading to update.
     */
    where: ServiceTradingWhereUniqueInput
  }

  /**
   * ServiceTrading updateMany
   */
  export type ServiceTradingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceTradings.
     */
    data: XOR<ServiceTradingUpdateManyMutationInput, ServiceTradingUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTradings to update
     */
    where?: ServiceTradingWhereInput
    /**
     * Limit how many ServiceTradings to update.
     */
    limit?: number
  }

  /**
   * ServiceTrading updateManyAndReturn
   */
  export type ServiceTradingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTrading
     */
    select?: ServiceTradingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTrading
     */
    omit?: ServiceTradingOmit<ExtArgs> | null
    /**
     * The data used to update ServiceTradings.
     */
    data: XOR<ServiceTradingUpdateManyMutationInput, ServiceTradingUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTradings to update
     */
    where?: ServiceTradingWhereInput
    /**
     * Limit how many ServiceTradings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTradingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceTrading upsert
   */
  export type ServiceTradingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTrading
     */
    select?: ServiceTradingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTrading
     */
    omit?: ServiceTradingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTradingInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceTrading to update in case it exists.
     */
    where: ServiceTradingWhereUniqueInput
    /**
     * In case the ServiceTrading found by the `where` argument doesn't exist, create a new ServiceTrading with this data.
     */
    create: XOR<ServiceTradingCreateInput, ServiceTradingUncheckedCreateInput>
    /**
     * In case the ServiceTrading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceTradingUpdateInput, ServiceTradingUncheckedUpdateInput>
  }

  /**
   * ServiceTrading delete
   */
  export type ServiceTradingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTrading
     */
    select?: ServiceTradingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTrading
     */
    omit?: ServiceTradingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTradingInclude<ExtArgs> | null
    /**
     * Filter which ServiceTrading to delete.
     */
    where: ServiceTradingWhereUniqueInput
  }

  /**
   * ServiceTrading deleteMany
   */
  export type ServiceTradingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTradings to delete
     */
    where?: ServiceTradingWhereInput
    /**
     * Limit how many ServiceTradings to delete.
     */
    limit?: number
  }

  /**
   * ServiceTrading without action
   */
  export type ServiceTradingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTrading
     */
    select?: ServiceTradingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTrading
     */
    omit?: ServiceTradingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTradingInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    username: 'username',
    image: 'image',
    password: 'password',
    dob: 'dob',
    pan: 'pan',
    aadharNumber: 'aadharNumber',
    gstin: 'gstin',
    address: 'address',
    state: 'state',
    city: 'city',
    zip: 'zip',
    panVerified: 'panVerified',
    termsAccepted: 'termsAccepted',
    emailVerified: 'emailVerified',
    phoneVerified: 'phoneVerified',
    isBanned: 'isBanned',
    userType: 'userType',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    identifier: 'identifier',
    otp: 'otp',
    expires_at: 'expires_at',
    verificationType: 'verificationType',
    createdAt: 'createdAt'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const PanVerificationDataScalarFieldEnum: {
    userId: 'userId',
    provider: 'provider',
    result: 'result',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PanVerificationDataScalarFieldEnum = (typeof PanVerificationDataScalarFieldEnum)[keyof typeof PanVerificationDataScalarFieldEnum]


  export const UserPurchasedServicesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    serviceId: 'serviceId',
    purchaseDate: 'purchaseDate',
    expiryDate: 'expiryDate',
    planDays: 'planDays',
    planDiscount: 'planDiscount',
    agreementAcceptedAt: 'agreementAcceptedAt',
    agreementData: 'agreementData'
  };

  export type UserPurchasedServicesScalarFieldEnum = (typeof UserPurchasedServicesScalarFieldEnum)[keyof typeof UserPurchasedServicesScalarFieldEnum]


  export const CouponScalarFieldEnum: {
    id: 'id',
    code: 'code',
    description: 'description',
    percentOff: 'percentOff',
    expiryDate: 'expiryDate',
    minAmount: 'minAmount',
    maxAmount: 'maxAmount',
    serviceId: 'serviceId',
    comboPlanId: 'comboPlanId',
    planDays: 'planDays',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CouponScalarFieldEnum = (typeof CouponScalarFieldEnum)[keyof typeof CouponScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    paymentId: 'paymentId',
    couponId: 'couponId',
    userId: 'userId',
    serviceId: 'serviceId',
    comboPlanId: 'comboPlanId',
    amount: 'amount',
    tenure: 'tenure',
    currency: 'currency',
    status: 'status',
    paymentGateway: 'paymentGateway',
    idempotencyKey: 'idempotencyKey',
    webhookResponse: 'webhookResponse',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    extraData: 'extraData'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const UserDocumentsScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    userId: 'userId',
    documentUrl: 'documentUrl',
    reviewedDocumentUrl: 'reviewedDocumentUrl',
    status: 'status',
    reviewedBy: 'reviewedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserDocumentsScalarFieldEnum = (typeof UserDocumentsScalarFieldEnum)[keyof typeof UserDocumentsScalarFieldEnum]


  export const AgreementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    content: 'content',
    version: 'version',
    hash: 'hash',
    signatoryPerson: 'signatoryPerson',
    companyName: 'companyName',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type AgreementScalarFieldEnum = (typeof AgreementScalarFieldEnum)[keyof typeof AgreementScalarFieldEnum]


  export const ServiceAgreementScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    agreementId: 'agreementId'
  };

  export type ServiceAgreementScalarFieldEnum = (typeof ServiceAgreementScalarFieldEnum)[keyof typeof ServiceAgreementScalarFieldEnum]


  export const ComboPlanAgreementScalarFieldEnum: {
    id: 'id',
    comboPlanId: 'comboPlanId',
    agreementId: 'agreementId'
  };

  export type ComboPlanAgreementScalarFieldEnum = (typeof ComboPlanAgreementScalarFieldEnum)[keyof typeof ComboPlanAgreementScalarFieldEnum]


  export const ComboPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    taxPercent: 'taxPercent',
    active: 'active',
    tenureDiscounts: 'tenureDiscounts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComboPlanScalarFieldEnum = (typeof ComboPlanScalarFieldEnum)[keyof typeof ComboPlanScalarFieldEnum]


  export const ComboPlanServiceScalarFieldEnum: {
    id: 'id',
    comboPlanId: 'comboPlanId',
    serviceId: 'serviceId'
  };

  export type ComboPlanServiceScalarFieldEnum = (typeof ComboPlanServiceScalarFieldEnum)[keyof typeof ComboPlanServiceScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    tag: 'tag',
    label: 'label',
    serviceClass: 'serviceClass',
    description: 'description',
    chart: 'chart',
    comparisonTitle: 'comparisonTitle',
    recommendation: 'recommendation',
    price: 'price',
    taxPercent: 'taxPercent',
    tenureDiscounts: 'tenureDiscounts',
    features: 'features',
    faq: 'faq',
    active: 'active',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServiceTradingScalarFieldEnum: {
    id: 'id',
    buy_stock_list: 'buy_stock_list',
    sell_stock_list: 'sell_stock_list',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceTradingScalarFieldEnum = (typeof ServiceTradingScalarFieldEnum)[keyof typeof ServiceTradingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'VerificationType'
   */
  export type EnumVerificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationType'>
    


  /**
   * Reference to a field of type 'VerificationType[]'
   */
  export type ListEnumVerificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'DocumentStatus'
   */
  export type EnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus'>
    


  /**
   * Reference to a field of type 'DocumentStatus[]'
   */
  export type ListEnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus[]'>
    


  /**
   * Reference to a field of type 'ServiceType'
   */
  export type EnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType'>
    


  /**
   * Reference to a field of type 'ServiceType[]'
   */
  export type ListEnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    dob?: StringNullableFilter<"User"> | string | null
    pan?: StringNullableFilter<"User"> | string | null
    aadharNumber?: StringNullableFilter<"User"> | string | null
    gstin?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    zip?: StringNullableFilter<"User"> | string | null
    panVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    termsAccepted?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    phoneVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    isBanned?: BoolFilter<"User"> | boolean
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    documents?: UserDocumentsListRelationFilter
    purchasedServices?: UserPurchasedServicesListRelationFilter
    panVerificationData?: PanVerificationDataListRelationFilter
    transaction?: TransactionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    pan?: SortOrderInput | SortOrder
    aadharNumber?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    panVerified?: SortOrderInput | SortOrder
    termsAccepted?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    phoneVerified?: SortOrderInput | SortOrder
    isBanned?: SortOrder
    userType?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    documents?: UserDocumentsOrderByRelationAggregateInput
    purchasedServices?: UserPurchasedServicesOrderByRelationAggregateInput
    panVerificationData?: panVerificationDataOrderByRelationAggregateInput
    transaction?: TransactionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    username?: string
    pan?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    dob?: StringNullableFilter<"User"> | string | null
    aadharNumber?: StringNullableFilter<"User"> | string | null
    gstin?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    zip?: StringNullableFilter<"User"> | string | null
    panVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    termsAccepted?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    phoneVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    isBanned?: BoolFilter<"User"> | boolean
    userType?: EnumUserTypeFilter<"User"> | $Enums.UserType
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    documents?: UserDocumentsListRelationFilter
    purchasedServices?: UserPurchasedServicesListRelationFilter
    panVerificationData?: PanVerificationDataListRelationFilter
    transaction?: TransactionListRelationFilter
  }, "id" | "email" | "phone" | "username" | "pan">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    pan?: SortOrderInput | SortOrder
    aadharNumber?: SortOrderInput | SortOrder
    gstin?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    panVerified?: SortOrderInput | SortOrder
    termsAccepted?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    phoneVerified?: SortOrderInput | SortOrder
    isBanned?: SortOrder
    userType?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    dob?: StringNullableWithAggregatesFilter<"User"> | string | null
    pan?: StringNullableWithAggregatesFilter<"User"> | string | null
    aadharNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    gstin?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    state?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    zip?: StringNullableWithAggregatesFilter<"User"> | string | null
    panVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    termsAccepted?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    phoneVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isBanned?: BoolWithAggregatesFilter<"User"> | boolean
    userType?: EnumUserTypeWithAggregatesFilter<"User"> | $Enums.UserType
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type OtpWhereInput = {
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    id?: StringFilter<"Otp"> | string
    userId?: StringFilter<"Otp"> | string
    identifier?: StringFilter<"Otp"> | string
    otp?: StringFilter<"Otp"> | string
    expires_at?: DateTimeFilter<"Otp"> | Date | string
    verificationType?: EnumVerificationTypeFilter<"Otp"> | $Enums.VerificationType
    createdAt?: DateTimeFilter<"Otp"> | Date | string
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    identifier?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    verificationType?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_identifier_verificationType?: OtpUserIdIdentifierVerificationTypeCompoundUniqueInput
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    userId?: StringFilter<"Otp"> | string
    identifier?: StringFilter<"Otp"> | string
    otp?: StringFilter<"Otp"> | string
    expires_at?: DateTimeFilter<"Otp"> | Date | string
    verificationType?: EnumVerificationTypeFilter<"Otp"> | $Enums.VerificationType
    createdAt?: DateTimeFilter<"Otp"> | Date | string
  }, "id" | "userId_identifier_verificationType">

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    identifier?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    verificationType?: SortOrder
    createdAt?: SortOrder
    _count?: OtpCountOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    OR?: OtpScalarWhereWithAggregatesInput[]
    NOT?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Otp"> | string
    userId?: StringWithAggregatesFilter<"Otp"> | string
    identifier?: StringWithAggregatesFilter<"Otp"> | string
    otp?: StringWithAggregatesFilter<"Otp"> | string
    expires_at?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    verificationType?: EnumVerificationTypeWithAggregatesFilter<"Otp"> | $Enums.VerificationType
    createdAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
  }

  export type panVerificationDataWhereInput = {
    AND?: panVerificationDataWhereInput | panVerificationDataWhereInput[]
    OR?: panVerificationDataWhereInput[]
    NOT?: panVerificationDataWhereInput | panVerificationDataWhereInput[]
    userId?: StringFilter<"panVerificationData"> | string
    provider?: StringFilter<"panVerificationData"> | string
    result?: JsonFilter<"panVerificationData">
    status?: StringFilter<"panVerificationData"> | string
    createdAt?: DateTimeFilter<"panVerificationData"> | Date | string
    updatedAt?: DateTimeFilter<"panVerificationData"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type panVerificationDataOrderByWithRelationInput = {
    userId?: SortOrder
    provider?: SortOrder
    result?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type panVerificationDataWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: panVerificationDataWhereInput | panVerificationDataWhereInput[]
    OR?: panVerificationDataWhereInput[]
    NOT?: panVerificationDataWhereInput | panVerificationDataWhereInput[]
    provider?: StringFilter<"panVerificationData"> | string
    result?: JsonFilter<"panVerificationData">
    status?: StringFilter<"panVerificationData"> | string
    createdAt?: DateTimeFilter<"panVerificationData"> | Date | string
    updatedAt?: DateTimeFilter<"panVerificationData"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId">

  export type panVerificationDataOrderByWithAggregationInput = {
    userId?: SortOrder
    provider?: SortOrder
    result?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: panVerificationDataCountOrderByAggregateInput
    _max?: panVerificationDataMaxOrderByAggregateInput
    _min?: panVerificationDataMinOrderByAggregateInput
  }

  export type panVerificationDataScalarWhereWithAggregatesInput = {
    AND?: panVerificationDataScalarWhereWithAggregatesInput | panVerificationDataScalarWhereWithAggregatesInput[]
    OR?: panVerificationDataScalarWhereWithAggregatesInput[]
    NOT?: panVerificationDataScalarWhereWithAggregatesInput | panVerificationDataScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"panVerificationData"> | string
    provider?: StringWithAggregatesFilter<"panVerificationData"> | string
    result?: JsonWithAggregatesFilter<"panVerificationData">
    status?: StringWithAggregatesFilter<"panVerificationData"> | string
    createdAt?: DateTimeWithAggregatesFilter<"panVerificationData"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"panVerificationData"> | Date | string
  }

  export type UserPurchasedServicesWhereInput = {
    AND?: UserPurchasedServicesWhereInput | UserPurchasedServicesWhereInput[]
    OR?: UserPurchasedServicesWhereInput[]
    NOT?: UserPurchasedServicesWhereInput | UserPurchasedServicesWhereInput[]
    id?: StringFilter<"UserPurchasedServices"> | string
    userId?: StringFilter<"UserPurchasedServices"> | string
    serviceId?: StringFilter<"UserPurchasedServices"> | string
    purchaseDate?: DateTimeFilter<"UserPurchasedServices"> | Date | string
    expiryDate?: DateTimeFilter<"UserPurchasedServices"> | Date | string
    planDays?: IntFilter<"UserPurchasedServices"> | number
    planDiscount?: FloatFilter<"UserPurchasedServices"> | number
    agreementAcceptedAt?: DateTimeNullableFilter<"UserPurchasedServices"> | Date | string | null
    agreementData?: JsonNullableFilter<"UserPurchasedServices">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type UserPurchasedServicesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    planDays?: SortOrder
    planDiscount?: SortOrder
    agreementAcceptedAt?: SortOrderInput | SortOrder
    agreementData?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type UserPurchasedServicesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_serviceId_expiryDate?: UserPurchasedServicesUserIdServiceIdExpiryDateCompoundUniqueInput
    AND?: UserPurchasedServicesWhereInput | UserPurchasedServicesWhereInput[]
    OR?: UserPurchasedServicesWhereInput[]
    NOT?: UserPurchasedServicesWhereInput | UserPurchasedServicesWhereInput[]
    userId?: StringFilter<"UserPurchasedServices"> | string
    serviceId?: StringFilter<"UserPurchasedServices"> | string
    purchaseDate?: DateTimeFilter<"UserPurchasedServices"> | Date | string
    expiryDate?: DateTimeFilter<"UserPurchasedServices"> | Date | string
    planDays?: IntFilter<"UserPurchasedServices"> | number
    planDiscount?: FloatFilter<"UserPurchasedServices"> | number
    agreementAcceptedAt?: DateTimeNullableFilter<"UserPurchasedServices"> | Date | string | null
    agreementData?: JsonNullableFilter<"UserPurchasedServices">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id" | "userId_serviceId_expiryDate">

  export type UserPurchasedServicesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    planDays?: SortOrder
    planDiscount?: SortOrder
    agreementAcceptedAt?: SortOrderInput | SortOrder
    agreementData?: SortOrderInput | SortOrder
    _count?: UserPurchasedServicesCountOrderByAggregateInput
    _avg?: UserPurchasedServicesAvgOrderByAggregateInput
    _max?: UserPurchasedServicesMaxOrderByAggregateInput
    _min?: UserPurchasedServicesMinOrderByAggregateInput
    _sum?: UserPurchasedServicesSumOrderByAggregateInput
  }

  export type UserPurchasedServicesScalarWhereWithAggregatesInput = {
    AND?: UserPurchasedServicesScalarWhereWithAggregatesInput | UserPurchasedServicesScalarWhereWithAggregatesInput[]
    OR?: UserPurchasedServicesScalarWhereWithAggregatesInput[]
    NOT?: UserPurchasedServicesScalarWhereWithAggregatesInput | UserPurchasedServicesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPurchasedServices"> | string
    userId?: StringWithAggregatesFilter<"UserPurchasedServices"> | string
    serviceId?: StringWithAggregatesFilter<"UserPurchasedServices"> | string
    purchaseDate?: DateTimeWithAggregatesFilter<"UserPurchasedServices"> | Date | string
    expiryDate?: DateTimeWithAggregatesFilter<"UserPurchasedServices"> | Date | string
    planDays?: IntWithAggregatesFilter<"UserPurchasedServices"> | number
    planDiscount?: FloatWithAggregatesFilter<"UserPurchasedServices"> | number
    agreementAcceptedAt?: DateTimeNullableWithAggregatesFilter<"UserPurchasedServices"> | Date | string | null
    agreementData?: JsonNullableWithAggregatesFilter<"UserPurchasedServices">
  }

  export type CouponWhereInput = {
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    id?: StringFilter<"Coupon"> | string
    code?: StringFilter<"Coupon"> | string
    description?: StringNullableFilter<"Coupon"> | string | null
    percentOff?: FloatFilter<"Coupon"> | number
    expiryDate?: DateTimeFilter<"Coupon"> | Date | string
    minAmount?: FloatFilter<"Coupon"> | number
    maxAmount?: FloatNullableFilter<"Coupon"> | number | null
    serviceId?: StringNullableFilter<"Coupon"> | string | null
    comboPlanId?: StringNullableFilter<"Coupon"> | string | null
    planDays?: IntNullableFilter<"Coupon"> | number | null
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    comboPlan?: XOR<ComboPlanNullableScalarRelationFilter, ComboPlanWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
    transactions?: TransactionListRelationFilter
  }

  export type CouponOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    percentOff?: SortOrder
    expiryDate?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    comboPlanId?: SortOrderInput | SortOrder
    planDays?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comboPlan?: ComboPlanOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type CouponWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: CouponWhereInput | CouponWhereInput[]
    OR?: CouponWhereInput[]
    NOT?: CouponWhereInput | CouponWhereInput[]
    description?: StringNullableFilter<"Coupon"> | string | null
    percentOff?: FloatFilter<"Coupon"> | number
    expiryDate?: DateTimeFilter<"Coupon"> | Date | string
    minAmount?: FloatFilter<"Coupon"> | number
    maxAmount?: FloatNullableFilter<"Coupon"> | number | null
    serviceId?: StringNullableFilter<"Coupon"> | string | null
    comboPlanId?: StringNullableFilter<"Coupon"> | string | null
    planDays?: IntNullableFilter<"Coupon"> | number | null
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
    comboPlan?: XOR<ComboPlanNullableScalarRelationFilter, ComboPlanWhereInput> | null
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
    transactions?: TransactionListRelationFilter
  }, "id" | "code">

  export type CouponOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    percentOff?: SortOrder
    expiryDate?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrderInput | SortOrder
    serviceId?: SortOrderInput | SortOrder
    comboPlanId?: SortOrderInput | SortOrder
    planDays?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CouponCountOrderByAggregateInput
    _avg?: CouponAvgOrderByAggregateInput
    _max?: CouponMaxOrderByAggregateInput
    _min?: CouponMinOrderByAggregateInput
    _sum?: CouponSumOrderByAggregateInput
  }

  export type CouponScalarWhereWithAggregatesInput = {
    AND?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    OR?: CouponScalarWhereWithAggregatesInput[]
    NOT?: CouponScalarWhereWithAggregatesInput | CouponScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Coupon"> | string
    code?: StringWithAggregatesFilter<"Coupon"> | string
    description?: StringNullableWithAggregatesFilter<"Coupon"> | string | null
    percentOff?: FloatWithAggregatesFilter<"Coupon"> | number
    expiryDate?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    minAmount?: FloatWithAggregatesFilter<"Coupon"> | number
    maxAmount?: FloatNullableWithAggregatesFilter<"Coupon"> | number | null
    serviceId?: StringNullableWithAggregatesFilter<"Coupon"> | string | null
    comboPlanId?: StringNullableWithAggregatesFilter<"Coupon"> | string | null
    planDays?: IntNullableWithAggregatesFilter<"Coupon"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Coupon"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    orderId?: StringNullableFilter<"Transaction"> | string | null
    paymentId?: StringNullableFilter<"Transaction"> | string | null
    couponId?: StringNullableFilter<"Transaction"> | string | null
    userId?: StringFilter<"Transaction"> | string
    serviceId?: StringNullableFilter<"Transaction"> | string | null
    comboPlanId?: StringNullableFilter<"Transaction"> | string | null
    amount?: FloatFilter<"Transaction"> | number
    tenure?: JsonNullableFilter<"Transaction">
    currency?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    paymentGateway?: StringFilter<"Transaction"> | string
    idempotencyKey?: StringNullableFilter<"Transaction"> | string | null
    webhookResponse?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    extraData?: JsonNullableFilter<"Transaction">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
    comboPlan?: XOR<ComboPlanNullableScalarRelationFilter, ComboPlanWhereInput> | null
    coupon?: XOR<CouponNullableScalarRelationFilter, CouponWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    couponId?: SortOrderInput | SortOrder
    userId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    comboPlanId?: SortOrderInput | SortOrder
    amount?: SortOrder
    tenure?: SortOrderInput | SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentGateway?: SortOrder
    idempotencyKey?: SortOrderInput | SortOrder
    webhookResponse?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    extraData?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    comboPlan?: ComboPlanOrderByWithRelationInput
    coupon?: CouponOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    paymentId?: StringNullableFilter<"Transaction"> | string | null
    couponId?: StringNullableFilter<"Transaction"> | string | null
    userId?: StringFilter<"Transaction"> | string
    serviceId?: StringNullableFilter<"Transaction"> | string | null
    comboPlanId?: StringNullableFilter<"Transaction"> | string | null
    amount?: FloatFilter<"Transaction"> | number
    tenure?: JsonNullableFilter<"Transaction">
    currency?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    paymentGateway?: StringFilter<"Transaction"> | string
    idempotencyKey?: StringNullableFilter<"Transaction"> | string | null
    webhookResponse?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    extraData?: JsonNullableFilter<"Transaction">
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
    comboPlan?: XOR<ComboPlanNullableScalarRelationFilter, ComboPlanWhereInput> | null
    coupon?: XOR<CouponNullableScalarRelationFilter, CouponWhereInput> | null
  }, "id" | "orderId">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    couponId?: SortOrderInput | SortOrder
    userId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    comboPlanId?: SortOrderInput | SortOrder
    amount?: SortOrder
    tenure?: SortOrderInput | SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentGateway?: SortOrder
    idempotencyKey?: SortOrderInput | SortOrder
    webhookResponse?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    extraData?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    orderId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    paymentId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    couponId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    userId?: StringWithAggregatesFilter<"Transaction"> | string
    serviceId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    comboPlanId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    tenure?: JsonNullableWithAggregatesFilter<"Transaction">
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    status?: StringWithAggregatesFilter<"Transaction"> | string
    paymentGateway?: StringWithAggregatesFilter<"Transaction"> | string
    idempotencyKey?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    webhookResponse?: JsonNullableWithAggregatesFilter<"Transaction">
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    extraData?: JsonNullableWithAggregatesFilter<"Transaction">
  }

  export type UserDocumentsWhereInput = {
    AND?: UserDocumentsWhereInput | UserDocumentsWhereInput[]
    OR?: UserDocumentsWhereInput[]
    NOT?: UserDocumentsWhereInput | UserDocumentsWhereInput[]
    id?: StringFilter<"UserDocuments"> | string
    serviceId?: StringFilter<"UserDocuments"> | string
    userId?: StringFilter<"UserDocuments"> | string
    documentUrl?: StringFilter<"UserDocuments"> | string
    reviewedDocumentUrl?: StringNullableFilter<"UserDocuments"> | string | null
    status?: EnumDocumentStatusFilter<"UserDocuments"> | $Enums.DocumentStatus
    reviewedBy?: StringNullableFilter<"UserDocuments"> | string | null
    createdAt?: DateTimeFilter<"UserDocuments"> | Date | string
    updatedAt?: DateTimeFilter<"UserDocuments"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }

  export type UserDocumentsOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
    documentUrl?: SortOrder
    reviewedDocumentUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type UserDocumentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserDocumentsWhereInput | UserDocumentsWhereInput[]
    OR?: UserDocumentsWhereInput[]
    NOT?: UserDocumentsWhereInput | UserDocumentsWhereInput[]
    serviceId?: StringFilter<"UserDocuments"> | string
    userId?: StringFilter<"UserDocuments"> | string
    documentUrl?: StringFilter<"UserDocuments"> | string
    reviewedDocumentUrl?: StringNullableFilter<"UserDocuments"> | string | null
    status?: EnumDocumentStatusFilter<"UserDocuments"> | $Enums.DocumentStatus
    reviewedBy?: StringNullableFilter<"UserDocuments"> | string | null
    createdAt?: DateTimeFilter<"UserDocuments"> | Date | string
    updatedAt?: DateTimeFilter<"UserDocuments"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }, "id">

  export type UserDocumentsOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
    documentUrl?: SortOrder
    reviewedDocumentUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserDocumentsCountOrderByAggregateInput
    _max?: UserDocumentsMaxOrderByAggregateInput
    _min?: UserDocumentsMinOrderByAggregateInput
  }

  export type UserDocumentsScalarWhereWithAggregatesInput = {
    AND?: UserDocumentsScalarWhereWithAggregatesInput | UserDocumentsScalarWhereWithAggregatesInput[]
    OR?: UserDocumentsScalarWhereWithAggregatesInput[]
    NOT?: UserDocumentsScalarWhereWithAggregatesInput | UserDocumentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserDocuments"> | string
    serviceId?: StringWithAggregatesFilter<"UserDocuments"> | string
    userId?: StringWithAggregatesFilter<"UserDocuments"> | string
    documentUrl?: StringWithAggregatesFilter<"UserDocuments"> | string
    reviewedDocumentUrl?: StringNullableWithAggregatesFilter<"UserDocuments"> | string | null
    status?: EnumDocumentStatusWithAggregatesFilter<"UserDocuments"> | $Enums.DocumentStatus
    reviewedBy?: StringNullableWithAggregatesFilter<"UserDocuments"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserDocuments"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserDocuments"> | Date | string
  }

  export type AgreementWhereInput = {
    AND?: AgreementWhereInput | AgreementWhereInput[]
    OR?: AgreementWhereInput[]
    NOT?: AgreementWhereInput | AgreementWhereInput[]
    id?: StringFilter<"Agreement"> | string
    name?: StringFilter<"Agreement"> | string
    content?: JsonFilter<"Agreement">
    version?: IntFilter<"Agreement"> | number
    hash?: StringFilter<"Agreement"> | string
    signatoryPerson?: StringNullableFilter<"Agreement"> | string | null
    companyName?: StringNullableFilter<"Agreement"> | string | null
    updatedAt?: DateTimeFilter<"Agreement"> | Date | string
    createdAt?: DateTimeFilter<"Agreement"> | Date | string
    serviceAgreements?: ServiceAgreementListRelationFilter
    comboPlanAgreements?: ComboPlanAgreementListRelationFilter
  }

  export type AgreementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    version?: SortOrder
    hash?: SortOrder
    signatoryPerson?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    serviceAgreements?: ServiceAgreementOrderByRelationAggregateInput
    comboPlanAgreements?: ComboPlanAgreementOrderByRelationAggregateInput
  }

  export type AgreementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgreementWhereInput | AgreementWhereInput[]
    OR?: AgreementWhereInput[]
    NOT?: AgreementWhereInput | AgreementWhereInput[]
    name?: StringFilter<"Agreement"> | string
    content?: JsonFilter<"Agreement">
    version?: IntFilter<"Agreement"> | number
    hash?: StringFilter<"Agreement"> | string
    signatoryPerson?: StringNullableFilter<"Agreement"> | string | null
    companyName?: StringNullableFilter<"Agreement"> | string | null
    updatedAt?: DateTimeFilter<"Agreement"> | Date | string
    createdAt?: DateTimeFilter<"Agreement"> | Date | string
    serviceAgreements?: ServiceAgreementListRelationFilter
    comboPlanAgreements?: ComboPlanAgreementListRelationFilter
  }, "id">

  export type AgreementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    version?: SortOrder
    hash?: SortOrder
    signatoryPerson?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: AgreementCountOrderByAggregateInput
    _avg?: AgreementAvgOrderByAggregateInput
    _max?: AgreementMaxOrderByAggregateInput
    _min?: AgreementMinOrderByAggregateInput
    _sum?: AgreementSumOrderByAggregateInput
  }

  export type AgreementScalarWhereWithAggregatesInput = {
    AND?: AgreementScalarWhereWithAggregatesInput | AgreementScalarWhereWithAggregatesInput[]
    OR?: AgreementScalarWhereWithAggregatesInput[]
    NOT?: AgreementScalarWhereWithAggregatesInput | AgreementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agreement"> | string
    name?: StringWithAggregatesFilter<"Agreement"> | string
    content?: JsonWithAggregatesFilter<"Agreement">
    version?: IntWithAggregatesFilter<"Agreement"> | number
    hash?: StringWithAggregatesFilter<"Agreement"> | string
    signatoryPerson?: StringNullableWithAggregatesFilter<"Agreement"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"Agreement"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Agreement"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Agreement"> | Date | string
  }

  export type ServiceAgreementWhereInput = {
    AND?: ServiceAgreementWhereInput | ServiceAgreementWhereInput[]
    OR?: ServiceAgreementWhereInput[]
    NOT?: ServiceAgreementWhereInput | ServiceAgreementWhereInput[]
    id?: StringFilter<"ServiceAgreement"> | string
    serviceId?: StringFilter<"ServiceAgreement"> | string
    agreementId?: StringFilter<"ServiceAgreement"> | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    agreement?: XOR<AgreementScalarRelationFilter, AgreementWhereInput>
  }

  export type ServiceAgreementOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    agreementId?: SortOrder
    service?: ServiceOrderByWithRelationInput
    agreement?: AgreementOrderByWithRelationInput
  }

  export type ServiceAgreementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceAgreementWhereInput | ServiceAgreementWhereInput[]
    OR?: ServiceAgreementWhereInput[]
    NOT?: ServiceAgreementWhereInput | ServiceAgreementWhereInput[]
    serviceId?: StringFilter<"ServiceAgreement"> | string
    agreementId?: StringFilter<"ServiceAgreement"> | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    agreement?: XOR<AgreementScalarRelationFilter, AgreementWhereInput>
  }, "id">

  export type ServiceAgreementOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    agreementId?: SortOrder
    _count?: ServiceAgreementCountOrderByAggregateInput
    _max?: ServiceAgreementMaxOrderByAggregateInput
    _min?: ServiceAgreementMinOrderByAggregateInput
  }

  export type ServiceAgreementScalarWhereWithAggregatesInput = {
    AND?: ServiceAgreementScalarWhereWithAggregatesInput | ServiceAgreementScalarWhereWithAggregatesInput[]
    OR?: ServiceAgreementScalarWhereWithAggregatesInput[]
    NOT?: ServiceAgreementScalarWhereWithAggregatesInput | ServiceAgreementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceAgreement"> | string
    serviceId?: StringWithAggregatesFilter<"ServiceAgreement"> | string
    agreementId?: StringWithAggregatesFilter<"ServiceAgreement"> | string
  }

  export type ComboPlanAgreementWhereInput = {
    AND?: ComboPlanAgreementWhereInput | ComboPlanAgreementWhereInput[]
    OR?: ComboPlanAgreementWhereInput[]
    NOT?: ComboPlanAgreementWhereInput | ComboPlanAgreementWhereInput[]
    id?: StringFilter<"ComboPlanAgreement"> | string
    comboPlanId?: StringFilter<"ComboPlanAgreement"> | string
    agreementId?: StringFilter<"ComboPlanAgreement"> | string
    comboPlan?: XOR<ComboPlanScalarRelationFilter, ComboPlanWhereInput>
    agreement?: XOR<AgreementScalarRelationFilter, AgreementWhereInput>
  }

  export type ComboPlanAgreementOrderByWithRelationInput = {
    id?: SortOrder
    comboPlanId?: SortOrder
    agreementId?: SortOrder
    comboPlan?: ComboPlanOrderByWithRelationInput
    agreement?: AgreementOrderByWithRelationInput
  }

  export type ComboPlanAgreementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComboPlanAgreementWhereInput | ComboPlanAgreementWhereInput[]
    OR?: ComboPlanAgreementWhereInput[]
    NOT?: ComboPlanAgreementWhereInput | ComboPlanAgreementWhereInput[]
    comboPlanId?: StringFilter<"ComboPlanAgreement"> | string
    agreementId?: StringFilter<"ComboPlanAgreement"> | string
    comboPlan?: XOR<ComboPlanScalarRelationFilter, ComboPlanWhereInput>
    agreement?: XOR<AgreementScalarRelationFilter, AgreementWhereInput>
  }, "id">

  export type ComboPlanAgreementOrderByWithAggregationInput = {
    id?: SortOrder
    comboPlanId?: SortOrder
    agreementId?: SortOrder
    _count?: ComboPlanAgreementCountOrderByAggregateInput
    _max?: ComboPlanAgreementMaxOrderByAggregateInput
    _min?: ComboPlanAgreementMinOrderByAggregateInput
  }

  export type ComboPlanAgreementScalarWhereWithAggregatesInput = {
    AND?: ComboPlanAgreementScalarWhereWithAggregatesInput | ComboPlanAgreementScalarWhereWithAggregatesInput[]
    OR?: ComboPlanAgreementScalarWhereWithAggregatesInput[]
    NOT?: ComboPlanAgreementScalarWhereWithAggregatesInput | ComboPlanAgreementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComboPlanAgreement"> | string
    comboPlanId?: StringWithAggregatesFilter<"ComboPlanAgreement"> | string
    agreementId?: StringWithAggregatesFilter<"ComboPlanAgreement"> | string
  }

  export type ComboPlanWhereInput = {
    AND?: ComboPlanWhereInput | ComboPlanWhereInput[]
    OR?: ComboPlanWhereInput[]
    NOT?: ComboPlanWhereInput | ComboPlanWhereInput[]
    id?: StringFilter<"ComboPlan"> | string
    name?: StringFilter<"ComboPlan"> | string
    description?: StringNullableFilter<"ComboPlan"> | string | null
    price?: FloatFilter<"ComboPlan"> | number
    taxPercent?: FloatNullableFilter<"ComboPlan"> | number | null
    active?: BoolNullableFilter<"ComboPlan"> | boolean | null
    tenureDiscounts?: JsonFilter<"ComboPlan">
    createdAt?: DateTimeFilter<"ComboPlan"> | Date | string
    updatedAt?: DateTimeFilter<"ComboPlan"> | Date | string
    agreement?: ComboPlanAgreementListRelationFilter
    services?: ComboPlanServiceListRelationFilter
    coupon?: CouponListRelationFilter
    Transaction?: TransactionListRelationFilter
  }

  export type ComboPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    taxPercent?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    tenureDiscounts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agreement?: ComboPlanAgreementOrderByRelationAggregateInput
    services?: ComboPlanServiceOrderByRelationAggregateInput
    coupon?: CouponOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
  }

  export type ComboPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComboPlanWhereInput | ComboPlanWhereInput[]
    OR?: ComboPlanWhereInput[]
    NOT?: ComboPlanWhereInput | ComboPlanWhereInput[]
    name?: StringFilter<"ComboPlan"> | string
    description?: StringNullableFilter<"ComboPlan"> | string | null
    price?: FloatFilter<"ComboPlan"> | number
    taxPercent?: FloatNullableFilter<"ComboPlan"> | number | null
    active?: BoolNullableFilter<"ComboPlan"> | boolean | null
    tenureDiscounts?: JsonFilter<"ComboPlan">
    createdAt?: DateTimeFilter<"ComboPlan"> | Date | string
    updatedAt?: DateTimeFilter<"ComboPlan"> | Date | string
    agreement?: ComboPlanAgreementListRelationFilter
    services?: ComboPlanServiceListRelationFilter
    coupon?: CouponListRelationFilter
    Transaction?: TransactionListRelationFilter
  }, "id">

  export type ComboPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    taxPercent?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    tenureDiscounts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComboPlanCountOrderByAggregateInput
    _avg?: ComboPlanAvgOrderByAggregateInput
    _max?: ComboPlanMaxOrderByAggregateInput
    _min?: ComboPlanMinOrderByAggregateInput
    _sum?: ComboPlanSumOrderByAggregateInput
  }

  export type ComboPlanScalarWhereWithAggregatesInput = {
    AND?: ComboPlanScalarWhereWithAggregatesInput | ComboPlanScalarWhereWithAggregatesInput[]
    OR?: ComboPlanScalarWhereWithAggregatesInput[]
    NOT?: ComboPlanScalarWhereWithAggregatesInput | ComboPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComboPlan"> | string
    name?: StringWithAggregatesFilter<"ComboPlan"> | string
    description?: StringNullableWithAggregatesFilter<"ComboPlan"> | string | null
    price?: FloatWithAggregatesFilter<"ComboPlan"> | number
    taxPercent?: FloatNullableWithAggregatesFilter<"ComboPlan"> | number | null
    active?: BoolNullableWithAggregatesFilter<"ComboPlan"> | boolean | null
    tenureDiscounts?: JsonWithAggregatesFilter<"ComboPlan">
    createdAt?: DateTimeWithAggregatesFilter<"ComboPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComboPlan"> | Date | string
  }

  export type ComboPlanServiceWhereInput = {
    AND?: ComboPlanServiceWhereInput | ComboPlanServiceWhereInput[]
    OR?: ComboPlanServiceWhereInput[]
    NOT?: ComboPlanServiceWhereInput | ComboPlanServiceWhereInput[]
    id?: StringFilter<"ComboPlanService"> | string
    comboPlanId?: StringFilter<"ComboPlanService"> | string
    serviceId?: StringFilter<"ComboPlanService"> | string
    comboPlan?: XOR<ComboPlanScalarRelationFilter, ComboPlanWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type ComboPlanServiceOrderByWithRelationInput = {
    id?: SortOrder
    comboPlanId?: SortOrder
    serviceId?: SortOrder
    comboPlan?: ComboPlanOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type ComboPlanServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComboPlanServiceWhereInput | ComboPlanServiceWhereInput[]
    OR?: ComboPlanServiceWhereInput[]
    NOT?: ComboPlanServiceWhereInput | ComboPlanServiceWhereInput[]
    comboPlanId?: StringFilter<"ComboPlanService"> | string
    serviceId?: StringFilter<"ComboPlanService"> | string
    comboPlan?: XOR<ComboPlanScalarRelationFilter, ComboPlanWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id">

  export type ComboPlanServiceOrderByWithAggregationInput = {
    id?: SortOrder
    comboPlanId?: SortOrder
    serviceId?: SortOrder
    _count?: ComboPlanServiceCountOrderByAggregateInput
    _max?: ComboPlanServiceMaxOrderByAggregateInput
    _min?: ComboPlanServiceMinOrderByAggregateInput
  }

  export type ComboPlanServiceScalarWhereWithAggregatesInput = {
    AND?: ComboPlanServiceScalarWhereWithAggregatesInput | ComboPlanServiceScalarWhereWithAggregatesInput[]
    OR?: ComboPlanServiceScalarWhereWithAggregatesInput[]
    NOT?: ComboPlanServiceScalarWhereWithAggregatesInput | ComboPlanServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComboPlanService"> | string
    comboPlanId?: StringWithAggregatesFilter<"ComboPlanService"> | string
    serviceId?: StringWithAggregatesFilter<"ComboPlanService"> | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    slug?: StringFilter<"Service"> | string
    tag?: StringNullableFilter<"Service"> | string | null
    label?: StringNullableFilter<"Service"> | string | null
    serviceClass?: StringNullableFilter<"Service"> | string | null
    description?: StringNullableFilter<"Service"> | string | null
    chart?: JsonNullableFilter<"Service">
    comparisonTitle?: StringNullableFilter<"Service"> | string | null
    recommendation?: StringNullableListFilter<"Service">
    price?: StringNullableFilter<"Service"> | string | null
    taxPercent?: FloatNullableFilter<"Service"> | number | null
    tenureDiscounts?: JsonNullableFilter<"Service">
    features?: JsonNullableFilter<"Service">
    faq?: JsonNullableFilter<"Service">
    active?: BoolNullableFilter<"Service"> | boolean | null
    type?: EnumServiceTypeFilter<"Service"> | $Enums.ServiceType
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    agreements?: ServiceAgreementListRelationFilter
    serviceTrading?: XOR<ServiceTradingNullableScalarRelationFilter, ServiceTradingWhereInput> | null
    purchasedServices?: UserPurchasedServicesListRelationFilter
    userDocuments?: UserDocumentsListRelationFilter
    Transaction?: TransactionListRelationFilter
    ComboPlanService?: ComboPlanServiceListRelationFilter
    coupon?: CouponListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    tag?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    serviceClass?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    chart?: SortOrderInput | SortOrder
    comparisonTitle?: SortOrderInput | SortOrder
    recommendation?: SortOrder
    price?: SortOrderInput | SortOrder
    taxPercent?: SortOrderInput | SortOrder
    tenureDiscounts?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    faq?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agreements?: ServiceAgreementOrderByRelationAggregateInput
    serviceTrading?: ServiceTradingOrderByWithRelationInput
    purchasedServices?: UserPurchasedServicesOrderByRelationAggregateInput
    userDocuments?: UserDocumentsOrderByRelationAggregateInput
    Transaction?: TransactionOrderByRelationAggregateInput
    ComboPlanService?: ComboPlanServiceOrderByRelationAggregateInput
    coupon?: CouponOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    tag?: StringNullableFilter<"Service"> | string | null
    label?: StringNullableFilter<"Service"> | string | null
    serviceClass?: StringNullableFilter<"Service"> | string | null
    description?: StringNullableFilter<"Service"> | string | null
    chart?: JsonNullableFilter<"Service">
    comparisonTitle?: StringNullableFilter<"Service"> | string | null
    recommendation?: StringNullableListFilter<"Service">
    price?: StringNullableFilter<"Service"> | string | null
    taxPercent?: FloatNullableFilter<"Service"> | number | null
    tenureDiscounts?: JsonNullableFilter<"Service">
    features?: JsonNullableFilter<"Service">
    faq?: JsonNullableFilter<"Service">
    active?: BoolNullableFilter<"Service"> | boolean | null
    type?: EnumServiceTypeFilter<"Service"> | $Enums.ServiceType
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    agreements?: ServiceAgreementListRelationFilter
    serviceTrading?: XOR<ServiceTradingNullableScalarRelationFilter, ServiceTradingWhereInput> | null
    purchasedServices?: UserPurchasedServicesListRelationFilter
    userDocuments?: UserDocumentsListRelationFilter
    Transaction?: TransactionListRelationFilter
    ComboPlanService?: ComboPlanServiceListRelationFilter
    coupon?: CouponListRelationFilter
  }, "id" | "slug">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    tag?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    serviceClass?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    chart?: SortOrderInput | SortOrder
    comparisonTitle?: SortOrderInput | SortOrder
    recommendation?: SortOrder
    price?: SortOrderInput | SortOrder
    taxPercent?: SortOrderInput | SortOrder
    tenureDiscounts?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    faq?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    slug?: StringWithAggregatesFilter<"Service"> | string
    tag?: StringNullableWithAggregatesFilter<"Service"> | string | null
    label?: StringNullableWithAggregatesFilter<"Service"> | string | null
    serviceClass?: StringNullableWithAggregatesFilter<"Service"> | string | null
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    chart?: JsonNullableWithAggregatesFilter<"Service">
    comparisonTitle?: StringNullableWithAggregatesFilter<"Service"> | string | null
    recommendation?: StringNullableListFilter<"Service">
    price?: StringNullableWithAggregatesFilter<"Service"> | string | null
    taxPercent?: FloatNullableWithAggregatesFilter<"Service"> | number | null
    tenureDiscounts?: JsonNullableWithAggregatesFilter<"Service">
    features?: JsonNullableWithAggregatesFilter<"Service">
    faq?: JsonNullableWithAggregatesFilter<"Service">
    active?: BoolNullableWithAggregatesFilter<"Service"> | boolean | null
    type?: EnumServiceTypeWithAggregatesFilter<"Service"> | $Enums.ServiceType
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type ServiceTradingWhereInput = {
    AND?: ServiceTradingWhereInput | ServiceTradingWhereInput[]
    OR?: ServiceTradingWhereInput[]
    NOT?: ServiceTradingWhereInput | ServiceTradingWhereInput[]
    id?: StringFilter<"ServiceTrading"> | string
    buy_stock_list?: JsonFilter<"ServiceTrading">
    sell_stock_list?: JsonFilter<"ServiceTrading">
    createdAt?: DateTimeFilter<"ServiceTrading"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTrading"> | Date | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type ServiceTradingOrderByWithRelationInput = {
    id?: SortOrder
    buy_stock_list?: SortOrder
    sell_stock_list?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
  }

  export type ServiceTradingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceTradingWhereInput | ServiceTradingWhereInput[]
    OR?: ServiceTradingWhereInput[]
    NOT?: ServiceTradingWhereInput | ServiceTradingWhereInput[]
    buy_stock_list?: JsonFilter<"ServiceTrading">
    sell_stock_list?: JsonFilter<"ServiceTrading">
    createdAt?: DateTimeFilter<"ServiceTrading"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTrading"> | Date | string
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id">

  export type ServiceTradingOrderByWithAggregationInput = {
    id?: SortOrder
    buy_stock_list?: SortOrder
    sell_stock_list?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceTradingCountOrderByAggregateInput
    _max?: ServiceTradingMaxOrderByAggregateInput
    _min?: ServiceTradingMinOrderByAggregateInput
  }

  export type ServiceTradingScalarWhereWithAggregatesInput = {
    AND?: ServiceTradingScalarWhereWithAggregatesInput | ServiceTradingScalarWhereWithAggregatesInput[]
    OR?: ServiceTradingScalarWhereWithAggregatesInput[]
    NOT?: ServiceTradingScalarWhereWithAggregatesInput | ServiceTradingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceTrading"> | string
    buy_stock_list?: JsonWithAggregatesFilter<"ServiceTrading">
    sell_stock_list?: JsonWithAggregatesFilter<"ServiceTrading">
    createdAt?: DateTimeWithAggregatesFilter<"ServiceTrading"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceTrading"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    phone?: string | null
    username?: string | null
    image?: string | null
    password?: string | null
    dob?: string | null
    pan?: string | null
    aadharNumber?: string | null
    gstin?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    zip?: string | null
    panVerified?: Date | string | null
    termsAccepted?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    isBanned?: boolean
    userType?: $Enums.UserType
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    documents?: UserDocumentsCreateNestedManyWithoutUserInput
    purchasedServices?: UserPurchasedServicesCreateNestedManyWithoutUserInput
    panVerificationData?: panVerificationDataCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    phone?: string | null
    username?: string | null
    image?: string | null
    password?: string | null
    dob?: string | null
    pan?: string | null
    aadharNumber?: string | null
    gstin?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    zip?: string | null
    panVerified?: Date | string | null
    termsAccepted?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    isBanned?: boolean
    userType?: $Enums.UserType
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    documents?: UserDocumentsUncheckedCreateNestedManyWithoutUserInput
    purchasedServices?: UserPurchasedServicesUncheckedCreateNestedManyWithoutUserInput
    panVerificationData?: panVerificationDataUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    panVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    documents?: UserDocumentsUpdateManyWithoutUserNestedInput
    purchasedServices?: UserPurchasedServicesUpdateManyWithoutUserNestedInput
    panVerificationData?: panVerificationDataUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    panVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    documents?: UserDocumentsUncheckedUpdateManyWithoutUserNestedInput
    purchasedServices?: UserPurchasedServicesUncheckedUpdateManyWithoutUserNestedInput
    panVerificationData?: panVerificationDataUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    phone?: string | null
    username?: string | null
    image?: string | null
    password?: string | null
    dob?: string | null
    pan?: string | null
    aadharNumber?: string | null
    gstin?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    zip?: string | null
    panVerified?: Date | string | null
    termsAccepted?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    isBanned?: boolean
    userType?: $Enums.UserType
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    panVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    panVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateInput = {
    id?: string
    userId: string
    identifier: string
    otp: string
    expires_at: Date | string
    verificationType: $Enums.VerificationType
    createdAt?: Date | string
  }

  export type OtpUncheckedCreateInput = {
    id?: string
    userId: string
    identifier: string
    otp: string
    expires_at: Date | string
    verificationType: $Enums.VerificationType
    createdAt?: Date | string
  }

  export type OtpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationType?: EnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationType?: EnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateManyInput = {
    id?: string
    userId: string
    identifier: string
    otp: string
    expires_at: Date | string
    verificationType: $Enums.VerificationType
    createdAt?: Date | string
  }

  export type OtpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationType?: EnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    verificationType?: EnumVerificationTypeFieldUpdateOperationsInput | $Enums.VerificationType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type panVerificationDataCreateInput = {
    provider: string
    result: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPanVerificationDataInput
  }

  export type panVerificationDataUncheckedCreateInput = {
    userId: string
    provider: string
    result: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type panVerificationDataUpdateInput = {
    provider?: StringFieldUpdateOperationsInput | string
    result?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPanVerificationDataNestedInput
  }

  export type panVerificationDataUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    result?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type panVerificationDataCreateManyInput = {
    userId: string
    provider: string
    result: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type panVerificationDataUpdateManyMutationInput = {
    provider?: StringFieldUpdateOperationsInput | string
    result?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type panVerificationDataUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    result?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPurchasedServicesCreateInput = {
    id?: string
    purchaseDate?: Date | string
    expiryDate: Date | string
    planDays: number
    planDiscount: number
    agreementAcceptedAt?: Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutPurchasedServicesInput
    service: ServiceCreateNestedOneWithoutPurchasedServicesInput
  }

  export type UserPurchasedServicesUncheckedCreateInput = {
    id?: string
    userId: string
    serviceId: string
    purchaseDate?: Date | string
    expiryDate: Date | string
    planDays: number
    planDiscount: number
    agreementAcceptedAt?: Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPurchasedServicesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planDays?: IntFieldUpdateOperationsInput | number
    planDiscount?: FloatFieldUpdateOperationsInput | number
    agreementAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutPurchasedServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutPurchasedServicesNestedInput
  }

  export type UserPurchasedServicesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planDays?: IntFieldUpdateOperationsInput | number
    planDiscount?: FloatFieldUpdateOperationsInput | number
    agreementAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPurchasedServicesCreateManyInput = {
    id?: string
    userId: string
    serviceId: string
    purchaseDate?: Date | string
    expiryDate: Date | string
    planDays: number
    planDiscount: number
    agreementAcceptedAt?: Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPurchasedServicesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planDays?: IntFieldUpdateOperationsInput | number
    planDiscount?: FloatFieldUpdateOperationsInput | number
    agreementAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPurchasedServicesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planDays?: IntFieldUpdateOperationsInput | number
    planDiscount?: FloatFieldUpdateOperationsInput | number
    agreementAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CouponCreateInput = {
    id?: string
    code: string
    description?: string | null
    percentOff: number
    expiryDate: Date | string
    minAmount?: number
    maxAmount?: number | null
    planDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comboPlan?: ComboPlanCreateNestedOneWithoutCouponInput
    service?: ServiceCreateNestedOneWithoutCouponInput
    transactions?: TransactionCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateInput = {
    id?: string
    code: string
    description?: string | null
    percentOff: number
    expiryDate: Date | string
    minAmount?: number
    maxAmount?: number | null
    serviceId?: string | null
    comboPlanId?: string | null
    planDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: FloatFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    planDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comboPlan?: ComboPlanUpdateOneWithoutCouponNestedInput
    service?: ServiceUpdateOneWithoutCouponNestedInput
    transactions?: TransactionUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: FloatFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    comboPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    planDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponCreateManyInput = {
    id?: string
    code: string
    description?: string | null
    percentOff: number
    expiryDate: Date | string
    minAmount?: number
    maxAmount?: number | null
    serviceId?: string | null
    comboPlanId?: string | null
    planDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: FloatFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    planDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CouponUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: FloatFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    comboPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    planDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutTransactionInput
    service?: ServiceCreateNestedOneWithoutTransactionInput
    comboPlan?: ComboPlanCreateNestedOneWithoutTransactionInput
    coupon?: CouponCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    couponId?: string | null
    userId: string
    serviceId?: string | null
    comboPlanId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutTransactionNestedInput
    service?: ServiceUpdateOneWithoutTransactionNestedInput
    comboPlan?: ComboPlanUpdateOneWithoutTransactionNestedInput
    coupon?: CouponUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    comboPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionCreateManyInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    couponId?: string | null
    userId: string
    serviceId?: string | null
    comboPlanId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    comboPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserDocumentsCreateInput = {
    id?: string
    documentUrl: string
    reviewedDocumentUrl?: string | null
    status?: $Enums.DocumentStatus
    reviewedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
    service?: ServiceCreateNestedOneWithoutUserDocumentsInput
  }

  export type UserDocumentsUncheckedCreateInput = {
    id?: string
    serviceId: string
    userId: string
    documentUrl: string
    reviewedDocumentUrl?: string | null
    status?: $Enums.DocumentStatus
    reviewedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDocumentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    reviewedDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    service?: ServiceUpdateOneWithoutUserDocumentsNestedInput
  }

  export type UserDocumentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    reviewedDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDocumentsCreateManyInput = {
    id?: string
    serviceId: string
    userId: string
    documentUrl: string
    reviewedDocumentUrl?: string | null
    status?: $Enums.DocumentStatus
    reviewedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDocumentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    reviewedDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDocumentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    reviewedDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementCreateInput = {
    id?: string
    name: string
    content: JsonNullValueInput | InputJsonValue
    version: number
    hash: string
    signatoryPerson?: string | null
    companyName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    serviceAgreements?: ServiceAgreementCreateNestedManyWithoutAgreementInput
    comboPlanAgreements?: ComboPlanAgreementCreateNestedManyWithoutAgreementInput
  }

  export type AgreementUncheckedCreateInput = {
    id?: string
    name: string
    content: JsonNullValueInput | InputJsonValue
    version: number
    hash: string
    signatoryPerson?: string | null
    companyName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    serviceAgreements?: ServiceAgreementUncheckedCreateNestedManyWithoutAgreementInput
    comboPlanAgreements?: ComboPlanAgreementUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type AgreementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    hash?: StringFieldUpdateOperationsInput | string
    signatoryPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceAgreements?: ServiceAgreementUpdateManyWithoutAgreementNestedInput
    comboPlanAgreements?: ComboPlanAgreementUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    hash?: StringFieldUpdateOperationsInput | string
    signatoryPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceAgreements?: ServiceAgreementUncheckedUpdateManyWithoutAgreementNestedInput
    comboPlanAgreements?: ComboPlanAgreementUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementCreateManyInput = {
    id?: string
    name: string
    content: JsonNullValueInput | InputJsonValue
    version: number
    hash: string
    signatoryPerson?: string | null
    companyName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type AgreementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    hash?: StringFieldUpdateOperationsInput | string
    signatoryPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgreementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    hash?: StringFieldUpdateOperationsInput | string
    signatoryPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAgreementCreateInput = {
    id?: string
    service: ServiceCreateNestedOneWithoutAgreementsInput
    agreement: AgreementCreateNestedOneWithoutServiceAgreementsInput
  }

  export type ServiceAgreementUncheckedCreateInput = {
    id?: string
    serviceId: string
    agreementId: string
  }

  export type ServiceAgreementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: ServiceUpdateOneRequiredWithoutAgreementsNestedInput
    agreement?: AgreementUpdateOneRequiredWithoutServiceAgreementsNestedInput
  }

  export type ServiceAgreementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    agreementId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceAgreementCreateManyInput = {
    id?: string
    serviceId: string
    agreementId: string
  }

  export type ServiceAgreementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceAgreementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    agreementId?: StringFieldUpdateOperationsInput | string
  }

  export type ComboPlanAgreementCreateInput = {
    id?: string
    comboPlan: ComboPlanCreateNestedOneWithoutAgreementInput
    agreement: AgreementCreateNestedOneWithoutComboPlanAgreementsInput
  }

  export type ComboPlanAgreementUncheckedCreateInput = {
    id?: string
    comboPlanId: string
    agreementId: string
  }

  export type ComboPlanAgreementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comboPlan?: ComboPlanUpdateOneRequiredWithoutAgreementNestedInput
    agreement?: AgreementUpdateOneRequiredWithoutComboPlanAgreementsNestedInput
  }

  export type ComboPlanAgreementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comboPlanId?: StringFieldUpdateOperationsInput | string
    agreementId?: StringFieldUpdateOperationsInput | string
  }

  export type ComboPlanAgreementCreateManyInput = {
    id?: string
    comboPlanId: string
    agreementId: string
  }

  export type ComboPlanAgreementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ComboPlanAgreementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    comboPlanId?: StringFieldUpdateOperationsInput | string
    agreementId?: StringFieldUpdateOperationsInput | string
  }

  export type ComboPlanCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    taxPercent?: number | null
    active?: boolean | null
    tenureDiscounts: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agreement?: ComboPlanAgreementCreateNestedManyWithoutComboPlanInput
    services?: ComboPlanServiceCreateNestedManyWithoutComboPlanInput
    coupon?: CouponCreateNestedManyWithoutComboPlanInput
    Transaction?: TransactionCreateNestedManyWithoutComboPlanInput
  }

  export type ComboPlanUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    taxPercent?: number | null
    active?: boolean | null
    tenureDiscounts: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agreement?: ComboPlanAgreementUncheckedCreateNestedManyWithoutComboPlanInput
    services?: ComboPlanServiceUncheckedCreateNestedManyWithoutComboPlanInput
    coupon?: CouponUncheckedCreateNestedManyWithoutComboPlanInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutComboPlanInput
  }

  export type ComboPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenureDiscounts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: ComboPlanAgreementUpdateManyWithoutComboPlanNestedInput
    services?: ComboPlanServiceUpdateManyWithoutComboPlanNestedInput
    coupon?: CouponUpdateManyWithoutComboPlanNestedInput
    Transaction?: TransactionUpdateManyWithoutComboPlanNestedInput
  }

  export type ComboPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenureDiscounts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: ComboPlanAgreementUncheckedUpdateManyWithoutComboPlanNestedInput
    services?: ComboPlanServiceUncheckedUpdateManyWithoutComboPlanNestedInput
    coupon?: CouponUncheckedUpdateManyWithoutComboPlanNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutComboPlanNestedInput
  }

  export type ComboPlanCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    taxPercent?: number | null
    active?: boolean | null
    tenureDiscounts: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComboPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenureDiscounts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComboPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenureDiscounts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComboPlanServiceCreateInput = {
    id?: string
    comboPlan: ComboPlanCreateNestedOneWithoutServicesInput
    service: ServiceCreateNestedOneWithoutComboPlanServiceInput
  }

  export type ComboPlanServiceUncheckedCreateInput = {
    id?: string
    comboPlanId: string
    serviceId: string
  }

  export type ComboPlanServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comboPlan?: ComboPlanUpdateOneRequiredWithoutServicesNestedInput
    service?: ServiceUpdateOneRequiredWithoutComboPlanServiceNestedInput
  }

  export type ComboPlanServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comboPlanId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ComboPlanServiceCreateManyInput = {
    id?: string
    comboPlanId: string
    serviceId: string
  }

  export type ComboPlanServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ComboPlanServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    comboPlanId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: ServiceAgreementCreateNestedManyWithoutServiceInput
    serviceTrading?: ServiceTradingCreateNestedOneWithoutServiceInput
    purchasedServices?: UserPurchasedServicesCreateNestedManyWithoutServiceInput
    userDocuments?: UserDocumentsCreateNestedManyWithoutServiceInput
    Transaction?: TransactionCreateNestedManyWithoutServiceInput
    ComboPlanService?: ComboPlanServiceCreateNestedManyWithoutServiceInput
    coupon?: CouponCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: ServiceAgreementUncheckedCreateNestedManyWithoutServiceInput
    serviceTrading?: ServiceTradingUncheckedCreateNestedOneWithoutServiceInput
    purchasedServices?: UserPurchasedServicesUncheckedCreateNestedManyWithoutServiceInput
    userDocuments?: UserDocumentsUncheckedCreateNestedManyWithoutServiceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutServiceInput
    ComboPlanService?: ComboPlanServiceUncheckedCreateNestedManyWithoutServiceInput
    coupon?: CouponUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: ServiceAgreementUpdateManyWithoutServiceNestedInput
    serviceTrading?: ServiceTradingUpdateOneWithoutServiceNestedInput
    purchasedServices?: UserPurchasedServicesUpdateManyWithoutServiceNestedInput
    userDocuments?: UserDocumentsUpdateManyWithoutServiceNestedInput
    Transaction?: TransactionUpdateManyWithoutServiceNestedInput
    ComboPlanService?: ComboPlanServiceUpdateManyWithoutServiceNestedInput
    coupon?: CouponUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: ServiceAgreementUncheckedUpdateManyWithoutServiceNestedInput
    serviceTrading?: ServiceTradingUncheckedUpdateOneWithoutServiceNestedInput
    purchasedServices?: UserPurchasedServicesUncheckedUpdateManyWithoutServiceNestedInput
    userDocuments?: UserDocumentsUncheckedUpdateManyWithoutServiceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutServiceNestedInput
    ComboPlanService?: ComboPlanServiceUncheckedUpdateManyWithoutServiceNestedInput
    coupon?: CouponUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTradingCreateInput = {
    buy_stock_list: JsonNullValueInput | InputJsonValue
    sell_stock_list: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutServiceTradingInput
  }

  export type ServiceTradingUncheckedCreateInput = {
    id: string
    buy_stock_list: JsonNullValueInput | InputJsonValue
    sell_stock_list: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTradingUpdateInput = {
    buy_stock_list?: JsonNullValueInput | InputJsonValue
    sell_stock_list?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutServiceTradingNestedInput
  }

  export type ServiceTradingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    buy_stock_list?: JsonNullValueInput | InputJsonValue
    sell_stock_list?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTradingCreateManyInput = {
    id: string
    buy_stock_list: JsonNullValueInput | InputJsonValue
    sell_stock_list: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTradingUpdateManyMutationInput = {
    buy_stock_list?: JsonNullValueInput | InputJsonValue
    sell_stock_list?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTradingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    buy_stock_list?: JsonNullValueInput | InputJsonValue
    sell_stock_list?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type UserDocumentsListRelationFilter = {
    every?: UserDocumentsWhereInput
    some?: UserDocumentsWhereInput
    none?: UserDocumentsWhereInput
  }

  export type UserPurchasedServicesListRelationFilter = {
    every?: UserPurchasedServicesWhereInput
    some?: UserPurchasedServicesWhereInput
    none?: UserPurchasedServicesWhereInput
  }

  export type PanVerificationDataListRelationFilter = {
    every?: panVerificationDataWhereInput
    some?: panVerificationDataWhereInput
    none?: panVerificationDataWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserDocumentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPurchasedServicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type panVerificationDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    username?: SortOrder
    image?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    pan?: SortOrder
    aadharNumber?: SortOrder
    gstin?: SortOrder
    address?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zip?: SortOrder
    panVerified?: SortOrder
    termsAccepted?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    isBanned?: SortOrder
    userType?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    username?: SortOrder
    image?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    pan?: SortOrder
    aadharNumber?: SortOrder
    gstin?: SortOrder
    address?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zip?: SortOrder
    panVerified?: SortOrder
    termsAccepted?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    isBanned?: SortOrder
    userType?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    username?: SortOrder
    image?: SortOrder
    password?: SortOrder
    dob?: SortOrder
    pan?: SortOrder
    aadharNumber?: SortOrder
    gstin?: SortOrder
    address?: SortOrder
    state?: SortOrder
    city?: SortOrder
    zip?: SortOrder
    panVerified?: SortOrder
    termsAccepted?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    isBanned?: SortOrder
    userType?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumVerificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationType | EnumVerificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationTypeFilter<$PrismaModel> | $Enums.VerificationType
  }

  export type OtpUserIdIdentifierVerificationTypeCompoundUniqueInput = {
    userId: string
    identifier: string
    verificationType: $Enums.VerificationType
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    identifier?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    verificationType?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    identifier?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    verificationType?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    identifier?: SortOrder
    otp?: SortOrder
    expires_at?: SortOrder
    verificationType?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumVerificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationType | EnumVerificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.VerificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationTypeFilter<$PrismaModel>
    _max?: NestedEnumVerificationTypeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type panVerificationDataCountOrderByAggregateInput = {
    userId?: SortOrder
    provider?: SortOrder
    result?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type panVerificationDataMaxOrderByAggregateInput = {
    userId?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type panVerificationDataMinOrderByAggregateInput = {
    userId?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type UserPurchasedServicesUserIdServiceIdExpiryDateCompoundUniqueInput = {
    userId: string
    serviceId: string
    expiryDate: Date | string
  }

  export type UserPurchasedServicesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    planDays?: SortOrder
    planDiscount?: SortOrder
    agreementAcceptedAt?: SortOrder
    agreementData?: SortOrder
  }

  export type UserPurchasedServicesAvgOrderByAggregateInput = {
    planDays?: SortOrder
    planDiscount?: SortOrder
  }

  export type UserPurchasedServicesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    planDays?: SortOrder
    planDiscount?: SortOrder
    agreementAcceptedAt?: SortOrder
  }

  export type UserPurchasedServicesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    purchaseDate?: SortOrder
    expiryDate?: SortOrder
    planDays?: SortOrder
    planDiscount?: SortOrder
    agreementAcceptedAt?: SortOrder
  }

  export type UserPurchasedServicesSumOrderByAggregateInput = {
    planDays?: SortOrder
    planDiscount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ComboPlanNullableScalarRelationFilter = {
    is?: ComboPlanWhereInput | null
    isNot?: ComboPlanWhereInput | null
  }

  export type ServiceNullableScalarRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type CouponCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    percentOff?: SortOrder
    expiryDate?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    serviceId?: SortOrder
    comboPlanId?: SortOrder
    planDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponAvgOrderByAggregateInput = {
    percentOff?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    planDays?: SortOrder
  }

  export type CouponMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    percentOff?: SortOrder
    expiryDate?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    serviceId?: SortOrder
    comboPlanId?: SortOrder
    planDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    description?: SortOrder
    percentOff?: SortOrder
    expiryDate?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    serviceId?: SortOrder
    comboPlanId?: SortOrder
    planDays?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CouponSumOrderByAggregateInput = {
    percentOff?: SortOrder
    minAmount?: SortOrder
    maxAmount?: SortOrder
    planDays?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type CouponNullableScalarRelationFilter = {
    is?: CouponWhereInput | null
    isNot?: CouponWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    comboPlanId?: SortOrder
    amount?: SortOrder
    tenure?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentGateway?: SortOrder
    idempotencyKey?: SortOrder
    webhookResponse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    extraData?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    comboPlanId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentGateway?: SortOrder
    idempotencyKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    paymentId?: SortOrder
    couponId?: SortOrder
    userId?: SortOrder
    serviceId?: SortOrder
    comboPlanId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentGateway?: SortOrder
    idempotencyKey?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type UserDocumentsCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
    documentUrl?: SortOrder
    reviewedDocumentUrl?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserDocumentsMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
    documentUrl?: SortOrder
    reviewedDocumentUrl?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserDocumentsMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    userId?: SortOrder
    documentUrl?: SortOrder
    reviewedDocumentUrl?: SortOrder
    status?: SortOrder
    reviewedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type ServiceAgreementListRelationFilter = {
    every?: ServiceAgreementWhereInput
    some?: ServiceAgreementWhereInput
    none?: ServiceAgreementWhereInput
  }

  export type ComboPlanAgreementListRelationFilter = {
    every?: ComboPlanAgreementWhereInput
    some?: ComboPlanAgreementWhereInput
    none?: ComboPlanAgreementWhereInput
  }

  export type ServiceAgreementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComboPlanAgreementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgreementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    version?: SortOrder
    hash?: SortOrder
    signatoryPerson?: SortOrder
    companyName?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AgreementAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type AgreementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    hash?: SortOrder
    signatoryPerson?: SortOrder
    companyName?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AgreementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    version?: SortOrder
    hash?: SortOrder
    signatoryPerson?: SortOrder
    companyName?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type AgreementSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type AgreementScalarRelationFilter = {
    is?: AgreementWhereInput
    isNot?: AgreementWhereInput
  }

  export type ServiceAgreementCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    agreementId?: SortOrder
  }

  export type ServiceAgreementMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    agreementId?: SortOrder
  }

  export type ServiceAgreementMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    agreementId?: SortOrder
  }

  export type ComboPlanScalarRelationFilter = {
    is?: ComboPlanWhereInput
    isNot?: ComboPlanWhereInput
  }

  export type ComboPlanAgreementCountOrderByAggregateInput = {
    id?: SortOrder
    comboPlanId?: SortOrder
    agreementId?: SortOrder
  }

  export type ComboPlanAgreementMaxOrderByAggregateInput = {
    id?: SortOrder
    comboPlanId?: SortOrder
    agreementId?: SortOrder
  }

  export type ComboPlanAgreementMinOrderByAggregateInput = {
    id?: SortOrder
    comboPlanId?: SortOrder
    agreementId?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ComboPlanServiceListRelationFilter = {
    every?: ComboPlanServiceWhereInput
    some?: ComboPlanServiceWhereInput
    none?: ComboPlanServiceWhereInput
  }

  export type CouponListRelationFilter = {
    every?: CouponWhereInput
    some?: CouponWhereInput
    none?: CouponWhereInput
  }

  export type ComboPlanServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CouponOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComboPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    taxPercent?: SortOrder
    active?: SortOrder
    tenureDiscounts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComboPlanAvgOrderByAggregateInput = {
    price?: SortOrder
    taxPercent?: SortOrder
  }

  export type ComboPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    taxPercent?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComboPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    taxPercent?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComboPlanSumOrderByAggregateInput = {
    price?: SortOrder
    taxPercent?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ComboPlanServiceCountOrderByAggregateInput = {
    id?: SortOrder
    comboPlanId?: SortOrder
    serviceId?: SortOrder
  }

  export type ComboPlanServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    comboPlanId?: SortOrder
    serviceId?: SortOrder
  }

  export type ComboPlanServiceMinOrderByAggregateInput = {
    id?: SortOrder
    comboPlanId?: SortOrder
    serviceId?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type ServiceTradingNullableScalarRelationFilter = {
    is?: ServiceTradingWhereInput | null
    isNot?: ServiceTradingWhereInput | null
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    tag?: SortOrder
    label?: SortOrder
    serviceClass?: SortOrder
    description?: SortOrder
    chart?: SortOrder
    comparisonTitle?: SortOrder
    recommendation?: SortOrder
    price?: SortOrder
    taxPercent?: SortOrder
    tenureDiscounts?: SortOrder
    features?: SortOrder
    faq?: SortOrder
    active?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    taxPercent?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    tag?: SortOrder
    label?: SortOrder
    serviceClass?: SortOrder
    description?: SortOrder
    comparisonTitle?: SortOrder
    price?: SortOrder
    taxPercent?: SortOrder
    active?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    tag?: SortOrder
    label?: SortOrder
    serviceClass?: SortOrder
    description?: SortOrder
    comparisonTitle?: SortOrder
    price?: SortOrder
    taxPercent?: SortOrder
    active?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    taxPercent?: SortOrder
  }

  export type EnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type ServiceTradingCountOrderByAggregateInput = {
    id?: SortOrder
    buy_stock_list?: SortOrder
    sell_stock_list?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTradingMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTradingMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type UserDocumentsCreateNestedManyWithoutUserInput = {
    create?: XOR<UserDocumentsCreateWithoutUserInput, UserDocumentsUncheckedCreateWithoutUserInput> | UserDocumentsCreateWithoutUserInput[] | UserDocumentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDocumentsCreateOrConnectWithoutUserInput | UserDocumentsCreateOrConnectWithoutUserInput[]
    createMany?: UserDocumentsCreateManyUserInputEnvelope
    connect?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
  }

  export type UserPurchasedServicesCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPurchasedServicesCreateWithoutUserInput, UserPurchasedServicesUncheckedCreateWithoutUserInput> | UserPurchasedServicesCreateWithoutUserInput[] | UserPurchasedServicesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPurchasedServicesCreateOrConnectWithoutUserInput | UserPurchasedServicesCreateOrConnectWithoutUserInput[]
    createMany?: UserPurchasedServicesCreateManyUserInputEnvelope
    connect?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
  }

  export type panVerificationDataCreateNestedManyWithoutUserInput = {
    create?: XOR<panVerificationDataCreateWithoutUserInput, panVerificationDataUncheckedCreateWithoutUserInput> | panVerificationDataCreateWithoutUserInput[] | panVerificationDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: panVerificationDataCreateOrConnectWithoutUserInput | panVerificationDataCreateOrConnectWithoutUserInput[]
    createMany?: panVerificationDataCreateManyUserInputEnvelope
    connect?: panVerificationDataWhereUniqueInput | panVerificationDataWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type UserDocumentsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserDocumentsCreateWithoutUserInput, UserDocumentsUncheckedCreateWithoutUserInput> | UserDocumentsCreateWithoutUserInput[] | UserDocumentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDocumentsCreateOrConnectWithoutUserInput | UserDocumentsCreateOrConnectWithoutUserInput[]
    createMany?: UserDocumentsCreateManyUserInputEnvelope
    connect?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
  }

  export type UserPurchasedServicesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPurchasedServicesCreateWithoutUserInput, UserPurchasedServicesUncheckedCreateWithoutUserInput> | UserPurchasedServicesCreateWithoutUserInput[] | UserPurchasedServicesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPurchasedServicesCreateOrConnectWithoutUserInput | UserPurchasedServicesCreateOrConnectWithoutUserInput[]
    createMany?: UserPurchasedServicesCreateManyUserInputEnvelope
    connect?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
  }

  export type panVerificationDataUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<panVerificationDataCreateWithoutUserInput, panVerificationDataUncheckedCreateWithoutUserInput> | panVerificationDataCreateWithoutUserInput[] | panVerificationDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: panVerificationDataCreateOrConnectWithoutUserInput | panVerificationDataCreateOrConnectWithoutUserInput[]
    createMany?: panVerificationDataCreateManyUserInputEnvelope
    connect?: panVerificationDataWhereUniqueInput | panVerificationDataWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserDocumentsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserDocumentsCreateWithoutUserInput, UserDocumentsUncheckedCreateWithoutUserInput> | UserDocumentsCreateWithoutUserInput[] | UserDocumentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDocumentsCreateOrConnectWithoutUserInput | UserDocumentsCreateOrConnectWithoutUserInput[]
    upsert?: UserDocumentsUpsertWithWhereUniqueWithoutUserInput | UserDocumentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserDocumentsCreateManyUserInputEnvelope
    set?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    disconnect?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    delete?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    connect?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    update?: UserDocumentsUpdateWithWhereUniqueWithoutUserInput | UserDocumentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserDocumentsUpdateManyWithWhereWithoutUserInput | UserDocumentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserDocumentsScalarWhereInput | UserDocumentsScalarWhereInput[]
  }

  export type UserPurchasedServicesUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPurchasedServicesCreateWithoutUserInput, UserPurchasedServicesUncheckedCreateWithoutUserInput> | UserPurchasedServicesCreateWithoutUserInput[] | UserPurchasedServicesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPurchasedServicesCreateOrConnectWithoutUserInput | UserPurchasedServicesCreateOrConnectWithoutUserInput[]
    upsert?: UserPurchasedServicesUpsertWithWhereUniqueWithoutUserInput | UserPurchasedServicesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPurchasedServicesCreateManyUserInputEnvelope
    set?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    disconnect?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    delete?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    connect?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    update?: UserPurchasedServicesUpdateWithWhereUniqueWithoutUserInput | UserPurchasedServicesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPurchasedServicesUpdateManyWithWhereWithoutUserInput | UserPurchasedServicesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPurchasedServicesScalarWhereInput | UserPurchasedServicesScalarWhereInput[]
  }

  export type panVerificationDataUpdateManyWithoutUserNestedInput = {
    create?: XOR<panVerificationDataCreateWithoutUserInput, panVerificationDataUncheckedCreateWithoutUserInput> | panVerificationDataCreateWithoutUserInput[] | panVerificationDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: panVerificationDataCreateOrConnectWithoutUserInput | panVerificationDataCreateOrConnectWithoutUserInput[]
    upsert?: panVerificationDataUpsertWithWhereUniqueWithoutUserInput | panVerificationDataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: panVerificationDataCreateManyUserInputEnvelope
    set?: panVerificationDataWhereUniqueInput | panVerificationDataWhereUniqueInput[]
    disconnect?: panVerificationDataWhereUniqueInput | panVerificationDataWhereUniqueInput[]
    delete?: panVerificationDataWhereUniqueInput | panVerificationDataWhereUniqueInput[]
    connect?: panVerificationDataWhereUniqueInput | panVerificationDataWhereUniqueInput[]
    update?: panVerificationDataUpdateWithWhereUniqueWithoutUserInput | panVerificationDataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: panVerificationDataUpdateManyWithWhereWithoutUserInput | panVerificationDataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: panVerificationDataScalarWhereInput | panVerificationDataScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type UserDocumentsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserDocumentsCreateWithoutUserInput, UserDocumentsUncheckedCreateWithoutUserInput> | UserDocumentsCreateWithoutUserInput[] | UserDocumentsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserDocumentsCreateOrConnectWithoutUserInput | UserDocumentsCreateOrConnectWithoutUserInput[]
    upsert?: UserDocumentsUpsertWithWhereUniqueWithoutUserInput | UserDocumentsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserDocumentsCreateManyUserInputEnvelope
    set?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    disconnect?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    delete?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    connect?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    update?: UserDocumentsUpdateWithWhereUniqueWithoutUserInput | UserDocumentsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserDocumentsUpdateManyWithWhereWithoutUserInput | UserDocumentsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserDocumentsScalarWhereInput | UserDocumentsScalarWhereInput[]
  }

  export type UserPurchasedServicesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPurchasedServicesCreateWithoutUserInput, UserPurchasedServicesUncheckedCreateWithoutUserInput> | UserPurchasedServicesCreateWithoutUserInput[] | UserPurchasedServicesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPurchasedServicesCreateOrConnectWithoutUserInput | UserPurchasedServicesCreateOrConnectWithoutUserInput[]
    upsert?: UserPurchasedServicesUpsertWithWhereUniqueWithoutUserInput | UserPurchasedServicesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPurchasedServicesCreateManyUserInputEnvelope
    set?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    disconnect?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    delete?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    connect?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    update?: UserPurchasedServicesUpdateWithWhereUniqueWithoutUserInput | UserPurchasedServicesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPurchasedServicesUpdateManyWithWhereWithoutUserInput | UserPurchasedServicesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPurchasedServicesScalarWhereInput | UserPurchasedServicesScalarWhereInput[]
  }

  export type panVerificationDataUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<panVerificationDataCreateWithoutUserInput, panVerificationDataUncheckedCreateWithoutUserInput> | panVerificationDataCreateWithoutUserInput[] | panVerificationDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: panVerificationDataCreateOrConnectWithoutUserInput | panVerificationDataCreateOrConnectWithoutUserInput[]
    upsert?: panVerificationDataUpsertWithWhereUniqueWithoutUserInput | panVerificationDataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: panVerificationDataCreateManyUserInputEnvelope
    set?: panVerificationDataWhereUniqueInput | panVerificationDataWhereUniqueInput[]
    disconnect?: panVerificationDataWhereUniqueInput | panVerificationDataWhereUniqueInput[]
    delete?: panVerificationDataWhereUniqueInput | panVerificationDataWhereUniqueInput[]
    connect?: panVerificationDataWhereUniqueInput | panVerificationDataWhereUniqueInput[]
    update?: panVerificationDataUpdateWithWhereUniqueWithoutUserInput | panVerificationDataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: panVerificationDataUpdateManyWithWhereWithoutUserInput | panVerificationDataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: panVerificationDataScalarWhereInput | panVerificationDataScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type EnumVerificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.VerificationType
  }

  export type UserCreateNestedOneWithoutPanVerificationDataInput = {
    create?: XOR<UserCreateWithoutPanVerificationDataInput, UserUncheckedCreateWithoutPanVerificationDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutPanVerificationDataInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPanVerificationDataNestedInput = {
    create?: XOR<UserCreateWithoutPanVerificationDataInput, UserUncheckedCreateWithoutPanVerificationDataInput>
    connectOrCreate?: UserCreateOrConnectWithoutPanVerificationDataInput
    upsert?: UserUpsertWithoutPanVerificationDataInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPanVerificationDataInput, UserUpdateWithoutPanVerificationDataInput>, UserUncheckedUpdateWithoutPanVerificationDataInput>
  }

  export type UserCreateNestedOneWithoutPurchasedServicesInput = {
    create?: XOR<UserCreateWithoutPurchasedServicesInput, UserUncheckedCreateWithoutPurchasedServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasedServicesInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutPurchasedServicesInput = {
    create?: XOR<ServiceCreateWithoutPurchasedServicesInput, ServiceUncheckedCreateWithoutPurchasedServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPurchasedServicesInput
    connect?: ServiceWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPurchasedServicesNestedInput = {
    create?: XOR<UserCreateWithoutPurchasedServicesInput, UserUncheckedCreateWithoutPurchasedServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasedServicesInput
    upsert?: UserUpsertWithoutPurchasedServicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchasedServicesInput, UserUpdateWithoutPurchasedServicesInput>, UserUncheckedUpdateWithoutPurchasedServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutPurchasedServicesNestedInput = {
    create?: XOR<ServiceCreateWithoutPurchasedServicesInput, ServiceUncheckedCreateWithoutPurchasedServicesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPurchasedServicesInput
    upsert?: ServiceUpsertWithoutPurchasedServicesInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutPurchasedServicesInput, ServiceUpdateWithoutPurchasedServicesInput>, ServiceUncheckedUpdateWithoutPurchasedServicesInput>
  }

  export type ComboPlanCreateNestedOneWithoutCouponInput = {
    create?: XOR<ComboPlanCreateWithoutCouponInput, ComboPlanUncheckedCreateWithoutCouponInput>
    connectOrCreate?: ComboPlanCreateOrConnectWithoutCouponInput
    connect?: ComboPlanWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutCouponInput = {
    create?: XOR<ServiceCreateWithoutCouponInput, ServiceUncheckedCreateWithoutCouponInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutCouponInput
    connect?: ServiceWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutCouponInput = {
    create?: XOR<TransactionCreateWithoutCouponInput, TransactionUncheckedCreateWithoutCouponInput> | TransactionCreateWithoutCouponInput[] | TransactionUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCouponInput | TransactionCreateOrConnectWithoutCouponInput[]
    createMany?: TransactionCreateManyCouponInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCouponInput = {
    create?: XOR<TransactionCreateWithoutCouponInput, TransactionUncheckedCreateWithoutCouponInput> | TransactionCreateWithoutCouponInput[] | TransactionUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCouponInput | TransactionCreateOrConnectWithoutCouponInput[]
    createMany?: TransactionCreateManyCouponInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ComboPlanUpdateOneWithoutCouponNestedInput = {
    create?: XOR<ComboPlanCreateWithoutCouponInput, ComboPlanUncheckedCreateWithoutCouponInput>
    connectOrCreate?: ComboPlanCreateOrConnectWithoutCouponInput
    upsert?: ComboPlanUpsertWithoutCouponInput
    disconnect?: ComboPlanWhereInput | boolean
    delete?: ComboPlanWhereInput | boolean
    connect?: ComboPlanWhereUniqueInput
    update?: XOR<XOR<ComboPlanUpdateToOneWithWhereWithoutCouponInput, ComboPlanUpdateWithoutCouponInput>, ComboPlanUncheckedUpdateWithoutCouponInput>
  }

  export type ServiceUpdateOneWithoutCouponNestedInput = {
    create?: XOR<ServiceCreateWithoutCouponInput, ServiceUncheckedCreateWithoutCouponInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutCouponInput
    upsert?: ServiceUpsertWithoutCouponInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutCouponInput, ServiceUpdateWithoutCouponInput>, ServiceUncheckedUpdateWithoutCouponInput>
  }

  export type TransactionUpdateManyWithoutCouponNestedInput = {
    create?: XOR<TransactionCreateWithoutCouponInput, TransactionUncheckedCreateWithoutCouponInput> | TransactionCreateWithoutCouponInput[] | TransactionUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCouponInput | TransactionCreateOrConnectWithoutCouponInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCouponInput | TransactionUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: TransactionCreateManyCouponInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCouponInput | TransactionUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCouponInput | TransactionUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCouponNestedInput = {
    create?: XOR<TransactionCreateWithoutCouponInput, TransactionUncheckedCreateWithoutCouponInput> | TransactionCreateWithoutCouponInput[] | TransactionUncheckedCreateWithoutCouponInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCouponInput | TransactionCreateOrConnectWithoutCouponInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCouponInput | TransactionUpsertWithWhereUniqueWithoutCouponInput[]
    createMany?: TransactionCreateManyCouponInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCouponInput | TransactionUpdateWithWhereUniqueWithoutCouponInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCouponInput | TransactionUpdateManyWithWhereWithoutCouponInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTransactionInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutTransactionInput = {
    create?: XOR<ServiceCreateWithoutTransactionInput, ServiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutTransactionInput
    connect?: ServiceWhereUniqueInput
  }

  export type ComboPlanCreateNestedOneWithoutTransactionInput = {
    create?: XOR<ComboPlanCreateWithoutTransactionInput, ComboPlanUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: ComboPlanCreateOrConnectWithoutTransactionInput
    connect?: ComboPlanWhereUniqueInput
  }

  export type CouponCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CouponCreateWithoutTransactionsInput, CouponUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CouponCreateOrConnectWithoutTransactionsInput
    connect?: CouponWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTransactionNestedInput = {
    create?: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionInput
    upsert?: UserUpsertWithoutTransactionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionInput, UserUpdateWithoutTransactionInput>, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type ServiceUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<ServiceCreateWithoutTransactionInput, ServiceUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutTransactionInput
    upsert?: ServiceUpsertWithoutTransactionInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutTransactionInput, ServiceUpdateWithoutTransactionInput>, ServiceUncheckedUpdateWithoutTransactionInput>
  }

  export type ComboPlanUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<ComboPlanCreateWithoutTransactionInput, ComboPlanUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: ComboPlanCreateOrConnectWithoutTransactionInput
    upsert?: ComboPlanUpsertWithoutTransactionInput
    disconnect?: ComboPlanWhereInput | boolean
    delete?: ComboPlanWhereInput | boolean
    connect?: ComboPlanWhereUniqueInput
    update?: XOR<XOR<ComboPlanUpdateToOneWithWhereWithoutTransactionInput, ComboPlanUpdateWithoutTransactionInput>, ComboPlanUncheckedUpdateWithoutTransactionInput>
  }

  export type CouponUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CouponCreateWithoutTransactionsInput, CouponUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CouponCreateOrConnectWithoutTransactionsInput
    upsert?: CouponUpsertWithoutTransactionsInput
    disconnect?: CouponWhereInput | boolean
    delete?: CouponWhereInput | boolean
    connect?: CouponWhereUniqueInput
    update?: XOR<XOR<CouponUpdateToOneWithWhereWithoutTransactionsInput, CouponUpdateWithoutTransactionsInput>, CouponUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutUserDocumentsInput = {
    create?: XOR<ServiceCreateWithoutUserDocumentsInput, ServiceUncheckedCreateWithoutUserDocumentsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutUserDocumentsInput
    connect?: ServiceWhereUniqueInput
  }

  export type EnumDocumentStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocumentStatus
  }

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentsInput, UserUpdateWithoutDocumentsInput>, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type ServiceUpdateOneWithoutUserDocumentsNestedInput = {
    create?: XOR<ServiceCreateWithoutUserDocumentsInput, ServiceUncheckedCreateWithoutUserDocumentsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutUserDocumentsInput
    upsert?: ServiceUpsertWithoutUserDocumentsInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutUserDocumentsInput, ServiceUpdateWithoutUserDocumentsInput>, ServiceUncheckedUpdateWithoutUserDocumentsInput>
  }

  export type ServiceAgreementCreateNestedManyWithoutAgreementInput = {
    create?: XOR<ServiceAgreementCreateWithoutAgreementInput, ServiceAgreementUncheckedCreateWithoutAgreementInput> | ServiceAgreementCreateWithoutAgreementInput[] | ServiceAgreementUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: ServiceAgreementCreateOrConnectWithoutAgreementInput | ServiceAgreementCreateOrConnectWithoutAgreementInput[]
    createMany?: ServiceAgreementCreateManyAgreementInputEnvelope
    connect?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
  }

  export type ComboPlanAgreementCreateNestedManyWithoutAgreementInput = {
    create?: XOR<ComboPlanAgreementCreateWithoutAgreementInput, ComboPlanAgreementUncheckedCreateWithoutAgreementInput> | ComboPlanAgreementCreateWithoutAgreementInput[] | ComboPlanAgreementUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: ComboPlanAgreementCreateOrConnectWithoutAgreementInput | ComboPlanAgreementCreateOrConnectWithoutAgreementInput[]
    createMany?: ComboPlanAgreementCreateManyAgreementInputEnvelope
    connect?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
  }

  export type ServiceAgreementUncheckedCreateNestedManyWithoutAgreementInput = {
    create?: XOR<ServiceAgreementCreateWithoutAgreementInput, ServiceAgreementUncheckedCreateWithoutAgreementInput> | ServiceAgreementCreateWithoutAgreementInput[] | ServiceAgreementUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: ServiceAgreementCreateOrConnectWithoutAgreementInput | ServiceAgreementCreateOrConnectWithoutAgreementInput[]
    createMany?: ServiceAgreementCreateManyAgreementInputEnvelope
    connect?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
  }

  export type ComboPlanAgreementUncheckedCreateNestedManyWithoutAgreementInput = {
    create?: XOR<ComboPlanAgreementCreateWithoutAgreementInput, ComboPlanAgreementUncheckedCreateWithoutAgreementInput> | ComboPlanAgreementCreateWithoutAgreementInput[] | ComboPlanAgreementUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: ComboPlanAgreementCreateOrConnectWithoutAgreementInput | ComboPlanAgreementCreateOrConnectWithoutAgreementInput[]
    createMany?: ComboPlanAgreementCreateManyAgreementInputEnvelope
    connect?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
  }

  export type ServiceAgreementUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<ServiceAgreementCreateWithoutAgreementInput, ServiceAgreementUncheckedCreateWithoutAgreementInput> | ServiceAgreementCreateWithoutAgreementInput[] | ServiceAgreementUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: ServiceAgreementCreateOrConnectWithoutAgreementInput | ServiceAgreementCreateOrConnectWithoutAgreementInput[]
    upsert?: ServiceAgreementUpsertWithWhereUniqueWithoutAgreementInput | ServiceAgreementUpsertWithWhereUniqueWithoutAgreementInput[]
    createMany?: ServiceAgreementCreateManyAgreementInputEnvelope
    set?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    disconnect?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    delete?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    connect?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    update?: ServiceAgreementUpdateWithWhereUniqueWithoutAgreementInput | ServiceAgreementUpdateWithWhereUniqueWithoutAgreementInput[]
    updateMany?: ServiceAgreementUpdateManyWithWhereWithoutAgreementInput | ServiceAgreementUpdateManyWithWhereWithoutAgreementInput[]
    deleteMany?: ServiceAgreementScalarWhereInput | ServiceAgreementScalarWhereInput[]
  }

  export type ComboPlanAgreementUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<ComboPlanAgreementCreateWithoutAgreementInput, ComboPlanAgreementUncheckedCreateWithoutAgreementInput> | ComboPlanAgreementCreateWithoutAgreementInput[] | ComboPlanAgreementUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: ComboPlanAgreementCreateOrConnectWithoutAgreementInput | ComboPlanAgreementCreateOrConnectWithoutAgreementInput[]
    upsert?: ComboPlanAgreementUpsertWithWhereUniqueWithoutAgreementInput | ComboPlanAgreementUpsertWithWhereUniqueWithoutAgreementInput[]
    createMany?: ComboPlanAgreementCreateManyAgreementInputEnvelope
    set?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    disconnect?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    delete?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    connect?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    update?: ComboPlanAgreementUpdateWithWhereUniqueWithoutAgreementInput | ComboPlanAgreementUpdateWithWhereUniqueWithoutAgreementInput[]
    updateMany?: ComboPlanAgreementUpdateManyWithWhereWithoutAgreementInput | ComboPlanAgreementUpdateManyWithWhereWithoutAgreementInput[]
    deleteMany?: ComboPlanAgreementScalarWhereInput | ComboPlanAgreementScalarWhereInput[]
  }

  export type ServiceAgreementUncheckedUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<ServiceAgreementCreateWithoutAgreementInput, ServiceAgreementUncheckedCreateWithoutAgreementInput> | ServiceAgreementCreateWithoutAgreementInput[] | ServiceAgreementUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: ServiceAgreementCreateOrConnectWithoutAgreementInput | ServiceAgreementCreateOrConnectWithoutAgreementInput[]
    upsert?: ServiceAgreementUpsertWithWhereUniqueWithoutAgreementInput | ServiceAgreementUpsertWithWhereUniqueWithoutAgreementInput[]
    createMany?: ServiceAgreementCreateManyAgreementInputEnvelope
    set?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    disconnect?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    delete?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    connect?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    update?: ServiceAgreementUpdateWithWhereUniqueWithoutAgreementInput | ServiceAgreementUpdateWithWhereUniqueWithoutAgreementInput[]
    updateMany?: ServiceAgreementUpdateManyWithWhereWithoutAgreementInput | ServiceAgreementUpdateManyWithWhereWithoutAgreementInput[]
    deleteMany?: ServiceAgreementScalarWhereInput | ServiceAgreementScalarWhereInput[]
  }

  export type ComboPlanAgreementUncheckedUpdateManyWithoutAgreementNestedInput = {
    create?: XOR<ComboPlanAgreementCreateWithoutAgreementInput, ComboPlanAgreementUncheckedCreateWithoutAgreementInput> | ComboPlanAgreementCreateWithoutAgreementInput[] | ComboPlanAgreementUncheckedCreateWithoutAgreementInput[]
    connectOrCreate?: ComboPlanAgreementCreateOrConnectWithoutAgreementInput | ComboPlanAgreementCreateOrConnectWithoutAgreementInput[]
    upsert?: ComboPlanAgreementUpsertWithWhereUniqueWithoutAgreementInput | ComboPlanAgreementUpsertWithWhereUniqueWithoutAgreementInput[]
    createMany?: ComboPlanAgreementCreateManyAgreementInputEnvelope
    set?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    disconnect?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    delete?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    connect?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    update?: ComboPlanAgreementUpdateWithWhereUniqueWithoutAgreementInput | ComboPlanAgreementUpdateWithWhereUniqueWithoutAgreementInput[]
    updateMany?: ComboPlanAgreementUpdateManyWithWhereWithoutAgreementInput | ComboPlanAgreementUpdateManyWithWhereWithoutAgreementInput[]
    deleteMany?: ComboPlanAgreementScalarWhereInput | ComboPlanAgreementScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutAgreementsInput = {
    create?: XOR<ServiceCreateWithoutAgreementsInput, ServiceUncheckedCreateWithoutAgreementsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAgreementsInput
    connect?: ServiceWhereUniqueInput
  }

  export type AgreementCreateNestedOneWithoutServiceAgreementsInput = {
    create?: XOR<AgreementCreateWithoutServiceAgreementsInput, AgreementUncheckedCreateWithoutServiceAgreementsInput>
    connectOrCreate?: AgreementCreateOrConnectWithoutServiceAgreementsInput
    connect?: AgreementWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutAgreementsNestedInput = {
    create?: XOR<ServiceCreateWithoutAgreementsInput, ServiceUncheckedCreateWithoutAgreementsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAgreementsInput
    upsert?: ServiceUpsertWithoutAgreementsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutAgreementsInput, ServiceUpdateWithoutAgreementsInput>, ServiceUncheckedUpdateWithoutAgreementsInput>
  }

  export type AgreementUpdateOneRequiredWithoutServiceAgreementsNestedInput = {
    create?: XOR<AgreementCreateWithoutServiceAgreementsInput, AgreementUncheckedCreateWithoutServiceAgreementsInput>
    connectOrCreate?: AgreementCreateOrConnectWithoutServiceAgreementsInput
    upsert?: AgreementUpsertWithoutServiceAgreementsInput
    connect?: AgreementWhereUniqueInput
    update?: XOR<XOR<AgreementUpdateToOneWithWhereWithoutServiceAgreementsInput, AgreementUpdateWithoutServiceAgreementsInput>, AgreementUncheckedUpdateWithoutServiceAgreementsInput>
  }

  export type ComboPlanCreateNestedOneWithoutAgreementInput = {
    create?: XOR<ComboPlanCreateWithoutAgreementInput, ComboPlanUncheckedCreateWithoutAgreementInput>
    connectOrCreate?: ComboPlanCreateOrConnectWithoutAgreementInput
    connect?: ComboPlanWhereUniqueInput
  }

  export type AgreementCreateNestedOneWithoutComboPlanAgreementsInput = {
    create?: XOR<AgreementCreateWithoutComboPlanAgreementsInput, AgreementUncheckedCreateWithoutComboPlanAgreementsInput>
    connectOrCreate?: AgreementCreateOrConnectWithoutComboPlanAgreementsInput
    connect?: AgreementWhereUniqueInput
  }

  export type ComboPlanUpdateOneRequiredWithoutAgreementNestedInput = {
    create?: XOR<ComboPlanCreateWithoutAgreementInput, ComboPlanUncheckedCreateWithoutAgreementInput>
    connectOrCreate?: ComboPlanCreateOrConnectWithoutAgreementInput
    upsert?: ComboPlanUpsertWithoutAgreementInput
    connect?: ComboPlanWhereUniqueInput
    update?: XOR<XOR<ComboPlanUpdateToOneWithWhereWithoutAgreementInput, ComboPlanUpdateWithoutAgreementInput>, ComboPlanUncheckedUpdateWithoutAgreementInput>
  }

  export type AgreementUpdateOneRequiredWithoutComboPlanAgreementsNestedInput = {
    create?: XOR<AgreementCreateWithoutComboPlanAgreementsInput, AgreementUncheckedCreateWithoutComboPlanAgreementsInput>
    connectOrCreate?: AgreementCreateOrConnectWithoutComboPlanAgreementsInput
    upsert?: AgreementUpsertWithoutComboPlanAgreementsInput
    connect?: AgreementWhereUniqueInput
    update?: XOR<XOR<AgreementUpdateToOneWithWhereWithoutComboPlanAgreementsInput, AgreementUpdateWithoutComboPlanAgreementsInput>, AgreementUncheckedUpdateWithoutComboPlanAgreementsInput>
  }

  export type ComboPlanAgreementCreateNestedManyWithoutComboPlanInput = {
    create?: XOR<ComboPlanAgreementCreateWithoutComboPlanInput, ComboPlanAgreementUncheckedCreateWithoutComboPlanInput> | ComboPlanAgreementCreateWithoutComboPlanInput[] | ComboPlanAgreementUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: ComboPlanAgreementCreateOrConnectWithoutComboPlanInput | ComboPlanAgreementCreateOrConnectWithoutComboPlanInput[]
    createMany?: ComboPlanAgreementCreateManyComboPlanInputEnvelope
    connect?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
  }

  export type ComboPlanServiceCreateNestedManyWithoutComboPlanInput = {
    create?: XOR<ComboPlanServiceCreateWithoutComboPlanInput, ComboPlanServiceUncheckedCreateWithoutComboPlanInput> | ComboPlanServiceCreateWithoutComboPlanInput[] | ComboPlanServiceUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: ComboPlanServiceCreateOrConnectWithoutComboPlanInput | ComboPlanServiceCreateOrConnectWithoutComboPlanInput[]
    createMany?: ComboPlanServiceCreateManyComboPlanInputEnvelope
    connect?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
  }

  export type CouponCreateNestedManyWithoutComboPlanInput = {
    create?: XOR<CouponCreateWithoutComboPlanInput, CouponUncheckedCreateWithoutComboPlanInput> | CouponCreateWithoutComboPlanInput[] | CouponUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutComboPlanInput | CouponCreateOrConnectWithoutComboPlanInput[]
    createMany?: CouponCreateManyComboPlanInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutComboPlanInput = {
    create?: XOR<TransactionCreateWithoutComboPlanInput, TransactionUncheckedCreateWithoutComboPlanInput> | TransactionCreateWithoutComboPlanInput[] | TransactionUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutComboPlanInput | TransactionCreateOrConnectWithoutComboPlanInput[]
    createMany?: TransactionCreateManyComboPlanInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ComboPlanAgreementUncheckedCreateNestedManyWithoutComboPlanInput = {
    create?: XOR<ComboPlanAgreementCreateWithoutComboPlanInput, ComboPlanAgreementUncheckedCreateWithoutComboPlanInput> | ComboPlanAgreementCreateWithoutComboPlanInput[] | ComboPlanAgreementUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: ComboPlanAgreementCreateOrConnectWithoutComboPlanInput | ComboPlanAgreementCreateOrConnectWithoutComboPlanInput[]
    createMany?: ComboPlanAgreementCreateManyComboPlanInputEnvelope
    connect?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
  }

  export type ComboPlanServiceUncheckedCreateNestedManyWithoutComboPlanInput = {
    create?: XOR<ComboPlanServiceCreateWithoutComboPlanInput, ComboPlanServiceUncheckedCreateWithoutComboPlanInput> | ComboPlanServiceCreateWithoutComboPlanInput[] | ComboPlanServiceUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: ComboPlanServiceCreateOrConnectWithoutComboPlanInput | ComboPlanServiceCreateOrConnectWithoutComboPlanInput[]
    createMany?: ComboPlanServiceCreateManyComboPlanInputEnvelope
    connect?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
  }

  export type CouponUncheckedCreateNestedManyWithoutComboPlanInput = {
    create?: XOR<CouponCreateWithoutComboPlanInput, CouponUncheckedCreateWithoutComboPlanInput> | CouponCreateWithoutComboPlanInput[] | CouponUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutComboPlanInput | CouponCreateOrConnectWithoutComboPlanInput[]
    createMany?: CouponCreateManyComboPlanInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutComboPlanInput = {
    create?: XOR<TransactionCreateWithoutComboPlanInput, TransactionUncheckedCreateWithoutComboPlanInput> | TransactionCreateWithoutComboPlanInput[] | TransactionUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutComboPlanInput | TransactionCreateOrConnectWithoutComboPlanInput[]
    createMany?: TransactionCreateManyComboPlanInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ComboPlanAgreementUpdateManyWithoutComboPlanNestedInput = {
    create?: XOR<ComboPlanAgreementCreateWithoutComboPlanInput, ComboPlanAgreementUncheckedCreateWithoutComboPlanInput> | ComboPlanAgreementCreateWithoutComboPlanInput[] | ComboPlanAgreementUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: ComboPlanAgreementCreateOrConnectWithoutComboPlanInput | ComboPlanAgreementCreateOrConnectWithoutComboPlanInput[]
    upsert?: ComboPlanAgreementUpsertWithWhereUniqueWithoutComboPlanInput | ComboPlanAgreementUpsertWithWhereUniqueWithoutComboPlanInput[]
    createMany?: ComboPlanAgreementCreateManyComboPlanInputEnvelope
    set?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    disconnect?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    delete?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    connect?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    update?: ComboPlanAgreementUpdateWithWhereUniqueWithoutComboPlanInput | ComboPlanAgreementUpdateWithWhereUniqueWithoutComboPlanInput[]
    updateMany?: ComboPlanAgreementUpdateManyWithWhereWithoutComboPlanInput | ComboPlanAgreementUpdateManyWithWhereWithoutComboPlanInput[]
    deleteMany?: ComboPlanAgreementScalarWhereInput | ComboPlanAgreementScalarWhereInput[]
  }

  export type ComboPlanServiceUpdateManyWithoutComboPlanNestedInput = {
    create?: XOR<ComboPlanServiceCreateWithoutComboPlanInput, ComboPlanServiceUncheckedCreateWithoutComboPlanInput> | ComboPlanServiceCreateWithoutComboPlanInput[] | ComboPlanServiceUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: ComboPlanServiceCreateOrConnectWithoutComboPlanInput | ComboPlanServiceCreateOrConnectWithoutComboPlanInput[]
    upsert?: ComboPlanServiceUpsertWithWhereUniqueWithoutComboPlanInput | ComboPlanServiceUpsertWithWhereUniqueWithoutComboPlanInput[]
    createMany?: ComboPlanServiceCreateManyComboPlanInputEnvelope
    set?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    disconnect?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    delete?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    connect?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    update?: ComboPlanServiceUpdateWithWhereUniqueWithoutComboPlanInput | ComboPlanServiceUpdateWithWhereUniqueWithoutComboPlanInput[]
    updateMany?: ComboPlanServiceUpdateManyWithWhereWithoutComboPlanInput | ComboPlanServiceUpdateManyWithWhereWithoutComboPlanInput[]
    deleteMany?: ComboPlanServiceScalarWhereInput | ComboPlanServiceScalarWhereInput[]
  }

  export type CouponUpdateManyWithoutComboPlanNestedInput = {
    create?: XOR<CouponCreateWithoutComboPlanInput, CouponUncheckedCreateWithoutComboPlanInput> | CouponCreateWithoutComboPlanInput[] | CouponUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutComboPlanInput | CouponCreateOrConnectWithoutComboPlanInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutComboPlanInput | CouponUpsertWithWhereUniqueWithoutComboPlanInput[]
    createMany?: CouponCreateManyComboPlanInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutComboPlanInput | CouponUpdateWithWhereUniqueWithoutComboPlanInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutComboPlanInput | CouponUpdateManyWithWhereWithoutComboPlanInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutComboPlanNestedInput = {
    create?: XOR<TransactionCreateWithoutComboPlanInput, TransactionUncheckedCreateWithoutComboPlanInput> | TransactionCreateWithoutComboPlanInput[] | TransactionUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutComboPlanInput | TransactionCreateOrConnectWithoutComboPlanInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutComboPlanInput | TransactionUpsertWithWhereUniqueWithoutComboPlanInput[]
    createMany?: TransactionCreateManyComboPlanInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutComboPlanInput | TransactionUpdateWithWhereUniqueWithoutComboPlanInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutComboPlanInput | TransactionUpdateManyWithWhereWithoutComboPlanInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ComboPlanAgreementUncheckedUpdateManyWithoutComboPlanNestedInput = {
    create?: XOR<ComboPlanAgreementCreateWithoutComboPlanInput, ComboPlanAgreementUncheckedCreateWithoutComboPlanInput> | ComboPlanAgreementCreateWithoutComboPlanInput[] | ComboPlanAgreementUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: ComboPlanAgreementCreateOrConnectWithoutComboPlanInput | ComboPlanAgreementCreateOrConnectWithoutComboPlanInput[]
    upsert?: ComboPlanAgreementUpsertWithWhereUniqueWithoutComboPlanInput | ComboPlanAgreementUpsertWithWhereUniqueWithoutComboPlanInput[]
    createMany?: ComboPlanAgreementCreateManyComboPlanInputEnvelope
    set?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    disconnect?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    delete?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    connect?: ComboPlanAgreementWhereUniqueInput | ComboPlanAgreementWhereUniqueInput[]
    update?: ComboPlanAgreementUpdateWithWhereUniqueWithoutComboPlanInput | ComboPlanAgreementUpdateWithWhereUniqueWithoutComboPlanInput[]
    updateMany?: ComboPlanAgreementUpdateManyWithWhereWithoutComboPlanInput | ComboPlanAgreementUpdateManyWithWhereWithoutComboPlanInput[]
    deleteMany?: ComboPlanAgreementScalarWhereInput | ComboPlanAgreementScalarWhereInput[]
  }

  export type ComboPlanServiceUncheckedUpdateManyWithoutComboPlanNestedInput = {
    create?: XOR<ComboPlanServiceCreateWithoutComboPlanInput, ComboPlanServiceUncheckedCreateWithoutComboPlanInput> | ComboPlanServiceCreateWithoutComboPlanInput[] | ComboPlanServiceUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: ComboPlanServiceCreateOrConnectWithoutComboPlanInput | ComboPlanServiceCreateOrConnectWithoutComboPlanInput[]
    upsert?: ComboPlanServiceUpsertWithWhereUniqueWithoutComboPlanInput | ComboPlanServiceUpsertWithWhereUniqueWithoutComboPlanInput[]
    createMany?: ComboPlanServiceCreateManyComboPlanInputEnvelope
    set?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    disconnect?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    delete?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    connect?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    update?: ComboPlanServiceUpdateWithWhereUniqueWithoutComboPlanInput | ComboPlanServiceUpdateWithWhereUniqueWithoutComboPlanInput[]
    updateMany?: ComboPlanServiceUpdateManyWithWhereWithoutComboPlanInput | ComboPlanServiceUpdateManyWithWhereWithoutComboPlanInput[]
    deleteMany?: ComboPlanServiceScalarWhereInput | ComboPlanServiceScalarWhereInput[]
  }

  export type CouponUncheckedUpdateManyWithoutComboPlanNestedInput = {
    create?: XOR<CouponCreateWithoutComboPlanInput, CouponUncheckedCreateWithoutComboPlanInput> | CouponCreateWithoutComboPlanInput[] | CouponUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutComboPlanInput | CouponCreateOrConnectWithoutComboPlanInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutComboPlanInput | CouponUpsertWithWhereUniqueWithoutComboPlanInput[]
    createMany?: CouponCreateManyComboPlanInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutComboPlanInput | CouponUpdateWithWhereUniqueWithoutComboPlanInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutComboPlanInput | CouponUpdateManyWithWhereWithoutComboPlanInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutComboPlanNestedInput = {
    create?: XOR<TransactionCreateWithoutComboPlanInput, TransactionUncheckedCreateWithoutComboPlanInput> | TransactionCreateWithoutComboPlanInput[] | TransactionUncheckedCreateWithoutComboPlanInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutComboPlanInput | TransactionCreateOrConnectWithoutComboPlanInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutComboPlanInput | TransactionUpsertWithWhereUniqueWithoutComboPlanInput[]
    createMany?: TransactionCreateManyComboPlanInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutComboPlanInput | TransactionUpdateWithWhereUniqueWithoutComboPlanInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutComboPlanInput | TransactionUpdateManyWithWhereWithoutComboPlanInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ComboPlanCreateNestedOneWithoutServicesInput = {
    create?: XOR<ComboPlanCreateWithoutServicesInput, ComboPlanUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ComboPlanCreateOrConnectWithoutServicesInput
    connect?: ComboPlanWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutComboPlanServiceInput = {
    create?: XOR<ServiceCreateWithoutComboPlanServiceInput, ServiceUncheckedCreateWithoutComboPlanServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutComboPlanServiceInput
    connect?: ServiceWhereUniqueInput
  }

  export type ComboPlanUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<ComboPlanCreateWithoutServicesInput, ComboPlanUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ComboPlanCreateOrConnectWithoutServicesInput
    upsert?: ComboPlanUpsertWithoutServicesInput
    connect?: ComboPlanWhereUniqueInput
    update?: XOR<XOR<ComboPlanUpdateToOneWithWhereWithoutServicesInput, ComboPlanUpdateWithoutServicesInput>, ComboPlanUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceUpdateOneRequiredWithoutComboPlanServiceNestedInput = {
    create?: XOR<ServiceCreateWithoutComboPlanServiceInput, ServiceUncheckedCreateWithoutComboPlanServiceInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutComboPlanServiceInput
    upsert?: ServiceUpsertWithoutComboPlanServiceInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutComboPlanServiceInput, ServiceUpdateWithoutComboPlanServiceInput>, ServiceUncheckedUpdateWithoutComboPlanServiceInput>
  }

  export type ServiceCreaterecommendationInput = {
    set: string[]
  }

  export type ServiceAgreementCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceAgreementCreateWithoutServiceInput, ServiceAgreementUncheckedCreateWithoutServiceInput> | ServiceAgreementCreateWithoutServiceInput[] | ServiceAgreementUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceAgreementCreateOrConnectWithoutServiceInput | ServiceAgreementCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceAgreementCreateManyServiceInputEnvelope
    connect?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
  }

  export type ServiceTradingCreateNestedOneWithoutServiceInput = {
    create?: XOR<ServiceTradingCreateWithoutServiceInput, ServiceTradingUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ServiceTradingCreateOrConnectWithoutServiceInput
    connect?: ServiceTradingWhereUniqueInput
  }

  export type UserPurchasedServicesCreateNestedManyWithoutServiceInput = {
    create?: XOR<UserPurchasedServicesCreateWithoutServiceInput, UserPurchasedServicesUncheckedCreateWithoutServiceInput> | UserPurchasedServicesCreateWithoutServiceInput[] | UserPurchasedServicesUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserPurchasedServicesCreateOrConnectWithoutServiceInput | UserPurchasedServicesCreateOrConnectWithoutServiceInput[]
    createMany?: UserPurchasedServicesCreateManyServiceInputEnvelope
    connect?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
  }

  export type UserDocumentsCreateNestedManyWithoutServiceInput = {
    create?: XOR<UserDocumentsCreateWithoutServiceInput, UserDocumentsUncheckedCreateWithoutServiceInput> | UserDocumentsCreateWithoutServiceInput[] | UserDocumentsUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserDocumentsCreateOrConnectWithoutServiceInput | UserDocumentsCreateOrConnectWithoutServiceInput[]
    createMany?: UserDocumentsCreateManyServiceInputEnvelope
    connect?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutServiceInput = {
    create?: XOR<TransactionCreateWithoutServiceInput, TransactionUncheckedCreateWithoutServiceInput> | TransactionCreateWithoutServiceInput[] | TransactionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutServiceInput | TransactionCreateOrConnectWithoutServiceInput[]
    createMany?: TransactionCreateManyServiceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ComboPlanServiceCreateNestedManyWithoutServiceInput = {
    create?: XOR<ComboPlanServiceCreateWithoutServiceInput, ComboPlanServiceUncheckedCreateWithoutServiceInput> | ComboPlanServiceCreateWithoutServiceInput[] | ComboPlanServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ComboPlanServiceCreateOrConnectWithoutServiceInput | ComboPlanServiceCreateOrConnectWithoutServiceInput[]
    createMany?: ComboPlanServiceCreateManyServiceInputEnvelope
    connect?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
  }

  export type CouponCreateNestedManyWithoutServiceInput = {
    create?: XOR<CouponCreateWithoutServiceInput, CouponUncheckedCreateWithoutServiceInput> | CouponCreateWithoutServiceInput[] | CouponUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutServiceInput | CouponCreateOrConnectWithoutServiceInput[]
    createMany?: CouponCreateManyServiceInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type ServiceAgreementUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceAgreementCreateWithoutServiceInput, ServiceAgreementUncheckedCreateWithoutServiceInput> | ServiceAgreementCreateWithoutServiceInput[] | ServiceAgreementUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceAgreementCreateOrConnectWithoutServiceInput | ServiceAgreementCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceAgreementCreateManyServiceInputEnvelope
    connect?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
  }

  export type ServiceTradingUncheckedCreateNestedOneWithoutServiceInput = {
    create?: XOR<ServiceTradingCreateWithoutServiceInput, ServiceTradingUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ServiceTradingCreateOrConnectWithoutServiceInput
    connect?: ServiceTradingWhereUniqueInput
  }

  export type UserPurchasedServicesUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<UserPurchasedServicesCreateWithoutServiceInput, UserPurchasedServicesUncheckedCreateWithoutServiceInput> | UserPurchasedServicesCreateWithoutServiceInput[] | UserPurchasedServicesUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserPurchasedServicesCreateOrConnectWithoutServiceInput | UserPurchasedServicesCreateOrConnectWithoutServiceInput[]
    createMany?: UserPurchasedServicesCreateManyServiceInputEnvelope
    connect?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
  }

  export type UserDocumentsUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<UserDocumentsCreateWithoutServiceInput, UserDocumentsUncheckedCreateWithoutServiceInput> | UserDocumentsCreateWithoutServiceInput[] | UserDocumentsUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserDocumentsCreateOrConnectWithoutServiceInput | UserDocumentsCreateOrConnectWithoutServiceInput[]
    createMany?: UserDocumentsCreateManyServiceInputEnvelope
    connect?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<TransactionCreateWithoutServiceInput, TransactionUncheckedCreateWithoutServiceInput> | TransactionCreateWithoutServiceInput[] | TransactionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutServiceInput | TransactionCreateOrConnectWithoutServiceInput[]
    createMany?: TransactionCreateManyServiceInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ComboPlanServiceUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ComboPlanServiceCreateWithoutServiceInput, ComboPlanServiceUncheckedCreateWithoutServiceInput> | ComboPlanServiceCreateWithoutServiceInput[] | ComboPlanServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ComboPlanServiceCreateOrConnectWithoutServiceInput | ComboPlanServiceCreateOrConnectWithoutServiceInput[]
    createMany?: ComboPlanServiceCreateManyServiceInputEnvelope
    connect?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
  }

  export type CouponUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<CouponCreateWithoutServiceInput, CouponUncheckedCreateWithoutServiceInput> | CouponCreateWithoutServiceInput[] | CouponUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutServiceInput | CouponCreateOrConnectWithoutServiceInput[]
    createMany?: CouponCreateManyServiceInputEnvelope
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
  }

  export type ServiceUpdaterecommendationInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumServiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ServiceType
  }

  export type ServiceAgreementUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceAgreementCreateWithoutServiceInput, ServiceAgreementUncheckedCreateWithoutServiceInput> | ServiceAgreementCreateWithoutServiceInput[] | ServiceAgreementUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceAgreementCreateOrConnectWithoutServiceInput | ServiceAgreementCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceAgreementUpsertWithWhereUniqueWithoutServiceInput | ServiceAgreementUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceAgreementCreateManyServiceInputEnvelope
    set?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    disconnect?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    delete?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    connect?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    update?: ServiceAgreementUpdateWithWhereUniqueWithoutServiceInput | ServiceAgreementUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceAgreementUpdateManyWithWhereWithoutServiceInput | ServiceAgreementUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceAgreementScalarWhereInput | ServiceAgreementScalarWhereInput[]
  }

  export type ServiceTradingUpdateOneWithoutServiceNestedInput = {
    create?: XOR<ServiceTradingCreateWithoutServiceInput, ServiceTradingUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ServiceTradingCreateOrConnectWithoutServiceInput
    upsert?: ServiceTradingUpsertWithoutServiceInput
    disconnect?: ServiceTradingWhereInput | boolean
    delete?: ServiceTradingWhereInput | boolean
    connect?: ServiceTradingWhereUniqueInput
    update?: XOR<XOR<ServiceTradingUpdateToOneWithWhereWithoutServiceInput, ServiceTradingUpdateWithoutServiceInput>, ServiceTradingUncheckedUpdateWithoutServiceInput>
  }

  export type UserPurchasedServicesUpdateManyWithoutServiceNestedInput = {
    create?: XOR<UserPurchasedServicesCreateWithoutServiceInput, UserPurchasedServicesUncheckedCreateWithoutServiceInput> | UserPurchasedServicesCreateWithoutServiceInput[] | UserPurchasedServicesUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserPurchasedServicesCreateOrConnectWithoutServiceInput | UserPurchasedServicesCreateOrConnectWithoutServiceInput[]
    upsert?: UserPurchasedServicesUpsertWithWhereUniqueWithoutServiceInput | UserPurchasedServicesUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: UserPurchasedServicesCreateManyServiceInputEnvelope
    set?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    disconnect?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    delete?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    connect?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    update?: UserPurchasedServicesUpdateWithWhereUniqueWithoutServiceInput | UserPurchasedServicesUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: UserPurchasedServicesUpdateManyWithWhereWithoutServiceInput | UserPurchasedServicesUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: UserPurchasedServicesScalarWhereInput | UserPurchasedServicesScalarWhereInput[]
  }

  export type UserDocumentsUpdateManyWithoutServiceNestedInput = {
    create?: XOR<UserDocumentsCreateWithoutServiceInput, UserDocumentsUncheckedCreateWithoutServiceInput> | UserDocumentsCreateWithoutServiceInput[] | UserDocumentsUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserDocumentsCreateOrConnectWithoutServiceInput | UserDocumentsCreateOrConnectWithoutServiceInput[]
    upsert?: UserDocumentsUpsertWithWhereUniqueWithoutServiceInput | UserDocumentsUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: UserDocumentsCreateManyServiceInputEnvelope
    set?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    disconnect?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    delete?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    connect?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    update?: UserDocumentsUpdateWithWhereUniqueWithoutServiceInput | UserDocumentsUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: UserDocumentsUpdateManyWithWhereWithoutServiceInput | UserDocumentsUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: UserDocumentsScalarWhereInput | UserDocumentsScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutServiceNestedInput = {
    create?: XOR<TransactionCreateWithoutServiceInput, TransactionUncheckedCreateWithoutServiceInput> | TransactionCreateWithoutServiceInput[] | TransactionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutServiceInput | TransactionCreateOrConnectWithoutServiceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutServiceInput | TransactionUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: TransactionCreateManyServiceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutServiceInput | TransactionUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutServiceInput | TransactionUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ComboPlanServiceUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ComboPlanServiceCreateWithoutServiceInput, ComboPlanServiceUncheckedCreateWithoutServiceInput> | ComboPlanServiceCreateWithoutServiceInput[] | ComboPlanServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ComboPlanServiceCreateOrConnectWithoutServiceInput | ComboPlanServiceCreateOrConnectWithoutServiceInput[]
    upsert?: ComboPlanServiceUpsertWithWhereUniqueWithoutServiceInput | ComboPlanServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ComboPlanServiceCreateManyServiceInputEnvelope
    set?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    disconnect?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    delete?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    connect?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    update?: ComboPlanServiceUpdateWithWhereUniqueWithoutServiceInput | ComboPlanServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ComboPlanServiceUpdateManyWithWhereWithoutServiceInput | ComboPlanServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ComboPlanServiceScalarWhereInput | ComboPlanServiceScalarWhereInput[]
  }

  export type CouponUpdateManyWithoutServiceNestedInput = {
    create?: XOR<CouponCreateWithoutServiceInput, CouponUncheckedCreateWithoutServiceInput> | CouponCreateWithoutServiceInput[] | CouponUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutServiceInput | CouponCreateOrConnectWithoutServiceInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutServiceInput | CouponUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: CouponCreateManyServiceInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutServiceInput | CouponUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutServiceInput | CouponUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type ServiceAgreementUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceAgreementCreateWithoutServiceInput, ServiceAgreementUncheckedCreateWithoutServiceInput> | ServiceAgreementCreateWithoutServiceInput[] | ServiceAgreementUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceAgreementCreateOrConnectWithoutServiceInput | ServiceAgreementCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceAgreementUpsertWithWhereUniqueWithoutServiceInput | ServiceAgreementUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceAgreementCreateManyServiceInputEnvelope
    set?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    disconnect?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    delete?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    connect?: ServiceAgreementWhereUniqueInput | ServiceAgreementWhereUniqueInput[]
    update?: ServiceAgreementUpdateWithWhereUniqueWithoutServiceInput | ServiceAgreementUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceAgreementUpdateManyWithWhereWithoutServiceInput | ServiceAgreementUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceAgreementScalarWhereInput | ServiceAgreementScalarWhereInput[]
  }

  export type ServiceTradingUncheckedUpdateOneWithoutServiceNestedInput = {
    create?: XOR<ServiceTradingCreateWithoutServiceInput, ServiceTradingUncheckedCreateWithoutServiceInput>
    connectOrCreate?: ServiceTradingCreateOrConnectWithoutServiceInput
    upsert?: ServiceTradingUpsertWithoutServiceInput
    disconnect?: ServiceTradingWhereInput | boolean
    delete?: ServiceTradingWhereInput | boolean
    connect?: ServiceTradingWhereUniqueInput
    update?: XOR<XOR<ServiceTradingUpdateToOneWithWhereWithoutServiceInput, ServiceTradingUpdateWithoutServiceInput>, ServiceTradingUncheckedUpdateWithoutServiceInput>
  }

  export type UserPurchasedServicesUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<UserPurchasedServicesCreateWithoutServiceInput, UserPurchasedServicesUncheckedCreateWithoutServiceInput> | UserPurchasedServicesCreateWithoutServiceInput[] | UserPurchasedServicesUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserPurchasedServicesCreateOrConnectWithoutServiceInput | UserPurchasedServicesCreateOrConnectWithoutServiceInput[]
    upsert?: UserPurchasedServicesUpsertWithWhereUniqueWithoutServiceInput | UserPurchasedServicesUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: UserPurchasedServicesCreateManyServiceInputEnvelope
    set?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    disconnect?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    delete?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    connect?: UserPurchasedServicesWhereUniqueInput | UserPurchasedServicesWhereUniqueInput[]
    update?: UserPurchasedServicesUpdateWithWhereUniqueWithoutServiceInput | UserPurchasedServicesUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: UserPurchasedServicesUpdateManyWithWhereWithoutServiceInput | UserPurchasedServicesUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: UserPurchasedServicesScalarWhereInput | UserPurchasedServicesScalarWhereInput[]
  }

  export type UserDocumentsUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<UserDocumentsCreateWithoutServiceInput, UserDocumentsUncheckedCreateWithoutServiceInput> | UserDocumentsCreateWithoutServiceInput[] | UserDocumentsUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: UserDocumentsCreateOrConnectWithoutServiceInput | UserDocumentsCreateOrConnectWithoutServiceInput[]
    upsert?: UserDocumentsUpsertWithWhereUniqueWithoutServiceInput | UserDocumentsUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: UserDocumentsCreateManyServiceInputEnvelope
    set?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    disconnect?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    delete?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    connect?: UserDocumentsWhereUniqueInput | UserDocumentsWhereUniqueInput[]
    update?: UserDocumentsUpdateWithWhereUniqueWithoutServiceInput | UserDocumentsUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: UserDocumentsUpdateManyWithWhereWithoutServiceInput | UserDocumentsUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: UserDocumentsScalarWhereInput | UserDocumentsScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<TransactionCreateWithoutServiceInput, TransactionUncheckedCreateWithoutServiceInput> | TransactionCreateWithoutServiceInput[] | TransactionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutServiceInput | TransactionCreateOrConnectWithoutServiceInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutServiceInput | TransactionUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: TransactionCreateManyServiceInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutServiceInput | TransactionUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutServiceInput | TransactionUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ComboPlanServiceUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ComboPlanServiceCreateWithoutServiceInput, ComboPlanServiceUncheckedCreateWithoutServiceInput> | ComboPlanServiceCreateWithoutServiceInput[] | ComboPlanServiceUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ComboPlanServiceCreateOrConnectWithoutServiceInput | ComboPlanServiceCreateOrConnectWithoutServiceInput[]
    upsert?: ComboPlanServiceUpsertWithWhereUniqueWithoutServiceInput | ComboPlanServiceUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ComboPlanServiceCreateManyServiceInputEnvelope
    set?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    disconnect?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    delete?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    connect?: ComboPlanServiceWhereUniqueInput | ComboPlanServiceWhereUniqueInput[]
    update?: ComboPlanServiceUpdateWithWhereUniqueWithoutServiceInput | ComboPlanServiceUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ComboPlanServiceUpdateManyWithWhereWithoutServiceInput | ComboPlanServiceUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ComboPlanServiceScalarWhereInput | ComboPlanServiceScalarWhereInput[]
  }

  export type CouponUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<CouponCreateWithoutServiceInput, CouponUncheckedCreateWithoutServiceInput> | CouponCreateWithoutServiceInput[] | CouponUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: CouponCreateOrConnectWithoutServiceInput | CouponCreateOrConnectWithoutServiceInput[]
    upsert?: CouponUpsertWithWhereUniqueWithoutServiceInput | CouponUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: CouponCreateManyServiceInputEnvelope
    set?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    disconnect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    delete?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    connect?: CouponWhereUniqueInput | CouponWhereUniqueInput[]
    update?: CouponUpdateWithWhereUniqueWithoutServiceInput | CouponUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: CouponUpdateManyWithWhereWithoutServiceInput | CouponUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: CouponScalarWhereInput | CouponScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutServiceTradingInput = {
    create?: XOR<ServiceCreateWithoutServiceTradingInput, ServiceUncheckedCreateWithoutServiceTradingInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceTradingInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceUpdateOneRequiredWithoutServiceTradingNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceTradingInput, ServiceUncheckedCreateWithoutServiceTradingInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceTradingInput
    upsert?: ServiceUpsertWithoutServiceTradingInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutServiceTradingInput, ServiceUpdateWithoutServiceTradingInput>, ServiceUncheckedUpdateWithoutServiceTradingInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumVerificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationType | EnumVerificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationTypeFilter<$PrismaModel> | $Enums.VerificationType
  }

  export type NestedEnumVerificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationType | EnumVerificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationType[] | ListEnumVerificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.VerificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationTypeFilter<$PrismaModel>
    _max?: NestedEnumVerificationTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type AccountCreateWithoutUserInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserDocumentsCreateWithoutUserInput = {
    id?: string
    documentUrl: string
    reviewedDocumentUrl?: string | null
    status?: $Enums.DocumentStatus
    reviewedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutUserDocumentsInput
  }

  export type UserDocumentsUncheckedCreateWithoutUserInput = {
    id?: string
    serviceId: string
    documentUrl: string
    reviewedDocumentUrl?: string | null
    status?: $Enums.DocumentStatus
    reviewedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDocumentsCreateOrConnectWithoutUserInput = {
    where: UserDocumentsWhereUniqueInput
    create: XOR<UserDocumentsCreateWithoutUserInput, UserDocumentsUncheckedCreateWithoutUserInput>
  }

  export type UserDocumentsCreateManyUserInputEnvelope = {
    data: UserDocumentsCreateManyUserInput | UserDocumentsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPurchasedServicesCreateWithoutUserInput = {
    id?: string
    purchaseDate?: Date | string
    expiryDate: Date | string
    planDays: number
    planDiscount: number
    agreementAcceptedAt?: Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
    service: ServiceCreateNestedOneWithoutPurchasedServicesInput
  }

  export type UserPurchasedServicesUncheckedCreateWithoutUserInput = {
    id?: string
    serviceId: string
    purchaseDate?: Date | string
    expiryDate: Date | string
    planDays: number
    planDiscount: number
    agreementAcceptedAt?: Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPurchasedServicesCreateOrConnectWithoutUserInput = {
    where: UserPurchasedServicesWhereUniqueInput
    create: XOR<UserPurchasedServicesCreateWithoutUserInput, UserPurchasedServicesUncheckedCreateWithoutUserInput>
  }

  export type UserPurchasedServicesCreateManyUserInputEnvelope = {
    data: UserPurchasedServicesCreateManyUserInput | UserPurchasedServicesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type panVerificationDataCreateWithoutUserInput = {
    provider: string
    result: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type panVerificationDataUncheckedCreateWithoutUserInput = {
    provider: string
    result: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type panVerificationDataCreateOrConnectWithoutUserInput = {
    where: panVerificationDataWhereUniqueInput
    create: XOR<panVerificationDataCreateWithoutUserInput, panVerificationDataUncheckedCreateWithoutUserInput>
  }

  export type panVerificationDataCreateManyUserInputEnvelope = {
    data: panVerificationDataCreateManyUserInput | panVerificationDataCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    service?: ServiceCreateNestedOneWithoutTransactionInput
    comboPlan?: ComboPlanCreateNestedOneWithoutTransactionInput
    coupon?: CouponCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    couponId?: string | null
    serviceId?: string | null
    comboPlanId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type UserDocumentsUpsertWithWhereUniqueWithoutUserInput = {
    where: UserDocumentsWhereUniqueInput
    update: XOR<UserDocumentsUpdateWithoutUserInput, UserDocumentsUncheckedUpdateWithoutUserInput>
    create: XOR<UserDocumentsCreateWithoutUserInput, UserDocumentsUncheckedCreateWithoutUserInput>
  }

  export type UserDocumentsUpdateWithWhereUniqueWithoutUserInput = {
    where: UserDocumentsWhereUniqueInput
    data: XOR<UserDocumentsUpdateWithoutUserInput, UserDocumentsUncheckedUpdateWithoutUserInput>
  }

  export type UserDocumentsUpdateManyWithWhereWithoutUserInput = {
    where: UserDocumentsScalarWhereInput
    data: XOR<UserDocumentsUpdateManyMutationInput, UserDocumentsUncheckedUpdateManyWithoutUserInput>
  }

  export type UserDocumentsScalarWhereInput = {
    AND?: UserDocumentsScalarWhereInput | UserDocumentsScalarWhereInput[]
    OR?: UserDocumentsScalarWhereInput[]
    NOT?: UserDocumentsScalarWhereInput | UserDocumentsScalarWhereInput[]
    id?: StringFilter<"UserDocuments"> | string
    serviceId?: StringFilter<"UserDocuments"> | string
    userId?: StringFilter<"UserDocuments"> | string
    documentUrl?: StringFilter<"UserDocuments"> | string
    reviewedDocumentUrl?: StringNullableFilter<"UserDocuments"> | string | null
    status?: EnumDocumentStatusFilter<"UserDocuments"> | $Enums.DocumentStatus
    reviewedBy?: StringNullableFilter<"UserDocuments"> | string | null
    createdAt?: DateTimeFilter<"UserDocuments"> | Date | string
    updatedAt?: DateTimeFilter<"UserDocuments"> | Date | string
  }

  export type UserPurchasedServicesUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPurchasedServicesWhereUniqueInput
    update: XOR<UserPurchasedServicesUpdateWithoutUserInput, UserPurchasedServicesUncheckedUpdateWithoutUserInput>
    create: XOR<UserPurchasedServicesCreateWithoutUserInput, UserPurchasedServicesUncheckedCreateWithoutUserInput>
  }

  export type UserPurchasedServicesUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPurchasedServicesWhereUniqueInput
    data: XOR<UserPurchasedServicesUpdateWithoutUserInput, UserPurchasedServicesUncheckedUpdateWithoutUserInput>
  }

  export type UserPurchasedServicesUpdateManyWithWhereWithoutUserInput = {
    where: UserPurchasedServicesScalarWhereInput
    data: XOR<UserPurchasedServicesUpdateManyMutationInput, UserPurchasedServicesUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPurchasedServicesScalarWhereInput = {
    AND?: UserPurchasedServicesScalarWhereInput | UserPurchasedServicesScalarWhereInput[]
    OR?: UserPurchasedServicesScalarWhereInput[]
    NOT?: UserPurchasedServicesScalarWhereInput | UserPurchasedServicesScalarWhereInput[]
    id?: StringFilter<"UserPurchasedServices"> | string
    userId?: StringFilter<"UserPurchasedServices"> | string
    serviceId?: StringFilter<"UserPurchasedServices"> | string
    purchaseDate?: DateTimeFilter<"UserPurchasedServices"> | Date | string
    expiryDate?: DateTimeFilter<"UserPurchasedServices"> | Date | string
    planDays?: IntFilter<"UserPurchasedServices"> | number
    planDiscount?: FloatFilter<"UserPurchasedServices"> | number
    agreementAcceptedAt?: DateTimeNullableFilter<"UserPurchasedServices"> | Date | string | null
    agreementData?: JsonNullableFilter<"UserPurchasedServices">
  }

  export type panVerificationDataUpsertWithWhereUniqueWithoutUserInput = {
    where: panVerificationDataWhereUniqueInput
    update: XOR<panVerificationDataUpdateWithoutUserInput, panVerificationDataUncheckedUpdateWithoutUserInput>
    create: XOR<panVerificationDataCreateWithoutUserInput, panVerificationDataUncheckedCreateWithoutUserInput>
  }

  export type panVerificationDataUpdateWithWhereUniqueWithoutUserInput = {
    where: panVerificationDataWhereUniqueInput
    data: XOR<panVerificationDataUpdateWithoutUserInput, panVerificationDataUncheckedUpdateWithoutUserInput>
  }

  export type panVerificationDataUpdateManyWithWhereWithoutUserInput = {
    where: panVerificationDataScalarWhereInput
    data: XOR<panVerificationDataUpdateManyMutationInput, panVerificationDataUncheckedUpdateManyWithoutUserInput>
  }

  export type panVerificationDataScalarWhereInput = {
    AND?: panVerificationDataScalarWhereInput | panVerificationDataScalarWhereInput[]
    OR?: panVerificationDataScalarWhereInput[]
    NOT?: panVerificationDataScalarWhereInput | panVerificationDataScalarWhereInput[]
    userId?: StringFilter<"panVerificationData"> | string
    provider?: StringFilter<"panVerificationData"> | string
    result?: JsonFilter<"panVerificationData">
    status?: StringFilter<"panVerificationData"> | string
    createdAt?: DateTimeFilter<"panVerificationData"> | Date | string
    updatedAt?: DateTimeFilter<"panVerificationData"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    orderId?: StringNullableFilter<"Transaction"> | string | null
    paymentId?: StringNullableFilter<"Transaction"> | string | null
    couponId?: StringNullableFilter<"Transaction"> | string | null
    userId?: StringFilter<"Transaction"> | string
    serviceId?: StringNullableFilter<"Transaction"> | string | null
    comboPlanId?: StringNullableFilter<"Transaction"> | string | null
    amount?: FloatFilter<"Transaction"> | number
    tenure?: JsonNullableFilter<"Transaction">
    currency?: StringFilter<"Transaction"> | string
    status?: StringFilter<"Transaction"> | string
    paymentGateway?: StringFilter<"Transaction"> | string
    idempotencyKey?: StringNullableFilter<"Transaction"> | string | null
    webhookResponse?: JsonNullableFilter<"Transaction">
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    extraData?: JsonNullableFilter<"Transaction">
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    phone?: string | null
    username?: string | null
    image?: string | null
    password?: string | null
    dob?: string | null
    pan?: string | null
    aadharNumber?: string | null
    gstin?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    zip?: string | null
    panVerified?: Date | string | null
    termsAccepted?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    isBanned?: boolean
    userType?: $Enums.UserType
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: UserDocumentsCreateNestedManyWithoutUserInput
    purchasedServices?: UserPurchasedServicesCreateNestedManyWithoutUserInput
    panVerificationData?: panVerificationDataCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    phone?: string | null
    username?: string | null
    image?: string | null
    password?: string | null
    dob?: string | null
    pan?: string | null
    aadharNumber?: string | null
    gstin?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    zip?: string | null
    panVerified?: Date | string | null
    termsAccepted?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    isBanned?: boolean
    userType?: $Enums.UserType
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: UserDocumentsUncheckedCreateNestedManyWithoutUserInput
    purchasedServices?: UserPurchasedServicesUncheckedCreateNestedManyWithoutUserInput
    panVerificationData?: panVerificationDataUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    panVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: UserDocumentsUpdateManyWithoutUserNestedInput
    purchasedServices?: UserPurchasedServicesUpdateManyWithoutUserNestedInput
    panVerificationData?: panVerificationDataUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    panVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: UserDocumentsUncheckedUpdateManyWithoutUserNestedInput
    purchasedServices?: UserPurchasedServicesUncheckedUpdateManyWithoutUserNestedInput
    panVerificationData?: panVerificationDataUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPanVerificationDataInput = {
    id?: string
    name?: string | null
    email: string
    phone?: string | null
    username?: string | null
    image?: string | null
    password?: string | null
    dob?: string | null
    pan?: string | null
    aadharNumber?: string | null
    gstin?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    zip?: string | null
    panVerified?: Date | string | null
    termsAccepted?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    isBanned?: boolean
    userType?: $Enums.UserType
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    documents?: UserDocumentsCreateNestedManyWithoutUserInput
    purchasedServices?: UserPurchasedServicesCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPanVerificationDataInput = {
    id?: string
    name?: string | null
    email: string
    phone?: string | null
    username?: string | null
    image?: string | null
    password?: string | null
    dob?: string | null
    pan?: string | null
    aadharNumber?: string | null
    gstin?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    zip?: string | null
    panVerified?: Date | string | null
    termsAccepted?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    isBanned?: boolean
    userType?: $Enums.UserType
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    documents?: UserDocumentsUncheckedCreateNestedManyWithoutUserInput
    purchasedServices?: UserPurchasedServicesUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPanVerificationDataInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPanVerificationDataInput, UserUncheckedCreateWithoutPanVerificationDataInput>
  }

  export type UserUpsertWithoutPanVerificationDataInput = {
    update: XOR<UserUpdateWithoutPanVerificationDataInput, UserUncheckedUpdateWithoutPanVerificationDataInput>
    create: XOR<UserCreateWithoutPanVerificationDataInput, UserUncheckedCreateWithoutPanVerificationDataInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPanVerificationDataInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPanVerificationDataInput, UserUncheckedUpdateWithoutPanVerificationDataInput>
  }

  export type UserUpdateWithoutPanVerificationDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    panVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    documents?: UserDocumentsUpdateManyWithoutUserNestedInput
    purchasedServices?: UserPurchasedServicesUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPanVerificationDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    panVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    documents?: UserDocumentsUncheckedUpdateManyWithoutUserNestedInput
    purchasedServices?: UserPurchasedServicesUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPurchasedServicesInput = {
    id?: string
    name?: string | null
    email: string
    phone?: string | null
    username?: string | null
    image?: string | null
    password?: string | null
    dob?: string | null
    pan?: string | null
    aadharNumber?: string | null
    gstin?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    zip?: string | null
    panVerified?: Date | string | null
    termsAccepted?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    isBanned?: boolean
    userType?: $Enums.UserType
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    documents?: UserDocumentsCreateNestedManyWithoutUserInput
    panVerificationData?: panVerificationDataCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPurchasedServicesInput = {
    id?: string
    name?: string | null
    email: string
    phone?: string | null
    username?: string | null
    image?: string | null
    password?: string | null
    dob?: string | null
    pan?: string | null
    aadharNumber?: string | null
    gstin?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    zip?: string | null
    panVerified?: Date | string | null
    termsAccepted?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    isBanned?: boolean
    userType?: $Enums.UserType
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    documents?: UserDocumentsUncheckedCreateNestedManyWithoutUserInput
    panVerificationData?: panVerificationDataUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPurchasedServicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchasedServicesInput, UserUncheckedCreateWithoutPurchasedServicesInput>
  }

  export type ServiceCreateWithoutPurchasedServicesInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: ServiceAgreementCreateNestedManyWithoutServiceInput
    serviceTrading?: ServiceTradingCreateNestedOneWithoutServiceInput
    userDocuments?: UserDocumentsCreateNestedManyWithoutServiceInput
    Transaction?: TransactionCreateNestedManyWithoutServiceInput
    ComboPlanService?: ComboPlanServiceCreateNestedManyWithoutServiceInput
    coupon?: CouponCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutPurchasedServicesInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: ServiceAgreementUncheckedCreateNestedManyWithoutServiceInput
    serviceTrading?: ServiceTradingUncheckedCreateNestedOneWithoutServiceInput
    userDocuments?: UserDocumentsUncheckedCreateNestedManyWithoutServiceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutServiceInput
    ComboPlanService?: ComboPlanServiceUncheckedCreateNestedManyWithoutServiceInput
    coupon?: CouponUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutPurchasedServicesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutPurchasedServicesInput, ServiceUncheckedCreateWithoutPurchasedServicesInput>
  }

  export type UserUpsertWithoutPurchasedServicesInput = {
    update: XOR<UserUpdateWithoutPurchasedServicesInput, UserUncheckedUpdateWithoutPurchasedServicesInput>
    create: XOR<UserCreateWithoutPurchasedServicesInput, UserUncheckedCreateWithoutPurchasedServicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchasedServicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchasedServicesInput, UserUncheckedUpdateWithoutPurchasedServicesInput>
  }

  export type UserUpdateWithoutPurchasedServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    panVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    documents?: UserDocumentsUpdateManyWithoutUserNestedInput
    panVerificationData?: panVerificationDataUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchasedServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    panVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    documents?: UserDocumentsUncheckedUpdateManyWithoutUserNestedInput
    panVerificationData?: panVerificationDataUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceUpsertWithoutPurchasedServicesInput = {
    update: XOR<ServiceUpdateWithoutPurchasedServicesInput, ServiceUncheckedUpdateWithoutPurchasedServicesInput>
    create: XOR<ServiceCreateWithoutPurchasedServicesInput, ServiceUncheckedCreateWithoutPurchasedServicesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutPurchasedServicesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutPurchasedServicesInput, ServiceUncheckedUpdateWithoutPurchasedServicesInput>
  }

  export type ServiceUpdateWithoutPurchasedServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: ServiceAgreementUpdateManyWithoutServiceNestedInput
    serviceTrading?: ServiceTradingUpdateOneWithoutServiceNestedInput
    userDocuments?: UserDocumentsUpdateManyWithoutServiceNestedInput
    Transaction?: TransactionUpdateManyWithoutServiceNestedInput
    ComboPlanService?: ComboPlanServiceUpdateManyWithoutServiceNestedInput
    coupon?: CouponUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutPurchasedServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: ServiceAgreementUncheckedUpdateManyWithoutServiceNestedInput
    serviceTrading?: ServiceTradingUncheckedUpdateOneWithoutServiceNestedInput
    userDocuments?: UserDocumentsUncheckedUpdateManyWithoutServiceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutServiceNestedInput
    ComboPlanService?: ComboPlanServiceUncheckedUpdateManyWithoutServiceNestedInput
    coupon?: CouponUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ComboPlanCreateWithoutCouponInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    taxPercent?: number | null
    active?: boolean | null
    tenureDiscounts: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agreement?: ComboPlanAgreementCreateNestedManyWithoutComboPlanInput
    services?: ComboPlanServiceCreateNestedManyWithoutComboPlanInput
    Transaction?: TransactionCreateNestedManyWithoutComboPlanInput
  }

  export type ComboPlanUncheckedCreateWithoutCouponInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    taxPercent?: number | null
    active?: boolean | null
    tenureDiscounts: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agreement?: ComboPlanAgreementUncheckedCreateNestedManyWithoutComboPlanInput
    services?: ComboPlanServiceUncheckedCreateNestedManyWithoutComboPlanInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutComboPlanInput
  }

  export type ComboPlanCreateOrConnectWithoutCouponInput = {
    where: ComboPlanWhereUniqueInput
    create: XOR<ComboPlanCreateWithoutCouponInput, ComboPlanUncheckedCreateWithoutCouponInput>
  }

  export type ServiceCreateWithoutCouponInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: ServiceAgreementCreateNestedManyWithoutServiceInput
    serviceTrading?: ServiceTradingCreateNestedOneWithoutServiceInput
    purchasedServices?: UserPurchasedServicesCreateNestedManyWithoutServiceInput
    userDocuments?: UserDocumentsCreateNestedManyWithoutServiceInput
    Transaction?: TransactionCreateNestedManyWithoutServiceInput
    ComboPlanService?: ComboPlanServiceCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutCouponInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: ServiceAgreementUncheckedCreateNestedManyWithoutServiceInput
    serviceTrading?: ServiceTradingUncheckedCreateNestedOneWithoutServiceInput
    purchasedServices?: UserPurchasedServicesUncheckedCreateNestedManyWithoutServiceInput
    userDocuments?: UserDocumentsUncheckedCreateNestedManyWithoutServiceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutServiceInput
    ComboPlanService?: ComboPlanServiceUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutCouponInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutCouponInput, ServiceUncheckedCreateWithoutCouponInput>
  }

  export type TransactionCreateWithoutCouponInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutTransactionInput
    service?: ServiceCreateNestedOneWithoutTransactionInput
    comboPlan?: ComboPlanCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCouponInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    userId: string
    serviceId?: string | null
    comboPlanId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionCreateOrConnectWithoutCouponInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCouponInput, TransactionUncheckedCreateWithoutCouponInput>
  }

  export type TransactionCreateManyCouponInputEnvelope = {
    data: TransactionCreateManyCouponInput | TransactionCreateManyCouponInput[]
    skipDuplicates?: boolean
  }

  export type ComboPlanUpsertWithoutCouponInput = {
    update: XOR<ComboPlanUpdateWithoutCouponInput, ComboPlanUncheckedUpdateWithoutCouponInput>
    create: XOR<ComboPlanCreateWithoutCouponInput, ComboPlanUncheckedCreateWithoutCouponInput>
    where?: ComboPlanWhereInput
  }

  export type ComboPlanUpdateToOneWithWhereWithoutCouponInput = {
    where?: ComboPlanWhereInput
    data: XOR<ComboPlanUpdateWithoutCouponInput, ComboPlanUncheckedUpdateWithoutCouponInput>
  }

  export type ComboPlanUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenureDiscounts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: ComboPlanAgreementUpdateManyWithoutComboPlanNestedInput
    services?: ComboPlanServiceUpdateManyWithoutComboPlanNestedInput
    Transaction?: TransactionUpdateManyWithoutComboPlanNestedInput
  }

  export type ComboPlanUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenureDiscounts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: ComboPlanAgreementUncheckedUpdateManyWithoutComboPlanNestedInput
    services?: ComboPlanServiceUncheckedUpdateManyWithoutComboPlanNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutComboPlanNestedInput
  }

  export type ServiceUpsertWithoutCouponInput = {
    update: XOR<ServiceUpdateWithoutCouponInput, ServiceUncheckedUpdateWithoutCouponInput>
    create: XOR<ServiceCreateWithoutCouponInput, ServiceUncheckedCreateWithoutCouponInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutCouponInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutCouponInput, ServiceUncheckedUpdateWithoutCouponInput>
  }

  export type ServiceUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: ServiceAgreementUpdateManyWithoutServiceNestedInput
    serviceTrading?: ServiceTradingUpdateOneWithoutServiceNestedInput
    purchasedServices?: UserPurchasedServicesUpdateManyWithoutServiceNestedInput
    userDocuments?: UserDocumentsUpdateManyWithoutServiceNestedInput
    Transaction?: TransactionUpdateManyWithoutServiceNestedInput
    ComboPlanService?: ComboPlanServiceUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: ServiceAgreementUncheckedUpdateManyWithoutServiceNestedInput
    serviceTrading?: ServiceTradingUncheckedUpdateOneWithoutServiceNestedInput
    purchasedServices?: UserPurchasedServicesUncheckedUpdateManyWithoutServiceNestedInput
    userDocuments?: UserDocumentsUncheckedUpdateManyWithoutServiceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutServiceNestedInput
    ComboPlanService?: ComboPlanServiceUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutCouponInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCouponInput, TransactionUncheckedUpdateWithoutCouponInput>
    create: XOR<TransactionCreateWithoutCouponInput, TransactionUncheckedCreateWithoutCouponInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCouponInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCouponInput, TransactionUncheckedUpdateWithoutCouponInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCouponInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCouponInput>
  }

  export type UserCreateWithoutTransactionInput = {
    id?: string
    name?: string | null
    email: string
    phone?: string | null
    username?: string | null
    image?: string | null
    password?: string | null
    dob?: string | null
    pan?: string | null
    aadharNumber?: string | null
    gstin?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    zip?: string | null
    panVerified?: Date | string | null
    termsAccepted?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    isBanned?: boolean
    userType?: $Enums.UserType
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    documents?: UserDocumentsCreateNestedManyWithoutUserInput
    purchasedServices?: UserPurchasedServicesCreateNestedManyWithoutUserInput
    panVerificationData?: panVerificationDataCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionInput = {
    id?: string
    name?: string | null
    email: string
    phone?: string | null
    username?: string | null
    image?: string | null
    password?: string | null
    dob?: string | null
    pan?: string | null
    aadharNumber?: string | null
    gstin?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    zip?: string | null
    panVerified?: Date | string | null
    termsAccepted?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    isBanned?: boolean
    userType?: $Enums.UserType
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    documents?: UserDocumentsUncheckedCreateNestedManyWithoutUserInput
    purchasedServices?: UserPurchasedServicesUncheckedCreateNestedManyWithoutUserInput
    panVerificationData?: panVerificationDataUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
  }

  export type ServiceCreateWithoutTransactionInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: ServiceAgreementCreateNestedManyWithoutServiceInput
    serviceTrading?: ServiceTradingCreateNestedOneWithoutServiceInput
    purchasedServices?: UserPurchasedServicesCreateNestedManyWithoutServiceInput
    userDocuments?: UserDocumentsCreateNestedManyWithoutServiceInput
    ComboPlanService?: ComboPlanServiceCreateNestedManyWithoutServiceInput
    coupon?: CouponCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutTransactionInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: ServiceAgreementUncheckedCreateNestedManyWithoutServiceInput
    serviceTrading?: ServiceTradingUncheckedCreateNestedOneWithoutServiceInput
    purchasedServices?: UserPurchasedServicesUncheckedCreateNestedManyWithoutServiceInput
    userDocuments?: UserDocumentsUncheckedCreateNestedManyWithoutServiceInput
    ComboPlanService?: ComboPlanServiceUncheckedCreateNestedManyWithoutServiceInput
    coupon?: CouponUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutTransactionInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutTransactionInput, ServiceUncheckedCreateWithoutTransactionInput>
  }

  export type ComboPlanCreateWithoutTransactionInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    taxPercent?: number | null
    active?: boolean | null
    tenureDiscounts: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agreement?: ComboPlanAgreementCreateNestedManyWithoutComboPlanInput
    services?: ComboPlanServiceCreateNestedManyWithoutComboPlanInput
    coupon?: CouponCreateNestedManyWithoutComboPlanInput
  }

  export type ComboPlanUncheckedCreateWithoutTransactionInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    taxPercent?: number | null
    active?: boolean | null
    tenureDiscounts: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agreement?: ComboPlanAgreementUncheckedCreateNestedManyWithoutComboPlanInput
    services?: ComboPlanServiceUncheckedCreateNestedManyWithoutComboPlanInput
    coupon?: CouponUncheckedCreateNestedManyWithoutComboPlanInput
  }

  export type ComboPlanCreateOrConnectWithoutTransactionInput = {
    where: ComboPlanWhereUniqueInput
    create: XOR<ComboPlanCreateWithoutTransactionInput, ComboPlanUncheckedCreateWithoutTransactionInput>
  }

  export type CouponCreateWithoutTransactionsInput = {
    id?: string
    code: string
    description?: string | null
    percentOff: number
    expiryDate: Date | string
    minAmount?: number
    maxAmount?: number | null
    planDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comboPlan?: ComboPlanCreateNestedOneWithoutCouponInput
    service?: ServiceCreateNestedOneWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutTransactionsInput = {
    id?: string
    code: string
    description?: string | null
    percentOff: number
    expiryDate: Date | string
    minAmount?: number
    maxAmount?: number | null
    serviceId?: string | null
    comboPlanId?: string | null
    planDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CouponCreateOrConnectWithoutTransactionsInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutTransactionsInput, CouponUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpsertWithoutTransactionInput = {
    update: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
    create: XOR<UserCreateWithoutTransactionInput, UserUncheckedCreateWithoutTransactionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionInput, UserUncheckedUpdateWithoutTransactionInput>
  }

  export type UserUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    panVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    documents?: UserDocumentsUpdateManyWithoutUserNestedInput
    purchasedServices?: UserPurchasedServicesUpdateManyWithoutUserNestedInput
    panVerificationData?: panVerificationDataUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    panVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    documents?: UserDocumentsUncheckedUpdateManyWithoutUserNestedInput
    purchasedServices?: UserPurchasedServicesUncheckedUpdateManyWithoutUserNestedInput
    panVerificationData?: panVerificationDataUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceUpsertWithoutTransactionInput = {
    update: XOR<ServiceUpdateWithoutTransactionInput, ServiceUncheckedUpdateWithoutTransactionInput>
    create: XOR<ServiceCreateWithoutTransactionInput, ServiceUncheckedCreateWithoutTransactionInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutTransactionInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutTransactionInput, ServiceUncheckedUpdateWithoutTransactionInput>
  }

  export type ServiceUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: ServiceAgreementUpdateManyWithoutServiceNestedInput
    serviceTrading?: ServiceTradingUpdateOneWithoutServiceNestedInput
    purchasedServices?: UserPurchasedServicesUpdateManyWithoutServiceNestedInput
    userDocuments?: UserDocumentsUpdateManyWithoutServiceNestedInput
    ComboPlanService?: ComboPlanServiceUpdateManyWithoutServiceNestedInput
    coupon?: CouponUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: ServiceAgreementUncheckedUpdateManyWithoutServiceNestedInput
    serviceTrading?: ServiceTradingUncheckedUpdateOneWithoutServiceNestedInput
    purchasedServices?: UserPurchasedServicesUncheckedUpdateManyWithoutServiceNestedInput
    userDocuments?: UserDocumentsUncheckedUpdateManyWithoutServiceNestedInput
    ComboPlanService?: ComboPlanServiceUncheckedUpdateManyWithoutServiceNestedInput
    coupon?: CouponUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ComboPlanUpsertWithoutTransactionInput = {
    update: XOR<ComboPlanUpdateWithoutTransactionInput, ComboPlanUncheckedUpdateWithoutTransactionInput>
    create: XOR<ComboPlanCreateWithoutTransactionInput, ComboPlanUncheckedCreateWithoutTransactionInput>
    where?: ComboPlanWhereInput
  }

  export type ComboPlanUpdateToOneWithWhereWithoutTransactionInput = {
    where?: ComboPlanWhereInput
    data: XOR<ComboPlanUpdateWithoutTransactionInput, ComboPlanUncheckedUpdateWithoutTransactionInput>
  }

  export type ComboPlanUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenureDiscounts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: ComboPlanAgreementUpdateManyWithoutComboPlanNestedInput
    services?: ComboPlanServiceUpdateManyWithoutComboPlanNestedInput
    coupon?: CouponUpdateManyWithoutComboPlanNestedInput
  }

  export type ComboPlanUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenureDiscounts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: ComboPlanAgreementUncheckedUpdateManyWithoutComboPlanNestedInput
    services?: ComboPlanServiceUncheckedUpdateManyWithoutComboPlanNestedInput
    coupon?: CouponUncheckedUpdateManyWithoutComboPlanNestedInput
  }

  export type CouponUpsertWithoutTransactionsInput = {
    update: XOR<CouponUpdateWithoutTransactionsInput, CouponUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CouponCreateWithoutTransactionsInput, CouponUncheckedCreateWithoutTransactionsInput>
    where?: CouponWhereInput
  }

  export type CouponUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CouponWhereInput
    data: XOR<CouponUpdateWithoutTransactionsInput, CouponUncheckedUpdateWithoutTransactionsInput>
  }

  export type CouponUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: FloatFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    planDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comboPlan?: ComboPlanUpdateOneWithoutCouponNestedInput
    service?: ServiceUpdateOneWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: FloatFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    comboPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    planDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutDocumentsInput = {
    id?: string
    name?: string | null
    email: string
    phone?: string | null
    username?: string | null
    image?: string | null
    password?: string | null
    dob?: string | null
    pan?: string | null
    aadharNumber?: string | null
    gstin?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    zip?: string | null
    panVerified?: Date | string | null
    termsAccepted?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    isBanned?: boolean
    userType?: $Enums.UserType
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    purchasedServices?: UserPurchasedServicesCreateNestedManyWithoutUserInput
    panVerificationData?: panVerificationDataCreateNestedManyWithoutUserInput
    transaction?: TransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name?: string | null
    email: string
    phone?: string | null
    username?: string | null
    image?: string | null
    password?: string | null
    dob?: string | null
    pan?: string | null
    aadharNumber?: string | null
    gstin?: string | null
    address?: string | null
    state?: string | null
    city?: string | null
    zip?: string | null
    panVerified?: Date | string | null
    termsAccepted?: Date | string | null
    emailVerified?: Date | string | null
    phoneVerified?: Date | string | null
    isBanned?: boolean
    userType?: $Enums.UserType
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    purchasedServices?: UserPurchasedServicesUncheckedCreateNestedManyWithoutUserInput
    panVerificationData?: panVerificationDataUncheckedCreateNestedManyWithoutUserInput
    transaction?: TransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type ServiceCreateWithoutUserDocumentsInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: ServiceAgreementCreateNestedManyWithoutServiceInput
    serviceTrading?: ServiceTradingCreateNestedOneWithoutServiceInput
    purchasedServices?: UserPurchasedServicesCreateNestedManyWithoutServiceInput
    Transaction?: TransactionCreateNestedManyWithoutServiceInput
    ComboPlanService?: ComboPlanServiceCreateNestedManyWithoutServiceInput
    coupon?: CouponCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutUserDocumentsInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: ServiceAgreementUncheckedCreateNestedManyWithoutServiceInput
    serviceTrading?: ServiceTradingUncheckedCreateNestedOneWithoutServiceInput
    purchasedServices?: UserPurchasedServicesUncheckedCreateNestedManyWithoutServiceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutServiceInput
    ComboPlanService?: ComboPlanServiceUncheckedCreateNestedManyWithoutServiceInput
    coupon?: CouponUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutUserDocumentsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutUserDocumentsInput, ServiceUncheckedCreateWithoutUserDocumentsInput>
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    panVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    purchasedServices?: UserPurchasedServicesUpdateManyWithoutUserNestedInput
    panVerificationData?: panVerificationDataUpdateManyWithoutUserNestedInput
    transaction?: TransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableStringFieldUpdateOperationsInput | string | null
    pan?: NullableStringFieldUpdateOperationsInput | string | null
    aadharNumber?: NullableStringFieldUpdateOperationsInput | string | null
    gstin?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    panVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phoneVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    purchasedServices?: UserPurchasedServicesUncheckedUpdateManyWithoutUserNestedInput
    panVerificationData?: panVerificationDataUncheckedUpdateManyWithoutUserNestedInput
    transaction?: TransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ServiceUpsertWithoutUserDocumentsInput = {
    update: XOR<ServiceUpdateWithoutUserDocumentsInput, ServiceUncheckedUpdateWithoutUserDocumentsInput>
    create: XOR<ServiceCreateWithoutUserDocumentsInput, ServiceUncheckedCreateWithoutUserDocumentsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutUserDocumentsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutUserDocumentsInput, ServiceUncheckedUpdateWithoutUserDocumentsInput>
  }

  export type ServiceUpdateWithoutUserDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: ServiceAgreementUpdateManyWithoutServiceNestedInput
    serviceTrading?: ServiceTradingUpdateOneWithoutServiceNestedInput
    purchasedServices?: UserPurchasedServicesUpdateManyWithoutServiceNestedInput
    Transaction?: TransactionUpdateManyWithoutServiceNestedInput
    ComboPlanService?: ComboPlanServiceUpdateManyWithoutServiceNestedInput
    coupon?: CouponUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutUserDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: ServiceAgreementUncheckedUpdateManyWithoutServiceNestedInput
    serviceTrading?: ServiceTradingUncheckedUpdateOneWithoutServiceNestedInput
    purchasedServices?: UserPurchasedServicesUncheckedUpdateManyWithoutServiceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutServiceNestedInput
    ComboPlanService?: ComboPlanServiceUncheckedUpdateManyWithoutServiceNestedInput
    coupon?: CouponUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceAgreementCreateWithoutAgreementInput = {
    id?: string
    service: ServiceCreateNestedOneWithoutAgreementsInput
  }

  export type ServiceAgreementUncheckedCreateWithoutAgreementInput = {
    id?: string
    serviceId: string
  }

  export type ServiceAgreementCreateOrConnectWithoutAgreementInput = {
    where: ServiceAgreementWhereUniqueInput
    create: XOR<ServiceAgreementCreateWithoutAgreementInput, ServiceAgreementUncheckedCreateWithoutAgreementInput>
  }

  export type ServiceAgreementCreateManyAgreementInputEnvelope = {
    data: ServiceAgreementCreateManyAgreementInput | ServiceAgreementCreateManyAgreementInput[]
    skipDuplicates?: boolean
  }

  export type ComboPlanAgreementCreateWithoutAgreementInput = {
    id?: string
    comboPlan: ComboPlanCreateNestedOneWithoutAgreementInput
  }

  export type ComboPlanAgreementUncheckedCreateWithoutAgreementInput = {
    id?: string
    comboPlanId: string
  }

  export type ComboPlanAgreementCreateOrConnectWithoutAgreementInput = {
    where: ComboPlanAgreementWhereUniqueInput
    create: XOR<ComboPlanAgreementCreateWithoutAgreementInput, ComboPlanAgreementUncheckedCreateWithoutAgreementInput>
  }

  export type ComboPlanAgreementCreateManyAgreementInputEnvelope = {
    data: ComboPlanAgreementCreateManyAgreementInput | ComboPlanAgreementCreateManyAgreementInput[]
    skipDuplicates?: boolean
  }

  export type ServiceAgreementUpsertWithWhereUniqueWithoutAgreementInput = {
    where: ServiceAgreementWhereUniqueInput
    update: XOR<ServiceAgreementUpdateWithoutAgreementInput, ServiceAgreementUncheckedUpdateWithoutAgreementInput>
    create: XOR<ServiceAgreementCreateWithoutAgreementInput, ServiceAgreementUncheckedCreateWithoutAgreementInput>
  }

  export type ServiceAgreementUpdateWithWhereUniqueWithoutAgreementInput = {
    where: ServiceAgreementWhereUniqueInput
    data: XOR<ServiceAgreementUpdateWithoutAgreementInput, ServiceAgreementUncheckedUpdateWithoutAgreementInput>
  }

  export type ServiceAgreementUpdateManyWithWhereWithoutAgreementInput = {
    where: ServiceAgreementScalarWhereInput
    data: XOR<ServiceAgreementUpdateManyMutationInput, ServiceAgreementUncheckedUpdateManyWithoutAgreementInput>
  }

  export type ServiceAgreementScalarWhereInput = {
    AND?: ServiceAgreementScalarWhereInput | ServiceAgreementScalarWhereInput[]
    OR?: ServiceAgreementScalarWhereInput[]
    NOT?: ServiceAgreementScalarWhereInput | ServiceAgreementScalarWhereInput[]
    id?: StringFilter<"ServiceAgreement"> | string
    serviceId?: StringFilter<"ServiceAgreement"> | string
    agreementId?: StringFilter<"ServiceAgreement"> | string
  }

  export type ComboPlanAgreementUpsertWithWhereUniqueWithoutAgreementInput = {
    where: ComboPlanAgreementWhereUniqueInput
    update: XOR<ComboPlanAgreementUpdateWithoutAgreementInput, ComboPlanAgreementUncheckedUpdateWithoutAgreementInput>
    create: XOR<ComboPlanAgreementCreateWithoutAgreementInput, ComboPlanAgreementUncheckedCreateWithoutAgreementInput>
  }

  export type ComboPlanAgreementUpdateWithWhereUniqueWithoutAgreementInput = {
    where: ComboPlanAgreementWhereUniqueInput
    data: XOR<ComboPlanAgreementUpdateWithoutAgreementInput, ComboPlanAgreementUncheckedUpdateWithoutAgreementInput>
  }

  export type ComboPlanAgreementUpdateManyWithWhereWithoutAgreementInput = {
    where: ComboPlanAgreementScalarWhereInput
    data: XOR<ComboPlanAgreementUpdateManyMutationInput, ComboPlanAgreementUncheckedUpdateManyWithoutAgreementInput>
  }

  export type ComboPlanAgreementScalarWhereInput = {
    AND?: ComboPlanAgreementScalarWhereInput | ComboPlanAgreementScalarWhereInput[]
    OR?: ComboPlanAgreementScalarWhereInput[]
    NOT?: ComboPlanAgreementScalarWhereInput | ComboPlanAgreementScalarWhereInput[]
    id?: StringFilter<"ComboPlanAgreement"> | string
    comboPlanId?: StringFilter<"ComboPlanAgreement"> | string
    agreementId?: StringFilter<"ComboPlanAgreement"> | string
  }

  export type ServiceCreateWithoutAgreementsInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceTrading?: ServiceTradingCreateNestedOneWithoutServiceInput
    purchasedServices?: UserPurchasedServicesCreateNestedManyWithoutServiceInput
    userDocuments?: UserDocumentsCreateNestedManyWithoutServiceInput
    Transaction?: TransactionCreateNestedManyWithoutServiceInput
    ComboPlanService?: ComboPlanServiceCreateNestedManyWithoutServiceInput
    coupon?: CouponCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutAgreementsInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceTrading?: ServiceTradingUncheckedCreateNestedOneWithoutServiceInput
    purchasedServices?: UserPurchasedServicesUncheckedCreateNestedManyWithoutServiceInput
    userDocuments?: UserDocumentsUncheckedCreateNestedManyWithoutServiceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutServiceInput
    ComboPlanService?: ComboPlanServiceUncheckedCreateNestedManyWithoutServiceInput
    coupon?: CouponUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutAgreementsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutAgreementsInput, ServiceUncheckedCreateWithoutAgreementsInput>
  }

  export type AgreementCreateWithoutServiceAgreementsInput = {
    id?: string
    name: string
    content: JsonNullValueInput | InputJsonValue
    version: number
    hash: string
    signatoryPerson?: string | null
    companyName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    comboPlanAgreements?: ComboPlanAgreementCreateNestedManyWithoutAgreementInput
  }

  export type AgreementUncheckedCreateWithoutServiceAgreementsInput = {
    id?: string
    name: string
    content: JsonNullValueInput | InputJsonValue
    version: number
    hash: string
    signatoryPerson?: string | null
    companyName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    comboPlanAgreements?: ComboPlanAgreementUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type AgreementCreateOrConnectWithoutServiceAgreementsInput = {
    where: AgreementWhereUniqueInput
    create: XOR<AgreementCreateWithoutServiceAgreementsInput, AgreementUncheckedCreateWithoutServiceAgreementsInput>
  }

  export type ServiceUpsertWithoutAgreementsInput = {
    update: XOR<ServiceUpdateWithoutAgreementsInput, ServiceUncheckedUpdateWithoutAgreementsInput>
    create: XOR<ServiceCreateWithoutAgreementsInput, ServiceUncheckedCreateWithoutAgreementsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutAgreementsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutAgreementsInput, ServiceUncheckedUpdateWithoutAgreementsInput>
  }

  export type ServiceUpdateWithoutAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceTrading?: ServiceTradingUpdateOneWithoutServiceNestedInput
    purchasedServices?: UserPurchasedServicesUpdateManyWithoutServiceNestedInput
    userDocuments?: UserDocumentsUpdateManyWithoutServiceNestedInput
    Transaction?: TransactionUpdateManyWithoutServiceNestedInput
    ComboPlanService?: ComboPlanServiceUpdateManyWithoutServiceNestedInput
    coupon?: CouponUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceTrading?: ServiceTradingUncheckedUpdateOneWithoutServiceNestedInput
    purchasedServices?: UserPurchasedServicesUncheckedUpdateManyWithoutServiceNestedInput
    userDocuments?: UserDocumentsUncheckedUpdateManyWithoutServiceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutServiceNestedInput
    ComboPlanService?: ComboPlanServiceUncheckedUpdateManyWithoutServiceNestedInput
    coupon?: CouponUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type AgreementUpsertWithoutServiceAgreementsInput = {
    update: XOR<AgreementUpdateWithoutServiceAgreementsInput, AgreementUncheckedUpdateWithoutServiceAgreementsInput>
    create: XOR<AgreementCreateWithoutServiceAgreementsInput, AgreementUncheckedCreateWithoutServiceAgreementsInput>
    where?: AgreementWhereInput
  }

  export type AgreementUpdateToOneWithWhereWithoutServiceAgreementsInput = {
    where?: AgreementWhereInput
    data: XOR<AgreementUpdateWithoutServiceAgreementsInput, AgreementUncheckedUpdateWithoutServiceAgreementsInput>
  }

  export type AgreementUpdateWithoutServiceAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    hash?: StringFieldUpdateOperationsInput | string
    signatoryPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comboPlanAgreements?: ComboPlanAgreementUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementUncheckedUpdateWithoutServiceAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    hash?: StringFieldUpdateOperationsInput | string
    signatoryPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comboPlanAgreements?: ComboPlanAgreementUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type ComboPlanCreateWithoutAgreementInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    taxPercent?: number | null
    active?: boolean | null
    tenureDiscounts: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ComboPlanServiceCreateNestedManyWithoutComboPlanInput
    coupon?: CouponCreateNestedManyWithoutComboPlanInput
    Transaction?: TransactionCreateNestedManyWithoutComboPlanInput
  }

  export type ComboPlanUncheckedCreateWithoutAgreementInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    taxPercent?: number | null
    active?: boolean | null
    tenureDiscounts: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ComboPlanServiceUncheckedCreateNestedManyWithoutComboPlanInput
    coupon?: CouponUncheckedCreateNestedManyWithoutComboPlanInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutComboPlanInput
  }

  export type ComboPlanCreateOrConnectWithoutAgreementInput = {
    where: ComboPlanWhereUniqueInput
    create: XOR<ComboPlanCreateWithoutAgreementInput, ComboPlanUncheckedCreateWithoutAgreementInput>
  }

  export type AgreementCreateWithoutComboPlanAgreementsInput = {
    id?: string
    name: string
    content: JsonNullValueInput | InputJsonValue
    version: number
    hash: string
    signatoryPerson?: string | null
    companyName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    serviceAgreements?: ServiceAgreementCreateNestedManyWithoutAgreementInput
  }

  export type AgreementUncheckedCreateWithoutComboPlanAgreementsInput = {
    id?: string
    name: string
    content: JsonNullValueInput | InputJsonValue
    version: number
    hash: string
    signatoryPerson?: string | null
    companyName?: string | null
    updatedAt?: Date | string
    createdAt?: Date | string
    serviceAgreements?: ServiceAgreementUncheckedCreateNestedManyWithoutAgreementInput
  }

  export type AgreementCreateOrConnectWithoutComboPlanAgreementsInput = {
    where: AgreementWhereUniqueInput
    create: XOR<AgreementCreateWithoutComboPlanAgreementsInput, AgreementUncheckedCreateWithoutComboPlanAgreementsInput>
  }

  export type ComboPlanUpsertWithoutAgreementInput = {
    update: XOR<ComboPlanUpdateWithoutAgreementInput, ComboPlanUncheckedUpdateWithoutAgreementInput>
    create: XOR<ComboPlanCreateWithoutAgreementInput, ComboPlanUncheckedCreateWithoutAgreementInput>
    where?: ComboPlanWhereInput
  }

  export type ComboPlanUpdateToOneWithWhereWithoutAgreementInput = {
    where?: ComboPlanWhereInput
    data: XOR<ComboPlanUpdateWithoutAgreementInput, ComboPlanUncheckedUpdateWithoutAgreementInput>
  }

  export type ComboPlanUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenureDiscounts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ComboPlanServiceUpdateManyWithoutComboPlanNestedInput
    coupon?: CouponUpdateManyWithoutComboPlanNestedInput
    Transaction?: TransactionUpdateManyWithoutComboPlanNestedInput
  }

  export type ComboPlanUncheckedUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenureDiscounts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ComboPlanServiceUncheckedUpdateManyWithoutComboPlanNestedInput
    coupon?: CouponUncheckedUpdateManyWithoutComboPlanNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutComboPlanNestedInput
  }

  export type AgreementUpsertWithoutComboPlanAgreementsInput = {
    update: XOR<AgreementUpdateWithoutComboPlanAgreementsInput, AgreementUncheckedUpdateWithoutComboPlanAgreementsInput>
    create: XOR<AgreementCreateWithoutComboPlanAgreementsInput, AgreementUncheckedCreateWithoutComboPlanAgreementsInput>
    where?: AgreementWhereInput
  }

  export type AgreementUpdateToOneWithWhereWithoutComboPlanAgreementsInput = {
    where?: AgreementWhereInput
    data: XOR<AgreementUpdateWithoutComboPlanAgreementsInput, AgreementUncheckedUpdateWithoutComboPlanAgreementsInput>
  }

  export type AgreementUpdateWithoutComboPlanAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    hash?: StringFieldUpdateOperationsInput | string
    signatoryPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceAgreements?: ServiceAgreementUpdateManyWithoutAgreementNestedInput
  }

  export type AgreementUncheckedUpdateWithoutComboPlanAgreementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    version?: IntFieldUpdateOperationsInput | number
    hash?: StringFieldUpdateOperationsInput | string
    signatoryPerson?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceAgreements?: ServiceAgreementUncheckedUpdateManyWithoutAgreementNestedInput
  }

  export type ComboPlanAgreementCreateWithoutComboPlanInput = {
    id?: string
    agreement: AgreementCreateNestedOneWithoutComboPlanAgreementsInput
  }

  export type ComboPlanAgreementUncheckedCreateWithoutComboPlanInput = {
    id?: string
    agreementId: string
  }

  export type ComboPlanAgreementCreateOrConnectWithoutComboPlanInput = {
    where: ComboPlanAgreementWhereUniqueInput
    create: XOR<ComboPlanAgreementCreateWithoutComboPlanInput, ComboPlanAgreementUncheckedCreateWithoutComboPlanInput>
  }

  export type ComboPlanAgreementCreateManyComboPlanInputEnvelope = {
    data: ComboPlanAgreementCreateManyComboPlanInput | ComboPlanAgreementCreateManyComboPlanInput[]
    skipDuplicates?: boolean
  }

  export type ComboPlanServiceCreateWithoutComboPlanInput = {
    id?: string
    service: ServiceCreateNestedOneWithoutComboPlanServiceInput
  }

  export type ComboPlanServiceUncheckedCreateWithoutComboPlanInput = {
    id?: string
    serviceId: string
  }

  export type ComboPlanServiceCreateOrConnectWithoutComboPlanInput = {
    where: ComboPlanServiceWhereUniqueInput
    create: XOR<ComboPlanServiceCreateWithoutComboPlanInput, ComboPlanServiceUncheckedCreateWithoutComboPlanInput>
  }

  export type ComboPlanServiceCreateManyComboPlanInputEnvelope = {
    data: ComboPlanServiceCreateManyComboPlanInput | ComboPlanServiceCreateManyComboPlanInput[]
    skipDuplicates?: boolean
  }

  export type CouponCreateWithoutComboPlanInput = {
    id?: string
    code: string
    description?: string | null
    percentOff: number
    expiryDate: Date | string
    minAmount?: number
    maxAmount?: number | null
    planDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    service?: ServiceCreateNestedOneWithoutCouponInput
    transactions?: TransactionCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutComboPlanInput = {
    id?: string
    code: string
    description?: string | null
    percentOff: number
    expiryDate: Date | string
    minAmount?: number
    maxAmount?: number | null
    serviceId?: string | null
    planDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponCreateOrConnectWithoutComboPlanInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutComboPlanInput, CouponUncheckedCreateWithoutComboPlanInput>
  }

  export type CouponCreateManyComboPlanInputEnvelope = {
    data: CouponCreateManyComboPlanInput | CouponCreateManyComboPlanInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutComboPlanInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutTransactionInput
    service?: ServiceCreateNestedOneWithoutTransactionInput
    coupon?: CouponCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutComboPlanInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    couponId?: string | null
    userId: string
    serviceId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionCreateOrConnectWithoutComboPlanInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutComboPlanInput, TransactionUncheckedCreateWithoutComboPlanInput>
  }

  export type TransactionCreateManyComboPlanInputEnvelope = {
    data: TransactionCreateManyComboPlanInput | TransactionCreateManyComboPlanInput[]
    skipDuplicates?: boolean
  }

  export type ComboPlanAgreementUpsertWithWhereUniqueWithoutComboPlanInput = {
    where: ComboPlanAgreementWhereUniqueInput
    update: XOR<ComboPlanAgreementUpdateWithoutComboPlanInput, ComboPlanAgreementUncheckedUpdateWithoutComboPlanInput>
    create: XOR<ComboPlanAgreementCreateWithoutComboPlanInput, ComboPlanAgreementUncheckedCreateWithoutComboPlanInput>
  }

  export type ComboPlanAgreementUpdateWithWhereUniqueWithoutComboPlanInput = {
    where: ComboPlanAgreementWhereUniqueInput
    data: XOR<ComboPlanAgreementUpdateWithoutComboPlanInput, ComboPlanAgreementUncheckedUpdateWithoutComboPlanInput>
  }

  export type ComboPlanAgreementUpdateManyWithWhereWithoutComboPlanInput = {
    where: ComboPlanAgreementScalarWhereInput
    data: XOR<ComboPlanAgreementUpdateManyMutationInput, ComboPlanAgreementUncheckedUpdateManyWithoutComboPlanInput>
  }

  export type ComboPlanServiceUpsertWithWhereUniqueWithoutComboPlanInput = {
    where: ComboPlanServiceWhereUniqueInput
    update: XOR<ComboPlanServiceUpdateWithoutComboPlanInput, ComboPlanServiceUncheckedUpdateWithoutComboPlanInput>
    create: XOR<ComboPlanServiceCreateWithoutComboPlanInput, ComboPlanServiceUncheckedCreateWithoutComboPlanInput>
  }

  export type ComboPlanServiceUpdateWithWhereUniqueWithoutComboPlanInput = {
    where: ComboPlanServiceWhereUniqueInput
    data: XOR<ComboPlanServiceUpdateWithoutComboPlanInput, ComboPlanServiceUncheckedUpdateWithoutComboPlanInput>
  }

  export type ComboPlanServiceUpdateManyWithWhereWithoutComboPlanInput = {
    where: ComboPlanServiceScalarWhereInput
    data: XOR<ComboPlanServiceUpdateManyMutationInput, ComboPlanServiceUncheckedUpdateManyWithoutComboPlanInput>
  }

  export type ComboPlanServiceScalarWhereInput = {
    AND?: ComboPlanServiceScalarWhereInput | ComboPlanServiceScalarWhereInput[]
    OR?: ComboPlanServiceScalarWhereInput[]
    NOT?: ComboPlanServiceScalarWhereInput | ComboPlanServiceScalarWhereInput[]
    id?: StringFilter<"ComboPlanService"> | string
    comboPlanId?: StringFilter<"ComboPlanService"> | string
    serviceId?: StringFilter<"ComboPlanService"> | string
  }

  export type CouponUpsertWithWhereUniqueWithoutComboPlanInput = {
    where: CouponWhereUniqueInput
    update: XOR<CouponUpdateWithoutComboPlanInput, CouponUncheckedUpdateWithoutComboPlanInput>
    create: XOR<CouponCreateWithoutComboPlanInput, CouponUncheckedCreateWithoutComboPlanInput>
  }

  export type CouponUpdateWithWhereUniqueWithoutComboPlanInput = {
    where: CouponWhereUniqueInput
    data: XOR<CouponUpdateWithoutComboPlanInput, CouponUncheckedUpdateWithoutComboPlanInput>
  }

  export type CouponUpdateManyWithWhereWithoutComboPlanInput = {
    where: CouponScalarWhereInput
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyWithoutComboPlanInput>
  }

  export type CouponScalarWhereInput = {
    AND?: CouponScalarWhereInput | CouponScalarWhereInput[]
    OR?: CouponScalarWhereInput[]
    NOT?: CouponScalarWhereInput | CouponScalarWhereInput[]
    id?: StringFilter<"Coupon"> | string
    code?: StringFilter<"Coupon"> | string
    description?: StringNullableFilter<"Coupon"> | string | null
    percentOff?: FloatFilter<"Coupon"> | number
    expiryDate?: DateTimeFilter<"Coupon"> | Date | string
    minAmount?: FloatFilter<"Coupon"> | number
    maxAmount?: FloatNullableFilter<"Coupon"> | number | null
    serviceId?: StringNullableFilter<"Coupon"> | string | null
    comboPlanId?: StringNullableFilter<"Coupon"> | string | null
    planDays?: IntNullableFilter<"Coupon"> | number | null
    createdAt?: DateTimeFilter<"Coupon"> | Date | string
    updatedAt?: DateTimeFilter<"Coupon"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutComboPlanInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutComboPlanInput, TransactionUncheckedUpdateWithoutComboPlanInput>
    create: XOR<TransactionCreateWithoutComboPlanInput, TransactionUncheckedCreateWithoutComboPlanInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutComboPlanInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutComboPlanInput, TransactionUncheckedUpdateWithoutComboPlanInput>
  }

  export type TransactionUpdateManyWithWhereWithoutComboPlanInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutComboPlanInput>
  }

  export type ComboPlanCreateWithoutServicesInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    taxPercent?: number | null
    active?: boolean | null
    tenureDiscounts: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agreement?: ComboPlanAgreementCreateNestedManyWithoutComboPlanInput
    coupon?: CouponCreateNestedManyWithoutComboPlanInput
    Transaction?: TransactionCreateNestedManyWithoutComboPlanInput
  }

  export type ComboPlanUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    taxPercent?: number | null
    active?: boolean | null
    tenureDiscounts: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agreement?: ComboPlanAgreementUncheckedCreateNestedManyWithoutComboPlanInput
    coupon?: CouponUncheckedCreateNestedManyWithoutComboPlanInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutComboPlanInput
  }

  export type ComboPlanCreateOrConnectWithoutServicesInput = {
    where: ComboPlanWhereUniqueInput
    create: XOR<ComboPlanCreateWithoutServicesInput, ComboPlanUncheckedCreateWithoutServicesInput>
  }

  export type ServiceCreateWithoutComboPlanServiceInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: ServiceAgreementCreateNestedManyWithoutServiceInput
    serviceTrading?: ServiceTradingCreateNestedOneWithoutServiceInput
    purchasedServices?: UserPurchasedServicesCreateNestedManyWithoutServiceInput
    userDocuments?: UserDocumentsCreateNestedManyWithoutServiceInput
    Transaction?: TransactionCreateNestedManyWithoutServiceInput
    coupon?: CouponCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutComboPlanServiceInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: ServiceAgreementUncheckedCreateNestedManyWithoutServiceInput
    serviceTrading?: ServiceTradingUncheckedCreateNestedOneWithoutServiceInput
    purchasedServices?: UserPurchasedServicesUncheckedCreateNestedManyWithoutServiceInput
    userDocuments?: UserDocumentsUncheckedCreateNestedManyWithoutServiceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutServiceInput
    coupon?: CouponUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutComboPlanServiceInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutComboPlanServiceInput, ServiceUncheckedCreateWithoutComboPlanServiceInput>
  }

  export type ComboPlanUpsertWithoutServicesInput = {
    update: XOR<ComboPlanUpdateWithoutServicesInput, ComboPlanUncheckedUpdateWithoutServicesInput>
    create: XOR<ComboPlanCreateWithoutServicesInput, ComboPlanUncheckedCreateWithoutServicesInput>
    where?: ComboPlanWhereInput
  }

  export type ComboPlanUpdateToOneWithWhereWithoutServicesInput = {
    where?: ComboPlanWhereInput
    data: XOR<ComboPlanUpdateWithoutServicesInput, ComboPlanUncheckedUpdateWithoutServicesInput>
  }

  export type ComboPlanUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenureDiscounts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: ComboPlanAgreementUpdateManyWithoutComboPlanNestedInput
    coupon?: CouponUpdateManyWithoutComboPlanNestedInput
    Transaction?: TransactionUpdateManyWithoutComboPlanNestedInput
  }

  export type ComboPlanUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    tenureDiscounts?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreement?: ComboPlanAgreementUncheckedUpdateManyWithoutComboPlanNestedInput
    coupon?: CouponUncheckedUpdateManyWithoutComboPlanNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutComboPlanNestedInput
  }

  export type ServiceUpsertWithoutComboPlanServiceInput = {
    update: XOR<ServiceUpdateWithoutComboPlanServiceInput, ServiceUncheckedUpdateWithoutComboPlanServiceInput>
    create: XOR<ServiceCreateWithoutComboPlanServiceInput, ServiceUncheckedCreateWithoutComboPlanServiceInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutComboPlanServiceInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutComboPlanServiceInput, ServiceUncheckedUpdateWithoutComboPlanServiceInput>
  }

  export type ServiceUpdateWithoutComboPlanServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: ServiceAgreementUpdateManyWithoutServiceNestedInput
    serviceTrading?: ServiceTradingUpdateOneWithoutServiceNestedInput
    purchasedServices?: UserPurchasedServicesUpdateManyWithoutServiceNestedInput
    userDocuments?: UserDocumentsUpdateManyWithoutServiceNestedInput
    Transaction?: TransactionUpdateManyWithoutServiceNestedInput
    coupon?: CouponUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutComboPlanServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: ServiceAgreementUncheckedUpdateManyWithoutServiceNestedInput
    serviceTrading?: ServiceTradingUncheckedUpdateOneWithoutServiceNestedInput
    purchasedServices?: UserPurchasedServicesUncheckedUpdateManyWithoutServiceNestedInput
    userDocuments?: UserDocumentsUncheckedUpdateManyWithoutServiceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutServiceNestedInput
    coupon?: CouponUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceAgreementCreateWithoutServiceInput = {
    id?: string
    agreement: AgreementCreateNestedOneWithoutServiceAgreementsInput
  }

  export type ServiceAgreementUncheckedCreateWithoutServiceInput = {
    id?: string
    agreementId: string
  }

  export type ServiceAgreementCreateOrConnectWithoutServiceInput = {
    where: ServiceAgreementWhereUniqueInput
    create: XOR<ServiceAgreementCreateWithoutServiceInput, ServiceAgreementUncheckedCreateWithoutServiceInput>
  }

  export type ServiceAgreementCreateManyServiceInputEnvelope = {
    data: ServiceAgreementCreateManyServiceInput | ServiceAgreementCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceTradingCreateWithoutServiceInput = {
    buy_stock_list: JsonNullValueInput | InputJsonValue
    sell_stock_list: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTradingUncheckedCreateWithoutServiceInput = {
    buy_stock_list: JsonNullValueInput | InputJsonValue
    sell_stock_list: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTradingCreateOrConnectWithoutServiceInput = {
    where: ServiceTradingWhereUniqueInput
    create: XOR<ServiceTradingCreateWithoutServiceInput, ServiceTradingUncheckedCreateWithoutServiceInput>
  }

  export type UserPurchasedServicesCreateWithoutServiceInput = {
    id?: string
    purchaseDate?: Date | string
    expiryDate: Date | string
    planDays: number
    planDiscount: number
    agreementAcceptedAt?: Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutPurchasedServicesInput
  }

  export type UserPurchasedServicesUncheckedCreateWithoutServiceInput = {
    id?: string
    userId: string
    purchaseDate?: Date | string
    expiryDate: Date | string
    planDays: number
    planDiscount: number
    agreementAcceptedAt?: Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPurchasedServicesCreateOrConnectWithoutServiceInput = {
    where: UserPurchasedServicesWhereUniqueInput
    create: XOR<UserPurchasedServicesCreateWithoutServiceInput, UserPurchasedServicesUncheckedCreateWithoutServiceInput>
  }

  export type UserPurchasedServicesCreateManyServiceInputEnvelope = {
    data: UserPurchasedServicesCreateManyServiceInput | UserPurchasedServicesCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type UserDocumentsCreateWithoutServiceInput = {
    id?: string
    documentUrl: string
    reviewedDocumentUrl?: string | null
    status?: $Enums.DocumentStatus
    reviewedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDocumentsInput
  }

  export type UserDocumentsUncheckedCreateWithoutServiceInput = {
    id?: string
    userId: string
    documentUrl: string
    reviewedDocumentUrl?: string | null
    status?: $Enums.DocumentStatus
    reviewedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDocumentsCreateOrConnectWithoutServiceInput = {
    where: UserDocumentsWhereUniqueInput
    create: XOR<UserDocumentsCreateWithoutServiceInput, UserDocumentsUncheckedCreateWithoutServiceInput>
  }

  export type UserDocumentsCreateManyServiceInputEnvelope = {
    data: UserDocumentsCreateManyServiceInput | UserDocumentsCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutServiceInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutTransactionInput
    comboPlan?: ComboPlanCreateNestedOneWithoutTransactionInput
    coupon?: CouponCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutServiceInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    couponId?: string | null
    userId: string
    comboPlanId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionCreateOrConnectWithoutServiceInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutServiceInput, TransactionUncheckedCreateWithoutServiceInput>
  }

  export type TransactionCreateManyServiceInputEnvelope = {
    data: TransactionCreateManyServiceInput | TransactionCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ComboPlanServiceCreateWithoutServiceInput = {
    id?: string
    comboPlan: ComboPlanCreateNestedOneWithoutServicesInput
  }

  export type ComboPlanServiceUncheckedCreateWithoutServiceInput = {
    id?: string
    comboPlanId: string
  }

  export type ComboPlanServiceCreateOrConnectWithoutServiceInput = {
    where: ComboPlanServiceWhereUniqueInput
    create: XOR<ComboPlanServiceCreateWithoutServiceInput, ComboPlanServiceUncheckedCreateWithoutServiceInput>
  }

  export type ComboPlanServiceCreateManyServiceInputEnvelope = {
    data: ComboPlanServiceCreateManyServiceInput | ComboPlanServiceCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type CouponCreateWithoutServiceInput = {
    id?: string
    code: string
    description?: string | null
    percentOff: number
    expiryDate: Date | string
    minAmount?: number
    maxAmount?: number | null
    planDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comboPlan?: ComboPlanCreateNestedOneWithoutCouponInput
    transactions?: TransactionCreateNestedManyWithoutCouponInput
  }

  export type CouponUncheckedCreateWithoutServiceInput = {
    id?: string
    code: string
    description?: string | null
    percentOff: number
    expiryDate: Date | string
    minAmount?: number
    maxAmount?: number | null
    comboPlanId?: string | null
    planDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCouponInput
  }

  export type CouponCreateOrConnectWithoutServiceInput = {
    where: CouponWhereUniqueInput
    create: XOR<CouponCreateWithoutServiceInput, CouponUncheckedCreateWithoutServiceInput>
  }

  export type CouponCreateManyServiceInputEnvelope = {
    data: CouponCreateManyServiceInput | CouponCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceAgreementUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceAgreementWhereUniqueInput
    update: XOR<ServiceAgreementUpdateWithoutServiceInput, ServiceAgreementUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceAgreementCreateWithoutServiceInput, ServiceAgreementUncheckedCreateWithoutServiceInput>
  }

  export type ServiceAgreementUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceAgreementWhereUniqueInput
    data: XOR<ServiceAgreementUpdateWithoutServiceInput, ServiceAgreementUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceAgreementUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceAgreementScalarWhereInput
    data: XOR<ServiceAgreementUpdateManyMutationInput, ServiceAgreementUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceTradingUpsertWithoutServiceInput = {
    update: XOR<ServiceTradingUpdateWithoutServiceInput, ServiceTradingUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceTradingCreateWithoutServiceInput, ServiceTradingUncheckedCreateWithoutServiceInput>
    where?: ServiceTradingWhereInput
  }

  export type ServiceTradingUpdateToOneWithWhereWithoutServiceInput = {
    where?: ServiceTradingWhereInput
    data: XOR<ServiceTradingUpdateWithoutServiceInput, ServiceTradingUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceTradingUpdateWithoutServiceInput = {
    buy_stock_list?: JsonNullValueInput | InputJsonValue
    sell_stock_list?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTradingUncheckedUpdateWithoutServiceInput = {
    buy_stock_list?: JsonNullValueInput | InputJsonValue
    sell_stock_list?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPurchasedServicesUpsertWithWhereUniqueWithoutServiceInput = {
    where: UserPurchasedServicesWhereUniqueInput
    update: XOR<UserPurchasedServicesUpdateWithoutServiceInput, UserPurchasedServicesUncheckedUpdateWithoutServiceInput>
    create: XOR<UserPurchasedServicesCreateWithoutServiceInput, UserPurchasedServicesUncheckedCreateWithoutServiceInput>
  }

  export type UserPurchasedServicesUpdateWithWhereUniqueWithoutServiceInput = {
    where: UserPurchasedServicesWhereUniqueInput
    data: XOR<UserPurchasedServicesUpdateWithoutServiceInput, UserPurchasedServicesUncheckedUpdateWithoutServiceInput>
  }

  export type UserPurchasedServicesUpdateManyWithWhereWithoutServiceInput = {
    where: UserPurchasedServicesScalarWhereInput
    data: XOR<UserPurchasedServicesUpdateManyMutationInput, UserPurchasedServicesUncheckedUpdateManyWithoutServiceInput>
  }

  export type UserDocumentsUpsertWithWhereUniqueWithoutServiceInput = {
    where: UserDocumentsWhereUniqueInput
    update: XOR<UserDocumentsUpdateWithoutServiceInput, UserDocumentsUncheckedUpdateWithoutServiceInput>
    create: XOR<UserDocumentsCreateWithoutServiceInput, UserDocumentsUncheckedCreateWithoutServiceInput>
  }

  export type UserDocumentsUpdateWithWhereUniqueWithoutServiceInput = {
    where: UserDocumentsWhereUniqueInput
    data: XOR<UserDocumentsUpdateWithoutServiceInput, UserDocumentsUncheckedUpdateWithoutServiceInput>
  }

  export type UserDocumentsUpdateManyWithWhereWithoutServiceInput = {
    where: UserDocumentsScalarWhereInput
    data: XOR<UserDocumentsUpdateManyMutationInput, UserDocumentsUncheckedUpdateManyWithoutServiceInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutServiceInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutServiceInput, TransactionUncheckedUpdateWithoutServiceInput>
    create: XOR<TransactionCreateWithoutServiceInput, TransactionUncheckedCreateWithoutServiceInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutServiceInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutServiceInput, TransactionUncheckedUpdateWithoutServiceInput>
  }

  export type TransactionUpdateManyWithWhereWithoutServiceInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutServiceInput>
  }

  export type ComboPlanServiceUpsertWithWhereUniqueWithoutServiceInput = {
    where: ComboPlanServiceWhereUniqueInput
    update: XOR<ComboPlanServiceUpdateWithoutServiceInput, ComboPlanServiceUncheckedUpdateWithoutServiceInput>
    create: XOR<ComboPlanServiceCreateWithoutServiceInput, ComboPlanServiceUncheckedCreateWithoutServiceInput>
  }

  export type ComboPlanServiceUpdateWithWhereUniqueWithoutServiceInput = {
    where: ComboPlanServiceWhereUniqueInput
    data: XOR<ComboPlanServiceUpdateWithoutServiceInput, ComboPlanServiceUncheckedUpdateWithoutServiceInput>
  }

  export type ComboPlanServiceUpdateManyWithWhereWithoutServiceInput = {
    where: ComboPlanServiceScalarWhereInput
    data: XOR<ComboPlanServiceUpdateManyMutationInput, ComboPlanServiceUncheckedUpdateManyWithoutServiceInput>
  }

  export type CouponUpsertWithWhereUniqueWithoutServiceInput = {
    where: CouponWhereUniqueInput
    update: XOR<CouponUpdateWithoutServiceInput, CouponUncheckedUpdateWithoutServiceInput>
    create: XOR<CouponCreateWithoutServiceInput, CouponUncheckedCreateWithoutServiceInput>
  }

  export type CouponUpdateWithWhereUniqueWithoutServiceInput = {
    where: CouponWhereUniqueInput
    data: XOR<CouponUpdateWithoutServiceInput, CouponUncheckedUpdateWithoutServiceInput>
  }

  export type CouponUpdateManyWithWhereWithoutServiceInput = {
    where: CouponScalarWhereInput
    data: XOR<CouponUpdateManyMutationInput, CouponUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceCreateWithoutServiceTradingInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: ServiceAgreementCreateNestedManyWithoutServiceInput
    purchasedServices?: UserPurchasedServicesCreateNestedManyWithoutServiceInput
    userDocuments?: UserDocumentsCreateNestedManyWithoutServiceInput
    Transaction?: TransactionCreateNestedManyWithoutServiceInput
    ComboPlanService?: ComboPlanServiceCreateNestedManyWithoutServiceInput
    coupon?: CouponCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutServiceTradingInput = {
    id?: string
    name: string
    slug: string
    tag?: string | null
    label?: string | null
    serviceClass?: string | null
    description?: string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: string | null
    recommendation?: ServiceCreaterecommendationInput | string[]
    price?: string | null
    taxPercent?: number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: boolean | null
    type: $Enums.ServiceType
    createdAt?: Date | string
    updatedAt?: Date | string
    agreements?: ServiceAgreementUncheckedCreateNestedManyWithoutServiceInput
    purchasedServices?: UserPurchasedServicesUncheckedCreateNestedManyWithoutServiceInput
    userDocuments?: UserDocumentsUncheckedCreateNestedManyWithoutServiceInput
    Transaction?: TransactionUncheckedCreateNestedManyWithoutServiceInput
    ComboPlanService?: ComboPlanServiceUncheckedCreateNestedManyWithoutServiceInput
    coupon?: CouponUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutServiceTradingInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceTradingInput, ServiceUncheckedCreateWithoutServiceTradingInput>
  }

  export type ServiceUpsertWithoutServiceTradingInput = {
    update: XOR<ServiceUpdateWithoutServiceTradingInput, ServiceUncheckedUpdateWithoutServiceTradingInput>
    create: XOR<ServiceCreateWithoutServiceTradingInput, ServiceUncheckedCreateWithoutServiceTradingInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutServiceTradingInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutServiceTradingInput, ServiceUncheckedUpdateWithoutServiceTradingInput>
  }

  export type ServiceUpdateWithoutServiceTradingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: ServiceAgreementUpdateManyWithoutServiceNestedInput
    purchasedServices?: UserPurchasedServicesUpdateManyWithoutServiceNestedInput
    userDocuments?: UserDocumentsUpdateManyWithoutServiceNestedInput
    Transaction?: TransactionUpdateManyWithoutServiceNestedInput
    ComboPlanService?: ComboPlanServiceUpdateManyWithoutServiceNestedInput
    coupon?: CouponUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServiceTradingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
    serviceClass?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    chart?: NullableJsonNullValueInput | InputJsonValue
    comparisonTitle?: NullableStringFieldUpdateOperationsInput | string | null
    recommendation?: ServiceUpdaterecommendationInput | string[]
    price?: NullableStringFieldUpdateOperationsInput | string | null
    taxPercent?: NullableFloatFieldUpdateOperationsInput | number | null
    tenureDiscounts?: NullableJsonNullValueInput | InputJsonValue
    features?: NullableJsonNullValueInput | InputJsonValue
    faq?: NullableJsonNullValueInput | InputJsonValue
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agreements?: ServiceAgreementUncheckedUpdateManyWithoutServiceNestedInput
    purchasedServices?: UserPurchasedServicesUncheckedUpdateManyWithoutServiceNestedInput
    userDocuments?: UserDocumentsUncheckedUpdateManyWithoutServiceNestedInput
    Transaction?: TransactionUncheckedUpdateManyWithoutServiceNestedInput
    ComboPlanService?: ComboPlanServiceUncheckedUpdateManyWithoutServiceNestedInput
    coupon?: CouponUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type AccountCreateManyUserInput = {
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserDocumentsCreateManyUserInput = {
    id?: string
    serviceId: string
    documentUrl: string
    reviewedDocumentUrl?: string | null
    status?: $Enums.DocumentStatus
    reviewedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPurchasedServicesCreateManyUserInput = {
    id?: string
    serviceId: string
    purchaseDate?: Date | string
    expiryDate: Date | string
    planDays: number
    planDiscount: number
    agreementAcceptedAt?: Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type panVerificationDataCreateManyUserInput = {
    provider: string
    result: JsonNullValueInput | InputJsonValue
    status: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    couponId?: string | null
    serviceId?: string | null
    comboPlanId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type AccountUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDocumentsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    reviewedDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutUserDocumentsNestedInput
  }

  export type UserDocumentsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    reviewedDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDocumentsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    reviewedDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPurchasedServicesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planDays?: IntFieldUpdateOperationsInput | number
    planDiscount?: FloatFieldUpdateOperationsInput | number
    agreementAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
    service?: ServiceUpdateOneRequiredWithoutPurchasedServicesNestedInput
  }

  export type UserPurchasedServicesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planDays?: IntFieldUpdateOperationsInput | number
    planDiscount?: FloatFieldUpdateOperationsInput | number
    agreementAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPurchasedServicesUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planDays?: IntFieldUpdateOperationsInput | number
    planDiscount?: FloatFieldUpdateOperationsInput | number
    agreementAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type panVerificationDataUpdateWithoutUserInput = {
    provider?: StringFieldUpdateOperationsInput | string
    result?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type panVerificationDataUncheckedUpdateWithoutUserInput = {
    provider?: StringFieldUpdateOperationsInput | string
    result?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type panVerificationDataUncheckedUpdateManyWithoutUserInput = {
    provider?: StringFieldUpdateOperationsInput | string
    result?: JsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    service?: ServiceUpdateOneWithoutTransactionNestedInput
    comboPlan?: ComboPlanUpdateOneWithoutTransactionNestedInput
    coupon?: CouponUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    comboPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    comboPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionCreateManyCouponInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    userId: string
    serviceId?: string | null
    comboPlanId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutTransactionNestedInput
    service?: ServiceUpdateOneWithoutTransactionNestedInput
    comboPlan?: ComboPlanUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    comboPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionUncheckedUpdateManyWithoutCouponInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    comboPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ServiceAgreementCreateManyAgreementInput = {
    id?: string
    serviceId: string
  }

  export type ComboPlanAgreementCreateManyAgreementInput = {
    id?: string
    comboPlanId: string
  }

  export type ServiceAgreementUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: ServiceUpdateOneRequiredWithoutAgreementsNestedInput
  }

  export type ServiceAgreementUncheckedUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceAgreementUncheckedUpdateManyWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ComboPlanAgreementUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    comboPlan?: ComboPlanUpdateOneRequiredWithoutAgreementNestedInput
  }

  export type ComboPlanAgreementUncheckedUpdateWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    comboPlanId?: StringFieldUpdateOperationsInput | string
  }

  export type ComboPlanAgreementUncheckedUpdateManyWithoutAgreementInput = {
    id?: StringFieldUpdateOperationsInput | string
    comboPlanId?: StringFieldUpdateOperationsInput | string
  }

  export type ComboPlanAgreementCreateManyComboPlanInput = {
    id?: string
    agreementId: string
  }

  export type ComboPlanServiceCreateManyComboPlanInput = {
    id?: string
    serviceId: string
  }

  export type CouponCreateManyComboPlanInput = {
    id?: string
    code: string
    description?: string | null
    percentOff: number
    expiryDate: Date | string
    minAmount?: number
    maxAmount?: number | null
    serviceId?: string | null
    planDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyComboPlanInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    couponId?: string | null
    userId: string
    serviceId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ComboPlanAgreementUpdateWithoutComboPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreement?: AgreementUpdateOneRequiredWithoutComboPlanAgreementsNestedInput
  }

  export type ComboPlanAgreementUncheckedUpdateWithoutComboPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreementId?: StringFieldUpdateOperationsInput | string
  }

  export type ComboPlanAgreementUncheckedUpdateManyWithoutComboPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreementId?: StringFieldUpdateOperationsInput | string
  }

  export type ComboPlanServiceUpdateWithoutComboPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    service?: ServiceUpdateOneRequiredWithoutComboPlanServiceNestedInput
  }

  export type ComboPlanServiceUncheckedUpdateWithoutComboPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ComboPlanServiceUncheckedUpdateManyWithoutComboPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type CouponUpdateWithoutComboPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: FloatFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    planDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutCouponNestedInput
    transactions?: TransactionUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutComboPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: FloatFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    planDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateManyWithoutComboPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: FloatFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    planDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutComboPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutTransactionNestedInput
    service?: ServiceUpdateOneWithoutTransactionNestedInput
    coupon?: CouponUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutComboPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionUncheckedUpdateManyWithoutComboPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ServiceAgreementCreateManyServiceInput = {
    id?: string
    agreementId: string
  }

  export type UserPurchasedServicesCreateManyServiceInput = {
    id?: string
    userId: string
    purchaseDate?: Date | string
    expiryDate: Date | string
    planDays: number
    planDiscount: number
    agreementAcceptedAt?: Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserDocumentsCreateManyServiceInput = {
    id?: string
    userId: string
    documentUrl: string
    reviewedDocumentUrl?: string | null
    status?: $Enums.DocumentStatus
    reviewedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyServiceInput = {
    id?: string
    orderId?: string | null
    paymentId?: string | null
    couponId?: string | null
    userId: string
    comboPlanId?: string | null
    amount: number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: string
    status: string
    paymentGateway: string
    idempotencyKey?: string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ComboPlanServiceCreateManyServiceInput = {
    id?: string
    comboPlanId: string
  }

  export type CouponCreateManyServiceInput = {
    id?: string
    code: string
    description?: string | null
    percentOff: number
    expiryDate: Date | string
    minAmount?: number
    maxAmount?: number | null
    comboPlanId?: string | null
    planDays?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceAgreementUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreement?: AgreementUpdateOneRequiredWithoutServiceAgreementsNestedInput
  }

  export type ServiceAgreementUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreementId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceAgreementUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    agreementId?: StringFieldUpdateOperationsInput | string
  }

  export type UserPurchasedServicesUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planDays?: IntFieldUpdateOperationsInput | number
    planDiscount?: FloatFieldUpdateOperationsInput | number
    agreementAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutPurchasedServicesNestedInput
  }

  export type UserPurchasedServicesUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planDays?: IntFieldUpdateOperationsInput | number
    planDiscount?: FloatFieldUpdateOperationsInput | number
    agreementAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserPurchasedServicesUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    planDays?: IntFieldUpdateOperationsInput | number
    planDiscount?: FloatFieldUpdateOperationsInput | number
    agreementAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agreementData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserDocumentsUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    reviewedDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type UserDocumentsUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    reviewedDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserDocumentsUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    reviewedDocumentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutTransactionNestedInput
    comboPlan?: ComboPlanUpdateOneWithoutTransactionNestedInput
    coupon?: CouponUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    comboPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type TransactionUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    couponId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    comboPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    tenure?: NullableJsonNullValueInput | InputJsonValue
    currency?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    paymentGateway?: StringFieldUpdateOperationsInput | string
    idempotencyKey?: NullableStringFieldUpdateOperationsInput | string | null
    webhookResponse?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extraData?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ComboPlanServiceUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    comboPlan?: ComboPlanUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ComboPlanServiceUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    comboPlanId?: StringFieldUpdateOperationsInput | string
  }

  export type ComboPlanServiceUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    comboPlanId?: StringFieldUpdateOperationsInput | string
  }

  export type CouponUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: FloatFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    planDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comboPlan?: ComboPlanUpdateOneWithoutCouponNestedInput
    transactions?: TransactionUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: FloatFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    comboPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    planDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCouponNestedInput
  }

  export type CouponUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    percentOff?: FloatFieldUpdateOperationsInput | number
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    minAmount?: FloatFieldUpdateOperationsInput | number
    maxAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    comboPlanId?: NullableStringFieldUpdateOperationsInput | string | null
    planDays?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}